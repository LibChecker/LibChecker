{
  "profile": "Default",
  "groups": [
    {
      "name": "Language injection",
      "inspections": [
        {
          "shortName": "InjectionNotApplicable",
          "displayName": "Injection Annotation not applicable",
          "enabled": false,
          "description": "Reports when a `@Language` annotation is applied to an element with a type other than `String` or `String[]`.\n\n**Example:**\n\n\n      @Language(\"HTML\") int i;\n\nAfter the quick-fix is applied:\n\n\n      int i;\n"
        },
        {
          "shortName": "UnknownLanguage",
          "displayName": "Unknown Language ID",
          "enabled": false,
          "description": "Reports when the ID of the language used in a `@Language` annotation is unknown.\n\n**Example:**\n\n\n      @Language(\"HMTL\") String html;\n"
        },
        {
          "shortName": "LanguageMismatch",
          "displayName": "Language mismatch",
          "enabled": false,
          "description": "Reports when the language of a reference does not match the expected language of the usage context.\n\nExample:\n\n\n      @Language(\"JavaScript\")\n      String JS_CODE = \"var x;\";\n\n      @Language(\"XPath\")\n      String XPATH_CODE = JS_CODE; // warning here\n"
        }
      ]
    },
    {
      "name": "Maven",
      "inspections": [
        {
          "shortName": "MavenRedundantGroupId",
          "displayName": "Redundant groupId",
          "enabled": false,
          "description": "Reports the unnecessary \\<groupId\\> definition since it is already defined in the parent pom.xml"
        },
        {
          "shortName": "MavenDuplicatePluginInspection",
          "displayName": "Duplicate plugin declaration",
          "enabled": false,
          "description": "Reports the duplication of the plugin declaration in pom.xml"
        },
        {
          "shortName": "MavenPropertyInParent",
          "displayName": "Usage of properties in parent description",
          "enabled": false,
          "description": "Reports that the usage of properties in modules parent definition is prohibited"
        },
        {
          "shortName": "MavenDuplicateDependenciesInspection",
          "displayName": "Duplicate Dependencies",
          "enabled": false,
          "description": "Reports duplicate dependencies"
        },
        {
          "shortName": "MavenModelInspection",
          "displayName": "Maven Model Inspection",
          "enabled": false,
          "description": "Reports resolution problems in a Maven model"
        },
        {
          "shortName": "MavenParentMissedVersionInspection",
          "displayName": "Parent version missed",
          "enabled": false,
          "description": "Reports the absence of the parent version element for versions that do not support consumer POM feature"
        },
        {
          "shortName": "MavenCoroutinesDeprecation",
          "displayName": "Incompatible kotlinx.coroutines dependency is used with Kotlin 1.3+ in Maven",
          "enabled": true,
          "description": "Reports **kotlinx.coroutines** library dependencies in Maven that should be updated in order to be compatible with Kotlin 1.3 and later."
        }
      ]
    },
    {
      "name": "JVM languages",
      "inspections": [
        {
          "shortName": "OverrideOnly",
          "displayName": "Method can only be overridden",
          "enabled": true,
          "description": "Reports calls to API methods marked with `@ApiStatus.OverrideOnly`.\n\n\nThe `@ApiStatus.OverrideOnly` annotation indicates that the method is part of SPI (Service Provider Interface).\nClients of the declaring library should implement or override such methods, not call them directly.\nMarking a class or interface with this annotation is the same as marking every method with it."
        },
        {
          "shortName": "MissingDeprecatedAnnotationOnScheduledForRemovalApi",
          "displayName": "Missing '@Deprecated' annotation on scheduled for removal API",
          "enabled": true,
          "description": "Reports declarations marked with `@ApiStatus.ScheduledForRemoval` without `@Deprecated`.\n\nExample:\n\n```\n  @ApiStatus.ScheduledForRemoval(inVersion = \"2017.3\")\n  public void myLegacyMethod() { }\n```\n\nAfter the quick-fix is applied the result looks like:\n\n```\n  @Deprecated\n  @ApiStatus.ScheduledForRemoval(inVersion = \"2017.3\")\n  public void myLegacyMethod() { }\n```"
        },
        {
          "shortName": "SourceToSinkFlow",
          "displayName": "Non-safe string is passed to safe method",
          "enabled": false,
          "description": "Reports cases when non-safe string is passed to a method with parameter marked with annotation `org.checkerframework.checker.tainting.qual.Untainted`.\n\n\nSafe string is:\n\n* call of method that is marked as `@Untainted`\n* local variable or method parameter that does not call non-safe methods\n* field, local variable or parameter that is marked as `@Untainted` and does not have non-safe methods calls assigned\n\n\nExample:\n\n\n      void doSmth(boolean b) {\n        String s = safe();\n        String s1 = \"other\";\n        if (b) s1 = s;\n        sink(s);\n      }\n      \n      String sink(@Untainted String s) {}\n\n\nHere we do not have non-safe string assignments to `s` so warning is not produced. On the other hand:\n\n\n      void doSmth(boolean b) {\n        String s = safe();\n        String s1 = \"other\";\n        s1 = foo();\n        if (b) s = s1;\n        sink(s);        // warning here\n      }\n      \n      String foo();\n\n      String sink(@Untainted String s) {}\n\n\nHere we have a warning since `s1` has an unknown state after `foo` call result assignment.\n\nNew in 2021.2"
        },
        {
          "shortName": "SerializableHasSerialVersionUIDField",
          "displayName": "Serializable class without 'serialVersionUID'",
          "enabled": false,
          "description": "Reports classes that implement `Serializable` and do not declare a `serialVersionUID` field.\n\n\nWithout a `serialVersionUID` field, any change to the class will make previously serialized versions unreadable.\n\n**Example:**\n\n\n      class Main implements Serializable {\n      }\n\nAfter the quick-fix is applied:\n\n\n      class Main implements Serializable {\n        private static final long serialVersionUID = -1446398935944895849L;\n      }\n\nWhen using a language level of JDK 14 or higher, the quickfix will also add the `java.io.Serial` annotation.\n\nUse the following options to configure the inspection:\n\n* List classes whose inheritors should not be reported by this inspection. This is meant for classes that inherit `Serializable` from a superclass but are not intended for serialization.\n* Whether to ignore `Serializable` anonymous classes."
        },
        {
          "shortName": "Dependency",
          "displayName": "Illegal package dependencies",
          "enabled": true,
          "description": "Reports illegal dependencies between scopes according to the dependency rules given. Dependency rules can be used to prohibit usage from a scope to another scope.\n\nUse the **Configure dependency rules** button below to customize validation rules."
        },
        {
          "shortName": "ThreadRun",
          "displayName": "Call to 'Thread.run()'",
          "enabled": true,
          "description": "Reports calls to `run()` on `java.lang.Thread` or any of its subclasses.\n\n\nWhile occasionally intended, this is usually a mistake, because `run()` doesn't start a new thread.\nTo execute the code in a separate thread, `start()` should be used."
        },
        {
          "shortName": "UnstableApiUsage",
          "displayName": "Unstable API Usage",
          "enabled": true,
          "description": "Reports usages of an API marked with one of the annotations as unstable. Such an API may be changed or removed in future versions, breaking the code that uses it.\n\nThe annotations which are used to mark unstable APIs are shown in the list below.\n\nBy default, the inspection ignores usages of unstable APIs\nif their declarations are located in sources of the same project. In such cases it'll be possible to update the usages when you change APIs.\nHowever, it may be inconvenient if the project is big, so one can switch off the **Ignore API declared in this project** option to report\nthe usages of unstable APIs declared in both the project sources and libraries."
        },
        {
          "shortName": "Since15",
          "displayName": "Usages of API which isn't available at the configured language level",
          "enabled": false,
          "description": "Reports usages of the API that is unavailable at the configured language level. This inspection does 3 things:\n\n* Highlight usage of generified classes when the language level is below Java 7.\n* Highlight when default methods are not overridden and the language level is below Java 8.\n* Highlight usage of API when the language level is lower than marked using the `@since` tag in the documentation.\n\n\nUse the **Forbid API usages** option to forbid usages of the API in respect to the project or custom language level."
        },
        {
          "shortName": "MustAlreadyBeRemovedApi",
          "displayName": "API must already be removed",
          "enabled": true,
          "description": "Reports declarations marked with `@ApiStatus.ScheduledForRemoval` that should have been removed in the current version of the declaring library.\n\nIt compares the specified scheduled removal version with the version that you can set below.\n\n\nSpecify the version as a string separated with dots and optionally postfixed with\n`alpha`, `beta`, `snapshot`, or `eap`.\n\nExamples of valid versions: `1.0`, `2.3.1`, `2018.1`, `7.5-snapshot`, `3.0-eap`.\n\n\nVersion comparison is intuitive: `1.0 < 2.0`, `1.0-eap < 1.0`, `2.3-snapshot < 2.3` and so on.\nFor detailed comparison logic, refer to the implementation of [VersionComparatorUtil](https://github.com/JetBrains/intellij-community/blob/master/platform/util-rt/src/com/intellij/util/text/VersionComparatorUtil.java)."
        },
        {
          "shortName": "JUnitRule",
          "displayName": "Malformed @Rule/@ClassRule field",
          "enabled": false,
          "description": "Reports malformed `@Rule` or `@ClassRule` annotation usages. Tests with malformed [rules](https://github.com/junit-team/junit4/wiki/Rules) cannot be run.\n\n* A `@Rule` annotated member must be `public` and a subtype of `org.junit.rules.TestRule` or `org.junit.rules.MethodRule`\n* A `@ClassRule` annotated member must be `public` and `static` and a subtype of `org.junit.rules.TestRule`\n\nFor example:\n\n\n      public class MomentousTest {\n        @Rule\n        private final TemporaryFolder tempFolder =\n          new TemporaryFolder();\n\n        // ... tests go here\n      }\n\nA quick fix is provided to fix the modifiers:\n\n\n      public class MomentousTest {\n        @Rule\n        public final TemporaryFolder tempFolder =\n          new TemporaryFolder();\n\n        // ... tests go here\n      }\n"
        },
        {
          "shortName": "TestFailedLine",
          "displayName": "Failed line in test",
          "enabled": true,
          "description": "Reports failed method calls or assertions in tests. It helps detect the failed line in code faster and start debugging it immediately.\n\n**Example:**\n\n\n      @Test\n      fun foo() {\n        assertEquals(1, 0) // highlighted\n      }\n"
        },
        {
          "shortName": "UnstableTypeUsedInSignature",
          "displayName": "Unstable type is used in signature",
          "enabled": true,
          "description": "Reports declarations of classes, methods, and fields that reference an unstable API type in the signature, but are not marked with the same unstable annotation.\n\n\nThis inspection ensures that the signatures of a public API do not expose any *unstable* (internal, experimental) types.\nFor example, if a method returns an *experimental* class, the method itself is considered *experimental*\nbecause incompatible changes of the type (deletion or move to another package) lead to incompatible method signature changes.\n\nUse the list below to specify which annotations mark an unstable API."
        },
        {
          "shortName": "JUnit5AssertionsConverter",
          "displayName": "Obsolete assertions in JUnit 5 tests",
          "enabled": false,
          "description": "Reports any calls to methods from the `junit.framework.Assert`, `org.junit.Assert`, or `org.junit.Assume`\nclasses inside JUnit 5 tests.\n\nAlthough the tests work properly, migration to `org.junit.jupiter.api.Assertions`/`org.junit.jupiter.api.Assumptions`\nwill help you avoid dependencies on old JUnit version.\n\n**Example:**\n\n\n      import org.junit.Assert;\n      import org.junit.jupiter.api.Test;\n\n      public class MyTest {\n        @Test\n        public void simpleTest() {\n          Assert.assertEquals(4, 2 + 2);\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      import org.junit.jupiter.api.Assertions;\n      import org.junit.jupiter.api.Test;\n\n      public class MyTest {\n        @Test\n        public void simpleTest() {\n          Assertions.assertEquals(4, 2 + 2);\n        }\n      }\n"
        },
        {
          "shortName": "TestOnlyProblems",
          "displayName": "Test-only usage in production code",
          "enabled": false,
          "description": "Reports `@TestOnly`- and `@VisibleForTesting`-annotated methods and classes that are used in production code. Also reports usage of applying `@TestOnly` `@VisibleForTesting` to the same element.\n\nThe problems are not reported if such method or class is referenced from:\n\n* Code under the **Test Sources** folder\n* A test class (JUnit/TestNG)\n* Another `@TestOnly`-annotated method\n\n**Example (in production code):**\n\n\n      @TestOnly\n      fun foo() { ... }\n\n      fun main () {\n        foo()\n      }\n"
        },
        {
          "shortName": "JUnit5Converter",
          "displayName": "JUnit 4 test can be JUnit 5",
          "enabled": false,
          "description": "Reports JUnit 4 tests that can be automatically migrated to JUnit 5. While default runners are automatically convertible, custom runners, method- and field- rules are not and require manual changes.\n\n**Example:**\n\n\n      import org.junit.Assert;\n      import org.junit.Test;\n\n      public class RelevantTest {\n        @Test\n        public void testIt() {\n          Assert.assertEquals(\"expected\", \"actual\");\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      import org.junit.jupiter.api.Assertions;\n      import org.junit.jupiter.api.Test;\n\n      public class RelevantTest {\n        @Test\n        public void testIt() {\n          Assertions.assertEquals(\"expected\", \"actual\");\n        }\n      }\n\nThis inspection requires that the JUnit 5 library is available in the classpath, and JDK 1.8 or later is configured for the project."
        },
        {
          "shortName": "BlockingMethodInNonBlockingContext",
          "displayName": "Possibly blocking call in non-blocking context",
          "enabled": true,
          "description": "Reports thread-blocking method calls in code fragments where threads should not be blocked.\n\n**Example (Project Reactor):**\n\n\n    Flux.just(\"1\").flatMap(f -> {\n        Flux<String> just = loadUsersFromDatabase();\n        just.toIterable(); // Error: blocking operator call in non-blocking scope\n        return just;\n      }\n    );\n\nConsider running blocking code [with a proper\nscheduler](https://projectreactor.io/docs/core/release/reference/#faq.wrap-blocking), for example `Schedulers.boundedElastic()`, or try to find an alternative non-blocking API.\n\n**Example (Kotlin Coroutines):**\n\n\n    suspend fun exampleFun() {\n        Thread.sleep(100); // Error: blocking method call inside suspend function\n    }\n\nConsider running blocking code [with a special dispatcher](https://kotlinlang.org/docs/coroutine-context-and-dispatchers.html),\nfor example `Dispatchers.IO`, or try to find an alternative non-blocking API.\n\nConfigure the inspection:\n\n* In the **Blocking Annotations** list, specify annotations that mark thread-blocking methods.\n* In the **Non-Blocking Annotations** list, specify annotations that mark non-blocking methods.\n\nSpecified annotations can be used as [External Annotations](https://www.jetbrains.com/help/idea/external-annotations.html)"
        },
        {
          "shortName": "NonExtendableApiUsage",
          "displayName": "Class, interface, or method should not be extended",
          "enabled": true,
          "description": "Reports classes, interfaces and methods that extend, implement, or override API elements marked with `@ApiStatus.NonExtendable`.\n\n\nThe `@ApiStatus.NonExtendable` annotation indicates that the class, interface, or method **must not be extended,\nimplemented, or overridden** .\nSince casting such interfaces and classes to the internal library implementation is rather common,\nif a client provides a different implementation, you will get `ClassCastException`.\nAdding new abstract methods to such classes and interfaces will break the compatibility with the client's implementations."
        },
        {
          "shortName": "IllegalDependencyOnInternalPackage",
          "displayName": "Illegal dependency on internal package",
          "enabled": false,
          "description": "Reports references in modules without `module-info.java` on packages which are not exported from named modules.\n\nSuch configuration may occur when some modules in the project are already migrated to Java modules but others are still non-modular.\nBy analogy to the JDK, such non-modular code should not get access to the code in named modules which is not explicitly exported."
        }
      ]
    },
    {
      "name": "Kotlin",
      "inspections": [
        {
          "shortName": "KotlinMavenPluginPhase",
          "displayName": "Kotlin Maven Plugin misconfigured",
          "enabled": true,
          "description": "Reports kotlin-maven-plugin configuration issues"
        },
        {
          "shortName": "KotlinInvalidBundleOrProperty",
          "displayName": "Invalid property key",
          "enabled": true,
          "description": "Reports unresolved references to `.properties` file keys and resource bundles in Kotlin files."
        },
        {
          "shortName": "KotlinTestJUnit",
          "displayName": "kotlin-test-junit could be used",
          "enabled": true,
          "description": "Reports usage of `kotlin-test` and `junit` dependency without `kotlin-test-junit`.\n\nIt is recommended to use `kotlin-test-junit` dependency to work with Kotlin and JUnit."
        },
        {
          "shortName": "DeprecatedGradleDependency",
          "displayName": "Deprecated library is used in Gradle",
          "enabled": true,
          "description": "Reports deprecated dependencies in Gradle build scripts.\n\n**Example:**\n\n\n      dependencies {\n          compile \"org.jetbrains.kotlin:kotlin-stdlib-jre7:1.2.0\"\n      }\n\nAfter the quick-fix applied:\n\n\n      dependencies {\n          compile \"org.jetbrains.kotlin:kotlin-stdlib-jdk7:1.2.0\"\n      }\n"
        },
        {
          "shortName": "DifferentKotlinGradleVersion",
          "displayName": "Kotlin Gradle and IDE plugins versions are different",
          "enabled": true,
          "description": "Reports that different IDE and Gradle plugin versions are used.\n\nThis can cause inconsistencies between IDE and Gradle builds in error reporting or code behavior.\n\n**Example:**\n\n\n      dependencies {\n        classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:0.0.1\"\n      }\n\nTo fix the problem change the kotlin gradle plugin version to match the version of kotlin that is bundled into the IDE plugin."
        },
        {
          "shortName": "DeprecatedMavenDependency",
          "displayName": "Deprecated library is used in Maven",
          "enabled": true,
          "description": "Reports deprecated maven dependency.\n\n**Example:**\n\n\n      <dependencies>\n        <dependency>\n            <groupId>org.jetbrains.kotlin</groupId>\n            <artifactId>kotlin-stdlib-jre7</artifactId>\n            <version>${kotlin.version}</version>\n        </dependency>\n      </dependencies>\n\nThe quick fix changes the deprecated dependency to a maintained one:\n\n\n       <dependencies>\n        <dependency>\n            <groupId>org.jetbrains.kotlin</groupId>\n            <artifactId>kotlin-stdlib-jdk7</artifactId>\n            <version>${kotlin.version}</version>\n        </dependency>\n      </dependencies>\n"
        },
        {
          "shortName": "DifferentStdlibGradleVersion",
          "displayName": "Kotlin library and Gradle plugin versions are different",
          "enabled": true,
          "description": "Reports different Kotlin stdlib and compiler versions.\n\n**Example:**\n\n\n      dependencies {\n        classpath \"org.jetbrains.kotlin:kotlin-stdlib:0.0.1\"\n      }\n\nTo fix the problem change the kotlin stdlib version to match the kotlin compiler version."
        },
        {
          "shortName": "DifferentMavenStdlibVersion",
          "displayName": "Library and maven plugin versions are different",
          "enabled": true,
          "description": "Reports different Kotlin stdlib and compiler versions.\n\nUsing different versions of the Kotlin compiler and the standard library can lead to unpredictable\nruntime problems and should be avoided."
        },
        {
          "shortName": "DifferentKotlinMavenVersion",
          "displayName": "Maven and IDE plugins versions are different",
          "enabled": true,
          "description": "Reports the Maven plugin version of the Kotlin compiler that is different from the one that is used in the IDE plugin.\n\nThis inconsistency may lead to different error reporting behavior in the IDE and the compiler"
        }
      ]
    },
    {
      "name": "Style issues",
      "inspections": [
        {
          "shortName": "RedundantRunCatching",
          "displayName": "Redundant 'runCatching' call",
          "enabled": false,
          "description": "Reports `runCatching` calls that are immediately followed by `getOrThrow`. Such calls can be replaced with just `run`.\n\n**Example:**\n\n\n      fun foo() = runCatching { doSomething() }.getOrThrow()\n\nAfter the quick-fix is applied:\n\n\n      fun foo() = run { doSomething() }\n"
        },
        {
          "shortName": "ConvertLambdaToReference",
          "displayName": "Can be replaced with function reference",
          "enabled": false,
          "description": "Reports function literal expressions that can be replaced with function references.\n\nReplacing lambdas with function references often makes code look more concise and understandable.\n\n**Example:**\n\n\n      fun Int.isEven() = this % 2 == 0\n\n      fun example() {\n          val numbers = listOf(1, 2, 4, 7, 9, 10)\n          val evenNumbers = numbers.filter { it.isEven() }\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun Int.isEven() = this % 2 == 0\n\n      fun example() {\n          val numbers = listOf(1, 2, 4, 7, 9, 10)\n          val evenNumbers = numbers.filter(Int::isEven)\n      }\n"
        },
        {
          "shortName": "ScopeFunctionConversion",
          "displayName": "Scope function can be converted to another one",
          "enabled": false,
          "description": "Reports scope functions (`let`, `run`, `apply`, `also`) that can be converted between each other.\n\nUsing corresponding functions makes your code simpler.\n\nThe quick-fix replaces the scope function to another one.\n\n**Example:**\n\n\n      val x = \"\".let {\n          it.length\n      }\n\nAfter the quick-fix is applied:\n\n\n      val x = \"\".run {\n          length\n      }\n"
        },
        {
          "shortName": "TrailingComma",
          "displayName": "Trailing comma recommendations",
          "enabled": false,
          "description": "Reports trailing commas that are not follow the recommended [style guide](https://kotlinlang.org/docs/coding-conventions.html#trailing-commas)."
        },
        {
          "shortName": "FoldInitializerAndIfToElvis",
          "displayName": "If-Null return/break/... foldable to '?:'",
          "enabled": false,
          "description": "Reports an `if` expression that checks variable being null or not right after initializing it that can be converted into an elvis operator in the initializer.\n\n**Example:**\n\n\n      fun test(foo: Int?, bar: Int): Int {\n          var i = foo\n          if (i == null) {\n              return bar\n          }\n          return i\n      }\n\nThe quick-fix converts the `if` expression with an initializer into an elvis expression:\n\n\n      fun test(foo: Int?, bar: Int): Int {\n          var i = foo ?: return bar\n          return i\n      }\n"
        },
        {
          "shortName": "ConvertToStringTemplate",
          "displayName": "String concatenation that can be converted to string template",
          "enabled": false,
          "description": "Reports string concatenation that can be converted to a string template.\n\nUsing string templates is recommended as it makes code easier to read.\n\n**Example:**\n\n\n      fun example() {\n          val capitals = mapOf(\"France\" to \"Paris\", \"Spain\" to \"Madrid\")\n          for ((country, capital) in capitals) {\n              print(capital + \" is a capital of \" + country)\n          }\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun example() {\n          val capitals = mapOf(\"France\" to \"Paris\", \"Spain\" to \"Madrid\")\n          for ((country, capital) in capitals) {\n              print(\"$capital is a capital of $country\")\n          }\n      }\n"
        },
        {
          "shortName": "SimplifiableCall",
          "displayName": "Library function call could be simplified",
          "enabled": false,
          "description": "Reports library function calls which could be replaced by simplified one.\n\nUsing corresponding functions makes your code simpler.\n\nThe quick-fix replaces the function calls with another one.\n\n**Example:**\n\n\n      fun test(list: List<Any>) {\n          list.filter { it is String }\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun test(list: List<Any>) {\n          list.filterIsInstance<String>()\n      }\n"
        },
        {
          "shortName": "ObjectLiteralToLambda",
          "displayName": "Object literal can be converted to lambda",
          "enabled": false,
          "description": "Reports anonymous object literals implementing a Java interface with a single abstract method that can be converted into a call with a lambda expression.\n\n**Example:**\n\n\n    class SomeService {\n      val threadPool = Executors.newCachedThreadPool()\n        \n      fun foo() {\n        threadPool.submit(object : Runnable {\n          override fun run() {\n            println(\"hello\")\n          }\n        })\n      }\n    }\n\nAfter the quick-fix is applied:\n\n\n      fun foo() {\n        threadPool.submit { println(\"hello\") }\n      }\n"
        },
        {
          "shortName": "BooleanLiteralArgument",
          "displayName": "Boolean literal argument without parameter name",
          "enabled": false,
          "description": "Reports call arguments with `Boolean` type without explicit parameter names specified.\n\n\nWhen multiple boolean literals are passed sequentially, it's easy to forget parameter ordering that could lead to mistakes.\nExplicit parameter names allow for easier code reading and understanding.\n\n**Example:**\n\n\n      fun check(checkName: Boolean, checkAddress: Boolean, checkPhone: Boolean) {}\n\n      fun usage() {\n          check(true, false, true) // What does this mean?\n      }\n\nA quick-fix adds missing parameter names:\n\n\n      fun check(checkName: Boolean, checkAddress: Boolean, checkPhone: Boolean) {}\n\n      fun usage() {\n          check(checkName = true, checkAddress = false, checkPhone = true)\n      }\n"
        },
        {
          "shortName": "ReplaceGuardClauseWithFunctionCall",
          "displayName": "Guard clause can be replaced with Kotlin's function call",
          "enabled": false,
          "description": "Reports guard clauses that can be replaced with a function call.\n\n**Example:**\n\n      fun test(foo: Int?) {\n          if (foo == null) throw IllegalArgumentException(\"foo\") // replaceable clause\n      }\n\nAfter the quick-fix is applied:\n\n      fun test(foo: Int?) {\n          checkNotNull(foo)\n      }\n"
        },
        {
          "shortName": "ReplaceSizeZeroCheckWithIsEmpty",
          "displayName": "Size zero check can be replaced with 'isEmpty()'",
          "enabled": false,
          "description": "Reports `size == 0` checks on `Collections/Array/String` that should be replaced with `isEmpty()`.\n\nUsing `isEmpty()` makes your code simpler.\n\nThe quick-fix replaces the size check with `isEmpty()`.\n\n**Example:**\n\n\n      fun foo() {\n          val arrayOf = arrayOf(1, 2, 3)\n          arrayOf.size == 0\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun foo() {\n          val arrayOf = arrayOf(1, 2, 3)\n          arrayOf.isEmpty()\n      }\n"
        },
        {
          "shortName": "ReplaceToStringWithStringTemplate",
          "displayName": "Call of 'toString' could be replaced with string template",
          "enabled": false,
          "description": "Reports `toString` function calls that can be replaced with a string template.\n\nUsing string templates makes your code simpler.\n\nThe quick-fix replaces `toString` with a string template.\n\n**Example:**\n\n\n      fun test(): String {\n          val x = 1\n          return x.toString()\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun test(): String {\n          val x = 1\n          return \"$x\"\n      }\n"
        },
        {
          "shortName": "DirectUseOfResultType",
          "displayName": "Function returning Result directly",
          "enabled": false,
          "description": "Reports functions that use `Result` as a return type.\n\n\n`Result` should never be used as a return type.\nThrow an exception, use a nullable type, or use a domain-specific result class to indicate failure.\n\n**Example:**\n\n\n      fun foo() = Result.success(true)\n"
        },
        {
          "shortName": "ProtectedInFinal",
          "displayName": "'protected' visibility is effectively 'private' in a final class",
          "enabled": false,
          "description": "Reports `protected` visibility used inside of a `final` class. In such cases `protected` members are accessible only in the class itself, so they are effectively `private`.\n\n**Example:**\n\n\n      class FinalClass {\n          protected fun foo() {}\n      }\n\nAfter the quick-fix is applied:\n\n\n      class FinalClass {\n          private fun foo() {}\n      }\n"
        },
        {
          "shortName": "ReplaceRangeStartEndInclusiveWithFirstLast",
          "displayName": "Boxed properties should be replaced with unboxed",
          "enabled": false,
          "description": "Reports **boxed** `Range.start` and `Range.endInclusive` properties.\n\nThese properties can be replaced with **unboxed** `first` and `last` properties to avoid redundant calls.\n\nThe quick-fix replaces `start` and `endInclusive` properties with the corresponding `first` and `last`.\n\n**Example:**\n\n\n      fun foo(range: CharRange) {\n          val lastElement = range.endInclusive\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun foo(range: CharRange) {\n          val lastElement = range.last\n      }\n"
        },
        {
          "shortName": "ReplaceSizeCheckWithIsNotEmpty",
          "displayName": "Size check can be replaced with 'isNotEmpty()'",
          "enabled": false,
          "description": "Reports size checks of `Collections/Array/String` that should be replaced with `isNotEmpty()`.\n\nUsing `isNotEmpty()` makes your code simpler.\n\nThe quick-fix replaces the size check with `isNotEmpty()`.\n\n**Example:**\n\n\n      fun foo() {\n          val arrayOf = arrayOf(1, 2, 3)\n          arrayOf.size > 0\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun foo() {\n          val arrayOf = arrayOf(1, 2, 3)\n          arrayOf.isNotEmpty()\n      }\n"
        },
        {
          "shortName": "IntroduceWhenSubject",
          "displayName": "'when' that can be simplified by introducing an argument",
          "enabled": false,
          "description": "Reports a `when` expression that can be simplified by introducing a subject argument.\n\n**Example:**\n\n\n      fun test(obj: Any): String {\n          return when {\n              obj is String -> \"string\"\n              obj is Int -> \"int\"\n              else -> \"unknown\"\n          }\n      }\n\nThe quick fix introduces a subject argument:\n\n\n      fun test(obj: Any): String {\n          return when (obj) {\n              is String -> \"string\"\n              is Int -> \"int\"\n              else -> \"unknown\"\n          }\n      }\n"
        },
        {
          "shortName": "SafeCastWithReturn",
          "displayName": "Safe cast with 'return' should be replaced with 'if' type check",
          "enabled": false,
          "description": "Reports safe cast with `return` that can be replaced with `if` type check.\n\nUsing corresponding functions makes your code simpler.\n\nThe quick-fix replaces the safe cast with `if` type check.\n\n**Example:**\n\n\n      fun test(x: Any) {\n          x as? String ?: return\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun test(x: Any) {\n          if (x !is String) return\n      }\n"
        },
        {
          "shortName": "ReplaceAssertBooleanWithAssertEquality",
          "displayName": "Assert boolean could be replaced with assert equality",
          "enabled": false,
          "description": "Reports calls to `assertTrue()` and `assertFalse()` that can be replaced with assert equality functions.\n\n\n`assertEquals()`, `assertSame()`, and their negating counterparts (-Not-) provide more informative messages on\nfailure.\n\n**Example:**\n\n      assertTrue(a == b)\n\nAfter the quick-fix is applied:\n\n      assertEquals(a, b)\n"
        },
        {
          "shortName": "IfThenToElvis",
          "displayName": "If-Then foldable to '?:'",
          "enabled": false,
          "description": "Reports `if-then` expressions that can be folded into elvis (`?:`) expressions.\n\n**Example:**\n\n\n      fun maybeFoo(): String? = \"foo\"\n\n      var foo = maybeFoo()\n      val bar = if (foo == null) \"hello\" else foo\n\nThe quick fix converts the `if-then` expression into an elvis (`?:`) expression:\n\n\n      fun maybeFoo(): String? = \"foo\"\n\n      var foo = maybeFoo()\n      val bar = foo ?: \"hello\"\n"
        },
        {
          "shortName": "ReplaceNotNullAssertionWithElvisReturn",
          "displayName": "Not-null assertion can be replaced with 'return'",
          "enabled": false,
          "description": "Reports not-null assertion (`!!`) calls that can be replaced with the elvis operator and return (`?: return`).\n\nA not-null assertion can lead to NPE (NullPointerException) that is not expected. Avoiding the use of `!!` is good practice.\n\nThe quick-fix replaces the not-null assertion with `return` or `return null`.\n\n**Example:**\n\n\n      fun test(number: Int?) {\n          val x = number!!\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun test(number: Int?) {\n          val x = number ?: return\n      }\n"
        },
        {
          "shortName": "ReplaceStringFormatWithLiteral",
          "displayName": "'String.format' call can be replaced with string templates",
          "enabled": false,
          "description": "Reports `String.format` calls that can be replaced with string templates.\n\nUsing string templates makes your code simpler.\n\nThe quick-fix replaces the call with a string template.\n\n**Example:**\n\n\n      fun main() {\n          val id = \"abc\"\n          val date = \"123\"\n          val s = String.format(\"%s_%s_%s\", id, date, id)\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun main() {\n          val id = \"abc\"\n          val date = \"123\"\n          val s = \"${id}_${date}_$id\"\n      }\n"
        },
        {
          "shortName": "ReplaceSubstringWithSubstringBefore",
          "displayName": "'substring' call should be replaced with 'substringBefore'",
          "enabled": false,
          "description": "Reports calls like `s.substring(0, s.indexOf(x))` that can be replaced with `s.substringBefore(x)`.\n\nUsing `substringBefore()` makes your code simpler.\n\nThe quick-fix replaces the `substring` call with `substringBefore`.\n\n**Example:**\n\n\n      fun foo(s: String) {\n          s.substring(0, s.indexOf('x'))\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun foo(s: String) {\n          s.substringBefore('x')\n      }\n"
        },
        {
          "shortName": "ReplaceJavaStaticMethodWithKotlinAnalog",
          "displayName": "Java methods should be replaced with Kotlin analog",
          "enabled": false,
          "description": "Reports a Java method call that can be replaced with a Kotlin function, for example, `System.out.println()`.\n\nReplacing the code gets rid of the dependency to Java and makes the idiomatic Kotlin code.\n\nThe quick-fix replaces the Java method calls on the same Kotlin call.\n\n**Example:**\n\n\n      import java.util.Arrays\n\n      fun main() {\n          val a = Arrays.asList(1, 3, null)\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun main() {\n          val a = listOf(1, 3, null)\n      }\n"
        },
        {
          "shortName": "ReplaceWithOperatorAssignment",
          "displayName": "Assignment can be replaced with operator assignment",
          "enabled": false,
          "description": "Reports modifications of variables with a simple assignment (such as `y = y + x`) that can be replaced with an operator assignment.\n\nThe quick-fix replaces the assignment with an assignment operator.\n\n**Example:**\n\n\n      fun foo() {\n          val list = mutableListOf(1, 2, 3)\n          list = list + 4\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun foo() {\n          val list = mutableListOf(1, 2, 3)\n          list += 4\n      }\n"
        },
        {
          "shortName": "ReplaceCollectionCountWithSize",
          "displayName": "Collection count can be converted to size",
          "enabled": false,
          "description": "Reports calls to `Collection<T>.count()`.\n\n\nThis function call can be replaced with `.size`.\n\n\n`.size` form ensures that the operation is O(1) and won't allocate extra objects, whereas\n`count()` could be confused with `Iterable<T>.count()`, which is O(n) and allocating.\n\n\n**Example:**\n\n      fun foo() {\n          var list = listOf(1,2,3)\n          list.count() // replaceable 'count()'\n      }\n\nAfter the quick-fix is applied:\n\n      fun foo() {\n          var list = listOf(1,2,3)\n          list.size\n      }\n"
        },
        {
          "shortName": "RedundantAsync",
          "displayName": "Redundant 'async' call",
          "enabled": false,
          "description": "Reports `async` calls that are immediately followed by `await`.\nSuch calls can be replaced with blocking calls.\n\n**Example:**\n\n\n      suspend fun test(ctx: CoroutineContext, scope: CoroutineScope) {\n          scope.async(ctx) { doSomeJob() }.await()\n      }\n\nAfter the quick-fix is applied:\n\n\n      suspend fun test(ctx: CoroutineContext, scope: CoroutineScope) {\n          withContext(scope.coroutineContext + ctx) { doSomeJob() }\n      }\n"
        },
        {
          "shortName": "JavaCollectionsStaticMethod",
          "displayName": "Java Collections static method call can be replaced with Kotlin stdlib",
          "enabled": false,
          "description": "Reports a Java `Collections` static method call that can be replaced with Kotlin stdlib.\n\n**Example:**\n\n\n      import java.util.Collections\n\n      fun test() {\n          val mutableList = mutableListOf(1, 2)\n          Collections.fill(mutableList, 3)\n      }\n\nThe quick fix replaces Java `Collections` static method call with the corresponding Kotlin stdlib method call:\n\n\n      import java.util.Collections\n\n      fun test() {\n          val mutableList = mutableListOf(1, 2)\n          mutableList.fill(3)\n      }\n"
        },
        {
          "shortName": "MoveVariableDeclarationIntoWhen",
          "displayName": "Variable declaration could be moved inside 'when'",
          "enabled": false,
          "description": "Reports variable declarations that can be moved inside a `when` expression.\n\n**Example:**\n\n\n    fun someCalc(x: Int) = x * 42\n\n    fun foo(x: Int): Int {\n      val a = someCalc(x)\n      return when (a) {\n        1 -> a\n        2 -> 2 * a\n        else -> 24\n      }\n    }\n\nAfter the quick-fix is applied:\n\n\n    fun foo(x: Int): Int {\n      return when (val a = someCalc(x)) {\n        1 -> a\n        2 -> 2 * a\n        else -> 24\n      }\n    }\n"
        },
        {
          "shortName": "DeferredIsResult",
          "displayName": "Function returning Deferred directly",
          "enabled": false,
          "description": "Reports functions with the `kotlinx.coroutines.Deferred` return type.\n\n\nFunctions that use `Deferred` as return type should have a name with the `Async` suffix.\nOtherwise, it's recommended to mark a function as `suspend` and unwrap `Deferred` inside it.\n\n**Example:**\n\n\n      fun calcEverything(): Deferred<Int> {\n          return CompletableDeferred(42)\n      }\n\nAfter the quick-fix that adds the `Async` suffix applied:\n\n\n      fun calcEverythingAsync(): Deferred<Int> {\n          return CompletableDeferred(42)\n      }\n\nAfter the quick-fix that converts the function into a `suspend` one applied:\n\n\n      suspend fun calcEverything(): Int {\n          return CompletableDeferred(42).await()\n      }\n"
        },
        {
          "shortName": "RemoveEmptyParenthesesFromAnnotationEntry",
          "displayName": "Remove unnecessary parentheses",
          "enabled": false,
          "description": "Reports redundant empty parentheses in annotation entries.\n\nUse the 'Remove unnecessary parentheses' quick-fix to clean up the code.\n\n**Examples:**\n\n\n      annotation class MyAnnotationA\n      annotation class MyAnnotationB(val x: Int)\n      annotation class MyAnnotationC(val x: Int = 10) // default value is present\n\n      @MyAnnotationA() // <== parentheses are redundant\n      fun testA() {\n      }\n\n      @MyAnnotationB() // <== missing argument, parentheses are required\n      fun testB() {\n      }\n\n      @MyAnnotationC() // <== parentheses are redundant\n      fun testC() {\n      }\n"
        },
        {
          "shortName": "SimplifiableCallChain",
          "displayName": "Call chain on collection type can be simplified",
          "enabled": false,
          "description": "Reports two-call chains replaceable by a single call.\n\nIt can help you to avoid redundant code execution.\n\nThe quick-fix replaces the call chain with a single call.\n\n**Example:**\n\n\n      fun main() {\n          listOf(1, 2, 3).filter { it > 1 }.count()\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun main() {\n          listOf(1, 2, 3).count { it > 1 }\n      }\n"
        },
        {
          "shortName": "ConvertReferenceToLambda",
          "displayName": "Can be replaced with lambda",
          "enabled": false,
          "description": "Reports a function reference expression that can be replaced with a function literal (lambda).\n\n\nSometimes, passing a lambda looks more straightforward and more consistent with the rest of the code.\nAlso, the fix might be handy if you need to replace a simple call with something more complex.\n\n**Example:**\n\n\n      fun Int.isEven() = this % 2 == 0\n\n      fun example() {\n          val numbers = listOf(1, 2, 4, 7, 9, 10)\n          val evenNumbers = numbers.filter(Int::isEven)\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun Int.isEven() = this % 2 == 0\n\n      fun example() {\n          val numbers = listOf(1, 2, 4, 7, 9, 10)\n          val evenNumbers = numbers.filter { it.isEven() }\n      }\n"
        },
        {
          "shortName": "ReplaceCallWithBinaryOperator",
          "displayName": "Can be replaced with binary operator",
          "enabled": false,
          "description": "Reports function calls that can be replaced with binary operators, in particular comparison-related ones.\n\n**Example:**\n\n      fun test(): Boolean {\n          return 2.compareTo(1) > 0 // replaceable 'compareTo()'\n      }\n\nAfter the quick-fix is applied:\n\n      fun test(): Boolean {\n          return 2 > 1\n      }\n"
        },
        {
          "shortName": "UnlabeledReturnInsideLambda",
          "displayName": "Unlabeled return inside lambda",
          "enabled": false,
          "description": "Reports unlabeled `return` expressions inside inline lambda.\n\nSuch expressions can be confusing because it might be unclear which scope belongs to `return`.\n\n**Change to return@...** quick-fix can be used to amend the code automatically.\n\nExample:\n\n\n      fun test(list: List<Int>) {\n          list.forEach {\n              // This return expression returns from the function test\n              // One can change it to return@forEach to change the scope\n              if (it == 10) return\n          }\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun test(list: List<Int>) {\n          list.forEach {\n              if (it == 10) return@test\n          }\n      }\n"
        },
        {
          "shortName": "ConvertPairConstructorToToFunction",
          "displayName": "Convert Pair constructor to 'to' function",
          "enabled": false,
          "description": "Reports a `Pair` constructor invocation that can be replaced with a `to()` infix function call.\n\n\nExplicit constructor invocations may add verbosity, especially if they are used multiple times.\nReplacing constructor calls with `to()` makes code easier to read and maintain.\n\n**Example:**\n\n\n      val countries = mapOf(\n          Pair(\"France\", \"Paris\"),\n          Pair(\"Spain\", \"Madrid\"),\n          Pair(\"Germany\", \"Berlin\")\n      )\n\nAfter the quick-fix is applied:\n\n\n      val countries = mapOf(\n          \"France\" to \"Paris\",\n          \"Spain\" to \"Madrid\",\n          \"Germany\" to \"Berlin\"\n      )\n"
        },
        {
          "shortName": "JoinDeclarationAndAssignment",
          "displayName": "Join declaration and assignment",
          "enabled": false,
          "description": "Reports property declarations that can be joined with the following assignment.\n\n**Example:**\n\n\n      val x: String\n      x = System.getProperty(\"\")\n\nThe quick fix joins the declaration with the assignment:\n\n\n      val x = System.getProperty(\"\")\n"
        },
        {
          "shortName": "UsePropertyAccessSyntax",
          "displayName": "Accessor call that can be replaced with property access syntax",
          "enabled": false,
          "description": "Reports Java `get` and `set` method calls that can be replaced with the Kotlin synthetic properties.\n\n**Use property access syntax** quick-fix can be used to amen the code automatically.\n\nExample:\n\n\n      // Java:\n      public class JavaClassWithGetter {\n          private final String expr = \"result\";\n\n          // ...\n\n          public String getExpr() {\n              return expr;\n          }\n      }\n\n\n      // Kotlin:\n      fun test(j: JavaClassWithGetter) {\n          // ...\n          j.getExpr() // <== A quick-fix simplifies the expression to 'j.expr'\n      }\n"
        },
        {
          "shortName": "UseExpressionBody",
          "displayName": "Expression body syntax is preferable here",
          "enabled": false,
          "description": "Reports `return` expressions (one-liners or `when`) that can be replaced with expression body syntax.\n\nExpression body syntax is recommended by the [style guide](https://kotlinlang.org/docs/coding-conventions.html#functions).\n\n**Convert to expression body** quick-fix can be used to amend the code automatically.\n\nExample:\n\n\n      fun sign(x: Int): Int {\n          return when { // <== can be simplified\n              x < 0 -> -1\n              x > 0 -> 1\n              else -> 0\n          }\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun sign(x: Int): Int = when {\n          x < 0 -> -1\n          x > 0 -> 1\n          else -> 0\n      }\n"
        },
        {
          "shortName": "MapGetWithNotNullAssertionOperator",
          "displayName": "'map.get()' with not-null assertion operator (!!)",
          "enabled": false,
          "description": "Reports `map.get()!!` that can be replaced with `map.getValue()`, `map.getOrElse()`, and so on.\n\n**Example:**\n\n\n    fun test(map: Map<Int, String>): String = map.get(0)!!\n\nAfter the quick-fix is applied:\n\n\n    fun test(map: Map<Int, String>): String = map.getValue(0)\n"
        },
        {
          "shortName": "SortModifiers",
          "displayName": "Non-canonical modifier order",
          "enabled": false,
          "description": "Reports modifiers that do not follow the order recommended by the [style guide](https://kotlinlang.org/docs/coding-conventions.html#modifiers-order).\n\n**Sort modifiers** quick-fix can be used to amend the code automatically.\n\nExamples:\n\n\n      private inline fun correctOrder(f: () -> Unit) {} // <== Ok\n\n      infix private fun Int.wrongOrder(expr: Int) {} // <== wrong order, quick-fix amends the modifiers to \"private infix\"\n"
        },
        {
          "shortName": "NullableBooleanElvis",
          "displayName": "Equality check can be used instead of elvis for nullable boolean check",
          "enabled": false,
          "description": "Reports cases when an equality check should be used instead of the elvis operator.\n\n**Example:**\n\n\n    fun check(a: Boolean? == null) {\n        if (a ?: false) throw IllegalStateException()\n    }\n\nAfter the quick-fix is applied:\n\n\n    fun check(a: Boolean? == null) {\n        if (a == true) throw IllegalStateException()\n    }\n"
        },
        {
          "shortName": "ReplaceSubstringWithDropLast",
          "displayName": "'substring' call should be replaced with 'dropLast' call",
          "enabled": false,
          "description": "Reports calls like `s.substring(0, s.length - x)` that can be replaced with `s.dropLast(x)`.\n\nUsing corresponding functions makes your code simpler.\n\nThe quick-fix replaces the `substring` call with `dropLast`.\n\n**Example:**\n\n\n      fun foo(s: String) {\n          s.substring(0, s.length - 5)\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun foo(s: String) {\n          s.dropLast(5)\n      }\n"
        },
        {
          "shortName": "CopyWithoutNamedArguments",
          "displayName": "'copy' method of data class is called without named arguments",
          "enabled": false,
          "description": "Reports calls to a data class' `copy()` method without named arguments.\n\n\nAs all arguments of the `copy()` function are optional, it might be hard to understand what properties are modified.\nProviding parameter names explicitly makes code easy to understand without navigating to the `data class` declaration.\n\n**Example:**\n\n\n      data class User(val name: String, val age: Int)\n\n      fun copyUser(user: User): User {\n          return user.copy(\"John\")\n      }\n\nA quick-fix provides parameter names to all `copy()` arguments:\n\n\n      data class User(val name: String, val age: Int)\n\n      fun copyUser(user: User): User {\n          return user.copy(name = \"John\")\n      }\n"
        },
        {
          "shortName": "ReplaceSubstringWithTake",
          "displayName": "'substring' call should be replaced with 'take' call",
          "enabled": false,
          "description": "Reports calls like `s.substring(0, x)` that can be replaced with `s.take(x)`.\n\nUsing `take()` makes your code simpler.\n\nThe quick-fix replaces the `substring` call with `take()`.\n\n**Example:**\n\n\n      fun foo(s: String) {\n          s.substring(0, 10)\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun foo(s: String) {\n          s.take(10)\n      }\n"
        },
        {
          "shortName": "ConvertCallChainIntoSequence",
          "displayName": "Call chain on collection could be converted into 'Sequence' to improve performance",
          "enabled": false,
          "description": "Reports call chain on a `Collection` that should be converted into **Sequence** .\n\nEach `Collection` transforming function (such as `map()` or `filter()`) creates a new\n`Collection` (typically `List` or `Set`) under the hood.\nIn case of multiple consequent calls, and a huge number of items in `Collection`, memory traffic might be significant.\nIn such a case, using `Sequence` is preferred.\n\n**Example:**\n\n\n      class Entity(val key: String, val value: String)\n\n      fun getValues(lines: List<String>) = lines\n          .filter { it.isNotEmpty() }\n          .map { it.split(',', limit = 2) }\n          .filter { it.size == 2 }\n          .map { Entity(it[0], it[1]) }\n\nA quick-fix wraps call chain into `asSequence()` and `toList()`:\n\n\n      class Entity(val key: String, val value: String)\n\n      fun getValues(lines: List<String>) = lines\n          .asSequence()\n          .filter { it.isNotEmpty() }\n          .map { it.split(',', limit = 2) }\n          .filter { it.size == 2 }\n          .map { Entity(it[0], it[1]) }\n          .toList()\n"
        },
        {
          "shortName": "AddOperatorModifier",
          "displayName": "Function should have 'operator' modifier",
          "enabled": false,
          "description": "Reports a function that matches one of the operator conventions but lacks the `operator` keyword.\n\nBy adding the `operator` modifier, you might allow function consumers to write idiomatic Kotlin code.\n\n**Example:**\n\n\n      class Complex(val real: Double, val imaginary: Double) {\n          fun plus(other: Complex) =\n              Complex(real + other.real, imaginary + other.imaginary)\n      }\n\n      fun usage(a: Complex, b: Complex) {\n          a.plus(b)\n      }\n\nA quick-fix adds the `operator` modifier keyword:\n\n\n      class Complex(val real: Double, val imaginary: Double) {\n          operator fun plus(other: Complex) =\n              Complex(real + other.real, imaginary + other.imaginary)\n      }\n\n      fun usage(a: Complex, b: Complex) {\n          a + b\n      }\n"
        },
        {
          "shortName": "MayBeConstant",
          "displayName": "Might be 'const'",
          "enabled": false,
          "description": "Reports top-level `val` properties in objects that might be declared as `const` for better performance and Java interoperability.\n\n**Example:**\n\n\n      object A {\n          val foo = 1\n      }\n\nAfter the quick-fix is applied:\n\n\n      object A {\n          const val foo = 1\n      }\n"
        },
        {
          "shortName": "ReplaceIsEmptyWithIfEmpty",
          "displayName": "'if' condition can be replaced with lambda call",
          "enabled": false,
          "description": "Reports `isEmpty`, `isBlank`, `isNotEmpty`, or `isNotBlank` calls in an `if` statement to assign a default value.\n\nThe quick-fix replaces the `if` condition with `ifEmpty` or `ifBlank` calls.\n\n**Example:**\n\n\n      fun test(list: List<Int>): List<Int> {\n          return if (list.isEmpty()) {\n              println()\n              foo()\n          } else {\n              list\n          }\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun test(list: List<Int>): List<Int> {\n          return list.ifEmpty {\n              println()\n              foo()\n          }\n      }\n\nThis inspection only reports if the Kotlin language version of the project or module is 1.3 or higher."
        },
        {
          "shortName": "ReplaceNegatedIsEmptyWithIsNotEmpty",
          "displayName": "Negated call can be simplified",
          "enabled": false,
          "description": "Reports negation `isEmpty()` and `isNotEmpty()` for collections and `String`, or `isBlank()` and `isNotBlank()` for `String`.\n\nUsing corresponding functions makes your code simpler.\n\nThe quick-fix replaces the negation call with the corresponding call from the Standard Library.\n\n**Example:**\n\n\n      fun main() {\n          val list = listOf(1,2,3)\n          if (!list.isEmpty()) {\n              // do smth\n          }\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun main() {\n          val list = listOf(1,2,3)\n          if (list.isNotEmpty()) {\n              // do smth\n          }\n      }\n"
        },
        {
          "shortName": "ReplaceWithImportAlias",
          "displayName": "Fully qualified name can be replaced with existing import alias",
          "enabled": false,
          "description": "Reports fully qualified names that can be replaced with an existing import alias.\n\n**Example:**\n\n\n    import foo.Foo as Bar\n    fun main() {\n        foo.Foo()\n    }\n\nAfter the quick-fix is applied:\n\n\n    import foo.Foo as Bar\n    fun main() {\n        Bar()\n    }\n"
        },
        {
          "shortName": "SimplifyBooleanWithConstants",
          "displayName": "Boolean expression can be simplified",
          "enabled": false,
          "description": "Reports boolean expression parts that can be reduced to constants.\n\nThe quick-fix simplifies the condition.\n\n**Example:**\n\n\n      fun use(arg: Boolean) {\n          if (false == arg) {\n\n          }\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun use(arg: Boolean) {\n          if (!arg) {\n\n          }\n      }\n"
        },
        {
          "shortName": "UseWithIndex",
          "displayName": "Manually incremented index variable can be replaced with use of 'withIndex()'",
          "enabled": false,
          "description": "Reports `for` loops with a manually incremented index variable.\n\n`for` loops with a manually incremented index variable can be simplified with the `withIndex()` function.\n\n**Use withIndex() instead of manual index increment** quick-fix can be used to amend the code automatically.\n\nExample:\n\n\n      fun foo(list: List<String>): Int? {\n          var index = 0\n          for (s in list) { <== can be simplified\n              val x = s.length * index\n              index++\n              if (x > 0) return x\n          }\n          return null\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun foo(list: List<String>): Int? {\n          for ((index, s) in list.withIndex()) {\n              val x = s.length * index\n              if (x > 0) return x\n          }\n          return null\n      }\n"
        },
        {
          "shortName": "SimplifyAssertNotNull",
          "displayName": "'assert' call can be replaced with '!!' or '?:'",
          "enabled": false,
          "description": "Reports `assert` calls that check a not null value of the declared variable.\n\nUsing `!!` or `?:` makes your code simpler.\n\nThe quick-fix replaces `assert` with `!!` or `?:` operator in the variable initializer.\n\n**Example:**\n\n\n      fun foo(p: Array<String?>) {\n          val v = p[0]\n          assert(v != null, { \"Should be not null\" })\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun foo(p: Array<String?>) {\n          val v = p[0] ?: error(\"Should be not null\")\n      }\n"
        },
        {
          "shortName": "ReplaceManualRangeWithIndicesCalls",
          "displayName": "Range can be converted to indices or iteration",
          "enabled": false,
          "description": "Reports `until` and `rangeTo` operators that can be replaced with `Collection.indices` or iteration over collection inside `for` loop.\n\nUsing syntactic sugar makes your code simpler.\n\nThe quick-fix replaces the manual range with the corresponding construction.\n\n**Example:**\n\n\n      fun main(args: Array<String>) {\n          for (index in 0..args.size - 1) {\n              println(args[index])\n          }\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun main(args: Array<String>) {\n          for (element in args) {\n              println(element)\n          }\n      }\n"
        },
        {
          "shortName": "ImplicitThis",
          "displayName": "Implicit 'this'",
          "enabled": false,
          "description": "Reports usages of implicit **this** .\n\n**Example:**\n\n\n      class Foo {\n          fun s() = \"\"\n\n          fun test() {\n              s()\n          }\n      }\n\nThe quick fix specifies **this** explicitly:\n\n\n      class Foo {\n          fun s() = \"\"\n\n          fun test() {\n              this.s()\n          }\n      }\n"
        },
        {
          "shortName": "RedundantAsSequence",
          "displayName": "Redundant 'asSequence' call",
          "enabled": false,
          "description": "Reports redundant `asSequence()` call that can never have a positive performance effect.\n\n\n`asSequence()` speeds up collection processing that includes multiple operations because it performs operations lazily\nand doesn't create intermediate collections.\n\n\nHowever, if a terminal operation (such as `toList()`) is used right after `asSequence()`, this doesn't give\nyou any positive performance effect.\n\n**Example:**\n\n\n      fun test(list: List<String>) {\n          list.asSequence().last()\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun test(list: List<String>) {\n          list.last()\n      }\n"
        },
        {
          "shortName": "CanBeVal",
          "displayName": "Local 'var' is never modified and can be declared as 'val'",
          "enabled": false,
          "description": "Reports local variables declared with the `var` keyword that are never modified.\n\nKotlin encourages to declare practically immutable variables using the `val` keyword, ensuring that their value will never change.\n\n**Example:**\n\n\n      fun example() {\n          var primeNumbers = listOf(1, 2, 3, 5, 7, 11, 13)\n          var fibonacciNumbers = listOf(1, 1, 2, 3, 5, 8, 13)\n          print(\"Same numbers: \" + primeNumbers.intersect(fibonacciNumbers))\n      }\n\nA quick-fix replaces the `var` keyword with `val`:\n\n\n      fun example() {\n          val primeNumbers = listOf(1, 2, 3, 5, 7, 11, 13)\n          val fibonacciNumbers = listOf(1, 1, 2, 3, 5, 8, 13)\n          print(\"Same numbers: \" + primeNumbers.intersect(fibonacciNumbers))\n      }\n"
        },
        {
          "shortName": "JavaMapForEach",
          "displayName": "Java Map.forEach method call should be replaced with Kotlin's forEach",
          "enabled": false,
          "description": "Reports a Java Map.`forEach` method call that can be replaced with Kotlin's **forEach** .\n\n**Example:**\n\n\n      fun test(map: HashMap<Int, String>) {\n          map.forEach { (key, value) ->\n              foo(key, value)\n          }\n      }\n\n      fun foo(i: Int, s: String) {}\n\nThe quick fix removes parentheses:\n\n\n      fun test(map: HashMap<Int, String>) {\n          map.forEach { key, value ->\n              foo(key, value)\n          }\n      }\n\n      fun foo(i: Int, s: String) {}\n"
        },
        {
          "shortName": "RedundantObjectTypeCheck",
          "displayName": "Non-idiomatic 'is' type check for an object",
          "enabled": false,
          "description": "Reports non-idiomatic `is` type checks for an object.\n\nIt's recommended to replace such checks with reference comparison.\n\n**Example:**\n\n\n      object Foo\n\n      fun foo(arg: Any) = when {\n          arg is Foo -> ...\n          arg !is Foo -> ...\n      }\n\nAfter the quick-fix is applied:\n\n\n      object Foo\n\n      fun foo(arg: Any) = when {\n          arg === Foo -> ...\n          arg !== Foo -> ...\n      }\n"
        },
        {
          "shortName": "ReplaceSubstringWithSubstringAfter",
          "displayName": "'substring' call should be replaced with 'substringAfter'",
          "enabled": false,
          "description": "Reports calls like `s.substring(s.indexOf(x))` that can be replaced with `s.substringAfter(x)`.\n\nUsing `s.substringAfter(x)` makes your code simpler.\n\nThe quick-fix replaces the `substring` call with `substringAfter`.\n\n**Example:**\n\n\n      fun foo(s: String) {\n          s.substring(s.indexOf('x'))\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun foo(s: String) {\n          s.substringAfter('x')\n      }\n"
        },
        {
          "shortName": "ReplaceAssociateFunction",
          "displayName": "'associate' can be replaced with 'associateBy' or 'associateWith'",
          "enabled": false,
          "description": "Reports calls to `associate()` and `associateTo()` that can be replaced with `associateBy()` or `associateWith()`.\n\n\nBoth functions accept a transformer function applied to elements of a given sequence or collection (as a receiver).\nThe pairs are then used to build the resulting `Map`.\n\n\nGiven the transformer refers to `it`, the `associate[To]()` call can be replaced with more performant `associateBy()`\nor `associateWith()`.\n\n**Examples:**\n\n      fun getKey(i: Int) = 1L\n      fun getValue(i: Int) = 1L\n\n      fun test() {\n          arrayOf(1).associate { getKey(it) to it }  // replaceable 'associate()'\n          listOf(1).associate { it to getValue(it) } // replaceable 'associate()'\n      }\n\nAfter the quick-fix is applied:\n\n      fun getKey(i: Int) = 1L\n      fun getValue(i: Int) = 1L\n\n      fun test() {\n          arrayOf(1).associateBy { getKey(it) }\n          listOf(1).associateWith { getValue(it) }\n      }\n"
        },
        {
          "shortName": "LiftReturnOrAssignment",
          "displayName": "Return or assignment can be lifted out",
          "enabled": false,
          "description": "Reports `if`, `when`, and `try` statements that can be converted to expressions by lifting the `return` statement or an assignment out.\n\n**Example:**\n\n\n      fun foo(arg: Int): String {\n          when (arg) {\n              0 -> return \"Zero\"\n              1 -> return \"One\"\n              else -> return \"Multiple\"\n          }\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun foo(arg: Int): String {\n          return when (arg) {\n              0 -> \"Zero\"\n              1 -> \"One\"\n              else -> \"Multiple\"\n          }\n      }\n"
        },
        {
          "shortName": "NestedLambdaShadowedImplicitParameter",
          "displayName": "Nested lambda has shadowed implicit parameter",
          "enabled": false,
          "description": "Reports nested lambdas with shadowed implicit parameters.\n\n**Example:**\n\n\n    fun foo(listOfLists: List<List<String>>) {\n      listOfLists.forEach {\n        it.forEach {\n          println(it)\n        }\n      }\n    }\n\nAfter the quick-fix is applied:\n\n\n    fun foo(listOfLists: List<List<String>>) {\n      listOfLists.forEach {\n        it.forEach { it1 ->\n          println(it1)\n        }\n      }\n    }\n"
        },
        {
          "shortName": "AddVarianceModifier",
          "displayName": "Type parameter can have 'in' or 'out' variance",
          "enabled": false,
          "description": "Reports type parameters that can have `in` or `out` variance.\n\nUsing `in` and `out` variance provides more precise type inference in Kotlin and clearer code semantics.\n\n**Example:**\n\n\n      class Box<T>(val obj: T)\n\n      fun consumeString(box: Box<String>) {}\n      fun consumeCharSequence(box: Box<CharSequence>) {}\n\n      fun usage(box: Box<String>) {\n          consumeString(box)\n          consumeCharSequence(box) // Compilation error\n      }\n\nA quick-fix adds the matching variance modifier:\n\n\n      class Box<out T>(val obj: T)\n\n      fun consumeString(box: Box<String>) {}\n      fun consumeCharSequence(box: Box<CharSequence>) {}\n\n      fun usage(box: Box<String>) ++{\n          consumeString(box)\n          consumeCharSequence(box) // OK\n      }\n"
        },
        {
          "shortName": "SimplifyNegatedBinaryExpression",
          "displayName": "Negated boolean expression can be simplified",
          "enabled": false,
          "description": "Reports negated binary expressions that can be simplified.\n\nThe quick-fix simplifies the binary expression.\n\n**Example:**\n\n\n      fun test(n: Int) {\n          !(0 == 1)\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun test(n: Int) {\n          0 != 1\n      }\n"
        },
        {
          "shortName": "MemberVisibilityCanBePrivate",
          "displayName": "Class member can have 'private' visibility",
          "enabled": false,
          "description": "Reports declarations that can be made `private` to follow the encapsulation principle.\n\n**Example:**\n\n\n    class Service(val url: String) {\n        fun connect(): URLConnection = URL(url).openConnection()\n    }\n\nAfter the quick-fix is applied (considering there are no usages of `url` outside of `Service` class):\n\n\n    class Service(private val url: String) {\n        fun connect(): URLConnection = URL(url).openConnection()\n    }\n"
        },
        {
          "shortName": "SuspiciousAsDynamic",
          "displayName": "Suspicious 'asDynamic' member invocation",
          "enabled": false,
          "description": "Reports usages of `asDynamic` function on a receiver of dynamic type.\n\n`asDynamic` function has no effect for expressions of dynamic type.\n\n`asDynamic` function on a receiver of dynamic type can lead to runtime problems because `asDynamic`\nwill be executed in JavaScript environment, and such function may not be present at runtime.\nThe intended way is to use this function on usual Kotlin type.\n\n**Remove \"asDynamic\" invocation** quick-fix can be used to amend the code automatically.\n\nExample:\n\n\n      fun wrongUsage(d: Dynamic) {\n         d.asDynamic().foo() // <== redundant, quick-fix simplifies the call expression to \"d.foo()\"\n      }\n"
        },
        {
          "shortName": "SimplifyNestedEachInScopeFunction",
          "displayName": "Scope function with nested forEach can be simplified",
          "enabled": false,
          "description": "Reports `forEach` functions in the scope functions such as `also` or `apply` that can be simplified.\n\n**Convert forEach call to onEach** quick-fix can be used to amend the code automatically.\n\nExamples:\n\n\n      fun test(list: List<Int>) {\n          val x = list.also { it.forEach { it + 4 } }.toString()\n          val y = list.apply { forEach { println(it) } }\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun test(list: List<Int>) {\n          val x = list.onEach { it + 4 }.toString()\n          val y = list.onEach { println(it) }\n      }\n"
        },
        {
          "shortName": "ReplaceMapIndexedWithListGenerator",
          "displayName": "Replace 'mapIndexed' with List generator",
          "enabled": false,
          "description": "Reports a `mapIndexed` call that can be replaced by `List` generator.\n\n**Example:**\n\n\n      val a = listOf(1, 2, 3).mapIndexed { i, _ ->\n          i + 42\n      }\n\nAfter the quick-fix is applied:\n\n\n      val a = List(listOf(1, 2, 3).size) { i ->\n              i + 42\n      }\n"
        },
        {
          "shortName": "LoopToCallChain",
          "displayName": "Loop can be replaced with stdlib operations",
          "enabled": false,
          "description": "Reports `for` loops that can be replaced with a sequence of stdlib operations (like `map`, `filter`, and so on).\n\n**Example:**\n\n\n    fun foo(list: List<String>): List<Int> {\n      val result = ArrayList<Int>()\n      for (s in list) {\n         if (s.length > 0)\n           result.add(s.hashCode())\n         }\n      return result\n    }\n\nAfter the quick-fix is applied:\n\n\n    fun foo(list: List<String>): List<Int> {\n      val result = list\n        .filter { it.length > 0 }\n        .map { it.hashCode() }\n      return result\n    }\n"
        },
        {
          "shortName": "UnusedMainParameter",
          "displayName": "Main parameter is not necessary",
          "enabled": false,
          "description": "Reports `main` function with an unused single parameter."
        },
        {
          "shortName": "FunctionWithLambdaExpressionBody",
          "displayName": "Function with '= { ... }' and inferred return type",
          "enabled": false,
          "description": "Reports functions with `= { ... }` and inferred return type.\n\n**Example:**\n\n\n      fun sum(a: Int, b: Int) = { a + b } // The return type of this function is '() -> Int'.\n\nThe quick fix removes braces:\n\n\n      fun sum(a: Int, b: Int) = a + b\n"
        },
        {
          "shortName": "ConvertTwoComparisonsToRangeCheck",
          "displayName": "Two comparisons should be converted to a range check",
          "enabled": false,
          "description": "Reports two consecutive comparisons that can be converted to a range check.\n\nChecking against a range makes code simpler by removing test subject duplication.\n\n**Example:**\n\n\n      fun checkMonth(month: Int): Boolean {\n          return month >= 1 && month <= 12\n      }\n\nA quick-fix replaces the comparison-based check with a range one:\n\n\n      fun checkMonth(month: Int): Boolean {\n          return month in 1..12\n      }\n"
        },
        {
          "shortName": "ReplaceSubstringWithIndexingOperation",
          "displayName": "'substring' call should be replaced with indexing operator",
          "enabled": false,
          "description": "Reports calls like `\"abc\".substring(0, 1)` that can be replaced with `\"abc\"[0]`.\n\nObtaining the element by index makes your code simpler.\n\nThe quick-fix replaces the `substring` call with the indexing operator.\n\n**Example:**\n\n\n      fun foo() {\n          \"abc\".substring(0, 1)\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun foo() {\n          \"abc\"[0]\n      }\n"
        },
        {
          "shortName": "MoveLambdaOutsideParentheses",
          "displayName": "Lambda argument inside parentheses",
          "enabled": false,
          "description": "Reports lambda expressions in parentheses which can be moved outside.\n\n**Example:**\n\n\n    fun square(a: Int, b: (Int) -> Int) {\n      b(a * a)\n    }\n\n    fun foo() {\n      square(2, { it })\n    }\n\nAfter the quick-fix is applied:\n\n\n    fun foo() {\n      square(2){ it }\n    }\n"
        },
        {
          "shortName": "CascadeIf",
          "displayName": "Cascade if can be replaced with when",
          "enabled": false,
          "description": "Reports `if` statements with three or more branches that can be replaced with the `when` expression.\n\n**Example:**\n\n\n      fun checkIdentifier(id: String) {\n          fun Char.isIdentifierStart() = this in 'A'..'z'\n          fun Char.isIdentifierPart() = isIdentifierStart() || this in '0'..'9'\n\n          if (id.isEmpty()) {\n              print(\"Identifier is empty\")\n          } else if (!id.first().isIdentifierStart()) {\n              print(\"Identifier should start with a letter\")\n          } else if (!id.subSequence(1, id.length).all(Char::isIdentifierPart)) {\n              print(\"Identifier should contain only letters and numbers\")\n          }\n      }\n\nA quick-fix converts the `if` expression to `when`:\n\n\n      fun checkIdentifier(id: String) {\n          fun Char.isIdentifierStart() = this in 'A'..'z'\n          fun Char.isIdentifierPart() = isIdentifierStart() || this in '0'..'9'\n\n          when {\n              id.isEmpty() -> {\n                  print(\"Identifier is empty\")\n              }\n              !id.first().isIdentifierStart() -> {\n                  print(\"Identifier should start with a letter\")\n              }\n              !id.subSequence(1, id.length).all(Char::isIdentifierPart) -> {\n                  print(\"Identifier should contain only letters and numbers\")\n              }\n          }\n      }\n"
        },
        {
          "shortName": "OptionalExpectation",
          "displayName": "Optionally expected annotation has no actual annotation",
          "enabled": false,
          "description": "Reports optionally expected annotations without actual annotation in some platform modules.\n\n**Example:**\n\n    // common code\n    @OptionalExpectation\n    expect annotation class JvmName(val name: String)\n\n    @JvmName(name = \"JvmFoo\")\n    fun foo() { }\n\n    // jvm code\n    actual annotation class JvmName(val name: String)\n\nThe inspection also reports cases when `actual annotation class JvmName` is omitted for non-JVM platforms (for example, Native)."
        },
        {
          "shortName": "IfThenToSafeAccess",
          "displayName": "If-Then foldable to '?.'",
          "enabled": false,
          "description": "Reports `if-then` expressions that can be folded into safe-access (`?.`) expressions.\n\n**Example:**\n\n\n      fun bar(x: String) = \"\"\n\n      fun foo(a: String?) {\n         if (a != null) bar(a) else null\n      }\n\nThe quick fix converts the `if-then` expression into a safe-access (`?.`) expression:\n\n\n      fun bar(x: String) = \"\"\n\n      fun foo(a: String?) {\n         a?.let { bar(it) }\n      }\n"
        },
        {
          "shortName": "RedundantElseInIf",
          "displayName": "Redundant 'else' in 'if'",
          "enabled": false,
          "description": "Reports redundant `else` in `if` with `return`\n\n**Example:**\n\n\n      fun foo(arg: Boolean): Int {\n          if (arg) return 0\n          else { // This else is redundant, code in braces could be just shifted left\n              someCode()\n          }\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun foo(arg: Boolean): Int {\n          if (arg) return 0\n          someCode()\n      }\n"
        },
        {
          "shortName": "ReplacePutWithAssignment",
          "displayName": "'map.put()' can be converted to assignment",
          "enabled": false,
          "description": "Reports `map.put` function calls that can be replaced with indexing operator (`[]`).\n\nUsing syntactic sugar makes your code simpler.\n\nThe quick-fix replaces `put` call with the assignment.\n\n**Example:**\n\n\n      fun foo(map: MutableMap<Int, String>) {\n          map.put(42, \"foo\")\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun foo(map: MutableMap<Int, String>) {\n          map[42] = \"foo\"\n      }\n"
        },
        {
          "shortName": "ConvertSecondaryConstructorToPrimary",
          "displayName": "Convert to primary constructor",
          "enabled": false,
          "description": "Reports a secondary constructor that can be replaced with a more concise primary constructor.\n\n**Example:**\n\n\n      class User {\n          val name: String\n\n          constructor(name: String) {\n              this.name = name\n          }\n      }\n\nA quick-fix converts code automatically:\n\n\n      class User(val name: String) {\n      }\n"
        },
        {
          "shortName": "ReplaceGetOrSet",
          "displayName": "Explicit 'get' or 'set' call",
          "enabled": false,
          "description": "Reports explicit calls to `get` or `set` functions which can be replaced by an indexing operator `[]`.\n\n\nKotlin allows custom implementations for the predefined set of operators on types.\nTo overload an operator, you can mark the corresponding function with the `operator` modifier:\n\n\n      operator fun get(index: Int) {}\n      operator fun set(index: Int, value: Int) {}\n        \nThe functions above correspond to the indexing operator.\n\n**Example:**\n\n      class Test {\n          operator fun get(i: Int): Int = 0\n      }\n\n      fun test() {\n          Test().get(0) // replaceable 'get()'\n      }\n\nAfter the quick-fix is applied:\n\n      class Test {\n          operator fun get(i: Int): Int = 0\n      }\n\n      fun test() {\n          Test()[0]\n      }\n"
        },
        {
          "shortName": "Destructure",
          "displayName": "Use destructuring declaration",
          "enabled": false,
          "description": "Reports declarations that can be destructured.\n\n**Example:**\n\n\n      data class My(val first: String, val second: Int, val third: Boolean)\n\n      fun foo(list: List<My>) {\n          list.forEach { my ->\n              println(my.second)\n              println(my.third)\n          }\n      }\n\nThe quick-fix destructures the declaration and introduces new variables with names from the corresponding class:\n\n\n      data class My(val first: String, val second: Int, val third: Boolean)\n\n      fun foo(list: List<My>) {\n          list.forEach { (_, second, third) ->\n              println(second)\n              println(third)\n          }\n      }\n"
        },
        {
          "shortName": "ConvertTryFinallyToUseCall",
          "displayName": "Convert try / finally to use() call",
          "enabled": false,
          "description": "Reports a `try-finally` block with `resource.close()` in `finally` which can be converted to a `resource.use()` call.\n\n`use()` is easier to read and less error-prone as there is no need in explicit `close()` call.\n\n**Example:**\n\n\n      fun example() {\n          val reader = File(\"file.txt\").bufferedReader()\n          try {\n              reader.lineSequence().forEach(::print)\n          } finally {\n              reader.close()\n          }\n      }\n\nAfter the quick-fix applied:\n\n\n      fun example() {\n          File(\"file.txt\").bufferedReader().use { reader ->\n              reader.lineSequence().forEach(::print)\n          }\n      }\n"
        },
        {
          "shortName": "ReplaceArrayOfWithLiteral",
          "displayName": "'arrayOf' call can be replaced with array literal [...]",
          "enabled": false,
          "description": "Reports `arrayOf` calls that can be replaced with array literals `[...]`.\n\n**Examples:**\n\n      annotation class MyAnnotation(val strings: Array<String>)\n\n      @MyAnnotation(arrayOf(\"alpha\", \"beta\", \"omega\")) // replaceable 'arrayOf()'\n      class MyClass\n\nAfter the quick-fix is applied:\n\n      annotation class MyAnnotation(val strings: Array<String>)\n\n      @MyAnnotation([\"alpha\", \"beta\", \"omega\"])\n      class MyClass\n"
        },
        {
          "shortName": "ReplaceRangeToWithUntil",
          "displayName": "'rangeTo' or the '..' call should be replaced with 'until'",
          "enabled": false,
          "description": "Reports calls to `rangeTo` or the `..` operator instead of calls to `until`.\n\nUsing corresponding functions makes your code simpler.\n\nThe quick-fix replaces `rangeTo` or the `..` call with `until`.\n\n**Example:**\n\n\n      fun foo(a: Int) {\n          for (i in 0..a - 1) {\n\n          }\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun foo(a: Int) {\n          for (i in 0 until a) {\n\n          }\n      }\n"
        },
        {
          "shortName": "ReplaceToWithInfixForm",
          "displayName": "'to' call should be replaced with infix form",
          "enabled": false,
          "description": "Reports `to` function calls that can be replaced with the infix form.\n\nUsing the infix form makes your code simpler.\n\nThe quick-fix replaces `to` with the infix form.\n\n**Example:**\n\n\n      fun foo(a: Int, b: Int) {\n          val pair = a.to(b)\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun foo(a: Int, b: Int) {\n          val pair = a to b\n      }\n"
        },
        {
          "shortName": "UnclearPrecedenceOfBinaryExpression",
          "displayName": "Multiple operators with different precedence",
          "enabled": false,
          "description": "Reports binary expressions that consist of different operators without parentheses.\n\nSuch expressions can be less readable due to different [precedence rules](https://kotlinlang.org/docs/reference/grammar.html#expressions) of operators.\n\nExample:\n\n```\n  fun foo(b: Boolean?, i: Int?) {\n      val x = b ?: i == null // evaluated as `(b ?: i) == null`\n      val y = i ?: 0 + 1 // evaluated as `i ?: (0 + 1)`\n  }\n```"
        }
      ]
    },
    {
      "name": "Redundant constructs",
      "inspections": [
        {
          "shortName": "SimpleRedundantLet",
          "displayName": "Redundant receiver-based 'let' call",
          "enabled": false,
          "description": "Reports redundant receiver-based `let` calls.\n\nThe quick-fix removes the redundant `let` call.\n\n**Example:**\n\n\n      fun test(s: String?): Int? = s?.let { it.length }\n\nAfter the quick-fix is applied:\n\n\n      fun test(s: String?): Int? = s?.length\n"
        },
        {
          "shortName": "RemoveSingleExpressionStringTemplate",
          "displayName": "Redundant string template",
          "enabled": false,
          "description": "Reports single-expression string templates that can be safely removed.\n\n**Example:**\n\n      val x = \"Hello\"\n      val y = \"$x\"\n\nAfter the quick-fix is applied:\n\n      val x = \"Hello\"\n      val y = x // <== Updated\n"
        },
        {
          "shortName": "RedundantSetter",
          "displayName": "Redundant property setter",
          "enabled": false,
          "description": "Reports redundant property setters.\n\n\nSetter is considered to be redundant in one of the following cases:\n\n1. Setter has no body. Accessor visibility isn't changed, declaration isn't `external` and has no annotations.\n\n\n         var myPropWithRedundantSetter: Int = 0\n             set // redundant\n\n         var myPropA: Int = 0\n             private set // OK - property visibility is changed to private\n\n         var myPropB: Int = 0\n             external set // OK - implemented not in Kotlin (external)\n\n         var myPropC: Int = 0\n             @Inject set // OK - accessor is annotated\n               \n2. Setter body is a block with a single statement assigning the parameter to the backing field.\n\n\n         var prop: Int = 0\n             set(value) { // redundant\n                 field = value\n             }\n              \n"
        },
        {
          "shortName": "RedundantLambdaOrAnonymousFunction",
          "displayName": "Redundant creation of lambda or anonymous function",
          "enabled": false,
          "description": "Reports lambdas or anonymous functions that are created and used immediately.\n\n\n      fun test() {\n          ({ println() })() // redundant\n          (fun() { println() })() // redundant\n      }\n"
        },
        {
          "shortName": "RedundantRequireNotNullCall",
          "displayName": "Redundant 'requireNotNull' or 'checkNotNull' call",
          "enabled": false,
          "description": "Reports redundant `requireNotNull` or `checkNotNull` call on non-nullable expressions.\n\n**Example:**\n\n\n      fun foo(i: Int) {\n          requireNotNull(i) // This 'i' is always not null, so this 'requireNotNull' call is redundant.\n          ...\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun foo(i: Int) {\n          ...\n      }\n"
        },
        {
          "shortName": "RedundantEnumConstructorInvocation",
          "displayName": "Redundant enum constructor invocation",
          "enabled": false,
          "description": "Reports redundant constructor invocation on an enum entry.\n\n**Example:**\n\n\n      enum class Baz(i: Int = 0) {\n          A(1),\n          B(),\n          C(),\n      }\n\nAfter the quick-fix is applied:\n\n\n      enum class Baz(i: Int = 0) {\n          A(1),\n          B,\n          C,\n      }\n"
        },
        {
          "shortName": "WhenWithOnlyElse",
          "displayName": "'when' has only 'else' branch and can be simplified",
          "enabled": false,
          "description": "Reports `when` expressions with only an `else` branch that can be simplified.\n\n**Simplify expression** quick-fix can be used to amend the code automatically.\n\nExample:\n\n\n      fun redundant() {\n          val x = when { // <== redundant, a quick-fix simplifies the when expression to \"val x = 1\"\n              else -> 1\n          }\n      }\n"
        },
        {
          "shortName": "RedundantSemicolon",
          "displayName": "Redundant semicolon",
          "enabled": false,
          "description": "Reports redundant semicolons (`;`) that can be safely removed.\n\n\nKotlin does not require a semicolon at the end of each statement or expression.\nA quick-fix is suggested to remove redundant semicolons.\n\n**Example:**\n\n\n      val myMap = mapOf(\"one\" to 1, \"two\" to 2);\n      myMap.forEach { (key, value) ->  print(\"$key -> $value\")};\n\nAfter the quick-fix is applied:\n\n\n      val myMap = mapOf(\"one\" to 1, \"two\" to 2)\n      myMap.forEach { (key, value) ->  print(\"$key -> $value\")}\n\nThere are two cases though where a semicolon is required:\n\n1. Several statements placed on a single line need to be separated with semicolons:\n\n\n         map.forEach { val (key, value) = it; println(\"$key -> $value\") }\n\n2. `enum` classes that also declare properties or functions, require a semicolon after the list of enum constants:\n\n\n         enum class Mode {\n             SILENT, VERBOSE;\n\n             fun isSilent(): Boolean = this == SILENT\n         }\n               \n"
        },
        {
          "shortName": "UnnecessaryOptInAnnotation",
          "displayName": "Unnecessary '@OptIn' annotation",
          "enabled": false,
          "description": "Reports unnecessary opt-in annotations that can be safely removed.\n\n`@OptIn` annotation is required for the code using experimental APIs that can change\nany time in the future. This annotation becomes useless and possibly misleading if no such API is used\n(e.g., when the experimental API becomes stable and does not require opting in its usage anymore).\n\n\n**Remove annotation** quick-fix can be used to remove the unnecessary `@OptIn` annotation.\n\nExample:\n\n\n      @OptIn(ExperimentalApi::class)\n      fun foo(x: Bar) {\n          x.baz()\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun foo(x: Bar) {\n          x.baz()\n      }\n"
        },
        {
          "shortName": "ComplexRedundantLet",
          "displayName": "Redundant argument-based 'let' call",
          "enabled": false,
          "description": "Reports a redundant argument-based `let` call.\n\n`let` is redundant when the lambda parameter is only used as a qualifier in a call expression.\n\nIf you need to give a name to the qualifying expression, declare a local variable.\n\n**Example:**\n\n\n      fun splitNumbers() {\n          \"1,2,3\".let { it.split(',') }\n      }\n\nA quick-fix removes the extra `let()` call:\n\n\n      fun example() {\n          \"1,2,3\".split(',')\n      }\n\nAlternative:\n\n\n      fun splitNumbers() {\n          val numbers = \"1,2,3\"\n          numbers.split(',')\n      }\n"
        },
        {
          "shortName": "RemoveRedundantSpreadOperator",
          "displayName": "Redundant spread operator",
          "enabled": false,
          "description": "Reports the use of a redundant spread operator for a family of `arrayOf` function calls.\n\nUse the 'Remove redundant spread operator' quick-fix to clean up the code.\n\n**Examples:**\n\n\n      fun foo(vararg s: String) { }\n\n      fun bar(ss: Array<String>) {\n          foo(*arrayOf(\"abc\"))       // for the both calls of 'foo', array creation\n          foo(*arrayOf(*ss, \"zzz\"))  // and its subsequent \"spreading\" is redundant\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun foo(vararg s: String) { }\n\n      fun bar(ss: Array<String>) {\n          foo(\"abc\")\n          foo(*ss, \"zzz\")\n      }\n"
        },
        {
          "shortName": "RemoveSetterParameterType",
          "displayName": "Redundant setter parameter type",
          "enabled": false,
          "description": "Reports explicitly specified parameter types in property setters.\n\n\nSetter parameter type always matches the property type, so it's not required to be explicit.\nThe 'Remove explicit type specification' quick-fix allows amending the code accordingly.\n\n**Examples:**\n\n\n      fun process(x: Int) {}\n\n      var x: Int = 0\n          set(value: Int) = process(value) // <== 'Int' specification can be safely omitted\n\nAfter the quick-fix is applied:\n\n\n      fun process(x: Int) {}\n\n      var x: Int = 0\n          set(value) = process(value)\n"
        },
        {
          "shortName": "RemoveEmptyParenthesesFromLambdaCall",
          "displayName": "Remove unnecessary parentheses from function call with lambda",
          "enabled": false,
          "description": "Reports redundant empty parentheses of function calls where the only parameter is a lambda that's outside the parentheses.\n\nUse the 'Remove unnecessary parentheses from function call with lambda' quick-fix to clean up the code.\n\n**Examples:**\n\n\n      fun foo() {\n          listOf(1).forEach() {  }\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun foo() {\n          listOf(1).forEach {  }\n      }\n"
        },
        {
          "shortName": "RemoveExplicitSuperQualifier",
          "displayName": "Unnecessary supertype qualification",
          "enabled": false,
          "description": "Reports `super` member calls with redundant supertype qualification.\n\n\nCode in a derived class can call its superclass functions and property accessors implementations using the `super` keyword.\nTo specify the supertype from which the inherited implementation is taken, `super` can be qualified by the supertype name in\nangle brackets, e.g. `super<Base>`. Sometimes this qualification is redundant and can be omitted.\nUse the 'Remove explicit supertype qualification' quick-fix to clean up the code.\n\n**Examples:**\n\n\n      open class B {\n          open fun foo(){}\n      }\n\n      class A : B() {\n          override fun foo() {\n             super<B>.foo() // <== redundant because 'B' is the only supertype\n          }\n      }\n\n      interface I {\n          fun foo() {}\n      }\n\n      class C : B(), I {\n          override fun foo() {\n              super<B>.foo() // <== here <B> qualifier is needed to distinguish 'B.foo()' from 'I.foo()'\n          }\n      }\n\nAfter the quick-fix is applied:\n\n\n      open class B {\n          open fun foo(){}\n      }\n\n      class A : B() {\n          override fun foo() {\n             super.foo() // <== Updated\n          }\n      }\n\n      interface I {\n          fun foo() {}\n      }\n\n      class C : B(), I {\n          override fun foo() {\n              super<B>.foo()\n          }\n      }\n"
        },
        {
          "shortName": "RedundantExplicitType",
          "displayName": "Obvious explicit type",
          "enabled": false,
          "description": "Reports local variables' explicitly given types which are obvious and thus redundant, like `val f: Foo = Foo()`.\n\n**Example:**\n\n\n      class Point(val x: Int, val y: Int)\n\n      fun foo() {\n          val t: Boolean = true\n          val p: Point = Point(1, 2)\n          val i: Int = 42\n      }\n\nAfter the quick-fix is applied:\n\n\n      class Point(val x: Int, val y: Int)\n\n      fun foo() {\n          val t = true\n          val p = Point(1, 2)\n          val i = 42\n      }\n"
        },
        {
          "shortName": "UnusedSymbol",
          "displayName": "Unused symbol",
          "enabled": false,
          "description": "Reports symbols that are not used or not reachable from entry points."
        },
        {
          "shortName": "RemoveEmptyPrimaryConstructor",
          "displayName": "Redundant empty primary constructor",
          "enabled": false,
          "description": "Reports empty primary constructors when they are implicitly available anyway.\n\n\nA primary constructor is redundant and can be safely omitted when it does not have any annotations or visibility modifiers.\nUse the 'Remove empty primary constructor' quick-fix to clean up the code.\n\n**Examples:**\n\n\n      class MyClassA constructor() //  redundant, can be replaced with 'class MyClassA'\n\n      annotation class MyAnnotation\n      class MyClassB @MyAnnotation constructor() //  required because of annotation\n\n      class MyClassC private constructor() // required because of visibility modifier\n"
        },
        {
          "shortName": "RemoveEmptySecondaryConstructorBody",
          "displayName": "Redundant constructor body",
          "enabled": false,
          "description": "Reports empty bodies of secondary constructors."
        },
        {
          "shortName": "RedundantGetter",
          "displayName": "Redundant property getter",
          "enabled": false,
          "description": "Reports redundant property getters.\n\n**Example:**\n\n\n      class Test {\n          val a = 1\n              get\n          val b = 1\n              get() = field\n      }\n\nAfter the quick-fix is applied:\n\n\n      class Test {\n          val a = 1\n          val b = 1\n      }\n"
        },
        {
          "shortName": "RedundantIf",
          "displayName": "Redundant 'if' statement",
          "enabled": false,
          "description": "Reports `if` statements which can be simplified to a single statement.\n\n**Example:**\n\n\n      fun test() {\n          if (foo()) {\n             return true\n          } else {\n             return false\n          }\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun test() {\n          return foo()\n      }\n"
        },
        {
          "shortName": "RemoveExplicitTypeArguments",
          "displayName": "Unnecessary type argument",
          "enabled": false,
          "description": "Reports function calls with type arguments that can be automatically inferred. Such type arguments are redundant and can be safely omitted.\n\nUse the 'Remove explicit type arguments' quick-fix to clean up the code.\n\n**Examples:**\n\n\n      // 'String' type can be inferred here\n      fun foo(): MutableList<String> = mutableListOf<String>()\n\n      // Here 'String' cannot be inferred, type argument is required.\n      fun bar() = mutableListOf<String>()\n\nAfter the quick-fix is applied:\n\n\n      fun foo(): MutableList<String> = mutableListOf() <== Updated\n\n      fun bar() = mutableListOf<String>()\n"
        },
        {
          "shortName": "RedundantVisibilityModifier",
          "displayName": "Redundant visibility modifier",
          "enabled": false,
          "description": "Reports visibility modifiers that match the default visibility of an element (`public` for most elements, `protected` for members that override a protected member)."
        },
        {
          "shortName": "RedundantInnerClassModifier",
          "displayName": "Redundant 'inner' modifier",
          "enabled": false,
          "description": "Reports the `inner` modifier on a class as redundant if it doesn't reference members of its outer class.\n\n**Example:**\n\n\n      class Foo {\n          inner class InnerClass { // redundant `inner` modifier\n              fun hello() {\n                  println(\"Hi!\")\n              }\n          }\n      }\n\n      class List {\n          val objects = Array<Any>(42) { Any() }\n\n          inner class Iterator { // Not redundant `inner` modifier\n              fun next(): Any {\n                  return objects[0]\n              }\n          }\n      }\n\nAfter the quick-fix is applied:\n\n\n      class Foo {\n          class InnerClass { // redundant `inner` modifier\n              fun hello() {\n                  println(\"Hi!\")\n              }\n          }\n      }\n\n      class List {\n          val objects = Array<Any>(42) { Any() }\n\n          inner class Iterator { // Not redundant `inner` modifier\n              fun next(): Any {\n                  return objects[0]\n              }\n          }\n      }\n"
        },
        {
          "shortName": "UnnecessaryVariable",
          "displayName": "Unnecessary local variable",
          "enabled": false,
          "description": "Reports local variables that used only in the very next `return` statement or exact copies of other variables.\n\nSuch variables can be safely inlined to make the code more clear."
        },
        {
          "shortName": "RedundantEmptyInitializerBlock",
          "displayName": "Redundant empty initializer block",
          "enabled": false,
          "description": "Reports redundant empty initializer blocks.\n\n**Example:**\n\n\n      class Foo {\n          init {\n              // Empty init block\n          }\n      }\n\nAfter the quick-fix is applied:\n\n\n      class Foo {\n      }\n"
        },
        {
          "shortName": "RedundantWith",
          "displayName": "Redundant 'with' call",
          "enabled": false,
          "description": "Reports redundant `with` function calls that don't access anything from the receiver.\n\n**Examples:**\n\n\n      class MyClass {\n          fun f(): String = \"\"\n      }\n\n      fun testRedundant() {\n          with(c) { // <== 'with' is redundant since 'c' isn't used\n              println(\"1\")\n          }\n      }\n\n      fun testOk() {\n          val c = MyClass()\n          with(c) { // <== OK because 'f()' is effectively 'c.f()'\n              println(f())\n          }\n      }\n"
        },
        {
          "shortName": "ConstantConditionIf",
          "displayName": "Condition of 'if' expression is constant",
          "enabled": false,
          "description": "Reports `if` expressions that have `true` or `false` constant literal condition and can be simplified.\n\nWhile occasionally intended, this construction is confusing and often the result of a typo\nor previous refactoring.\n\n**Example:**\n\n\n      fun example() {\n          if (true) {\n              throw IllegalStateException(\"Unexpected state\")\n          }\n      }\n\nA quick-fix removes the `if` condition:\n\n\n      fun example() {\n          throw IllegalStateException(\"Unexpected state\")\n      }\n"
        },
        {
          "shortName": "RedundantLambdaArrow",
          "displayName": "Redundant lambda arrow",
          "enabled": false,
          "description": "Reports redundant lambda arrows in lambdas without parameters.\n\n**Example:**\n\n\n      fun foo(f: () -> Unit) = f()\n\n      fun bar() {\n          foo { -\\> println(\"Hi!\") }\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun foo(f: () -> Unit) = f()\n\n      fun bar() {\n          foo { println(\"Hi!\") }\n      }\n"
        },
        {
          "shortName": "RedundantModalityModifier",
          "displayName": "Redundant modality modifier",
          "enabled": false,
          "description": "Reports the modality modifiers that match the default modality of an element (`final` for most elements, `open` for members with an `override`).\n\n**Example:**\n\n\n      final class Foo\n\n      open class Bar : Comparable<Bar> {\n          open override fun compareTo(other: Bar): Int = 0\n      }\n\nAfter the quick-fix is applied:\n\n\n      class Foo\n\n      open class Bar : Comparable<Bar> {\n          open override fun compareTo(other: Bar): Int = 0\n      }\n"
        },
        {
          "shortName": "RemoveToStringInStringTemplate",
          "displayName": "Redundant call to 'toString()' in string template",
          "enabled": false,
          "description": "Reports calls to `toString()` in string templates that can be safely removed.\n\n**Example:**\n\n      fun foo(a: Int, b: Int) = a + b\n\n      fun test(): String {\n          return \"Foo: ${foo(0, 4).toString()}\" // 'toString()' is redundant\n      }\n\nAfter the quick-fix is applied:\n\n      fun foo(a: Int, b: Int) = a + b\n\n      fun test(): String {\n          return \"Foo: ${foo(0, 4)}\"\n      }\n"
        },
        {
          "shortName": "KotlinUnusedImport",
          "displayName": "Unused import directive",
          "enabled": false,
          "description": "Reports redundant `import` statements.\n\nDefault and unused imports can be safely removed.\n\n**Example:**\n\n\n      import kotlin.*\n      import kotlin.collections.*\n      import kotlin.comparisons.*\n      import kotlin.io.*\n      import kotlin.ranges.*\n      import kotlin.sequences.*\n      import kotlin.text.*\n\n      // jvm specific\n      import java.lang.*\n      import kotlin.jvm.*\n\n      // js specific\n      import kotlin.js.*\n\n      import java.io.* // this import is unused and could be removed\n      import java.util.*\n\n      fun foo(list: ArrayList<String>) {\n          list.add(\"\")\n      }\n"
        },
        {
          "shortName": "CanBePrimaryConstructorProperty",
          "displayName": "Property is explicitly assigned to constructor parameter",
          "enabled": false,
          "description": "Reports properties that are explicitly assigned to primary constructor parameters.\n\nProperties can be declared directly in the primary constructor, reducing the amount of code and increasing code readability.\n\n**Example:**\n\n\n      class User(name: String) {\n          val name = name\n      }\n\nA quick-fix joins the parameter and property declaration into a primary constructor parameter:\n\n\n      class User(val name: String) {\n      }\n"
        },
        {
          "shortName": "ReplaceWithIgnoreCaseEquals",
          "displayName": "Should be replaced with 'equals(..., ignoreCase = true)'",
          "enabled": false,
          "description": "Reports case-insensitive comparisons that can be replaced with `equals(..., ignoreCase = true)`.\n\nBy using `equals()` you don't have to allocate extra strings with `toLowerCase()` or `toUpperCase()` to compare strings.\n\nThe quick-fix replaces the case-insensitive comparison that uses `toLowerCase()` or `toUpperCase()` with `equals(..., ignoreCase = true)`.\n\n**Note:** May change semantics for some locales.\n\n**Example:**\n\n\n      fun main() {\n          val a = \"KoTliN\"\n          val b = \"KOTLIN\"\n          println(a.toLowerCase() == b.toLowerCase())\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun main() {\n          val a = \"KoTliN\"\n          val b = \"KOTLIN\"\n          println(a.equals(b, ignoreCase = true))\n      }\n"
        },
        {
          "shortName": "RedundantCompanionReference",
          "displayName": "Redundant 'Companion' reference",
          "enabled": false,
          "description": "Reports redundant `Companion` reference.\n\n**Example:**\n\n\n      class A {\n          companion object {\n              fun create() = A()\n          }\n      }\n      fun test() {\n          val s = A.Companion.create()\n      }\n\nAfter the quick-fix is applied:\n\n\n      class A {\n          companion object {\n              fun create() = A()\n          }\n      }\n      fun test() {\n          val s = A.create()\n      }\n"
        },
        {
          "shortName": "SimplifyWhenWithBooleanConstantCondition",
          "displayName": "Simplifiable 'when'",
          "enabled": false,
          "description": "Reports `when` expressions with the constant `true` or `false` branches.\n\n**Simplify \"when\"** quick-fix can be used to amend the code automatically.\n\nExamples:\n\n\n      fun redundant() {\n          when { // <== redundant, quick-fix simplifies the when expression to \"println(\"true\")\"\n              true -> println(\"true\")\n              else -> println(\"false\")\n          }\n      }\n"
        },
        {
          "shortName": "RedundantSamConstructor",
          "displayName": "Redundant SAM constructor",
          "enabled": false,
          "description": "Reports SAM (Single Abstract Method) constructor usages which can be replaced with lambdas.\n\n**Example:**\n\n\n      fun main() {\n          foo(Runnable { println(\"Hi!\") })\n      }\n\n      fun foo(other: Runnable) {}\n\nAfter the quick-fix is applied:\n\n\n      fun main() {\n          foo( { println(\"Hi!\") })\n      }\n\n      fun foo(other: Runnable) {}\n"
        },
        {
          "shortName": "RemoveRedundantCallsOfConversionMethods",
          "displayName": "Redundant call of conversion method",
          "enabled": false,
          "description": "Reports redundant calls to conversion methods (for example, `toString()` on a `String` or `toDouble()` on a `Double`).\n\nUse the 'Remove redundant calls of the conversion method' quick-fix to clean up the code."
        },
        {
          "shortName": "RemoveForLoopIndices",
          "displayName": "Unused loop index",
          "enabled": false,
          "description": "Reports `for` loops iterating over a collection using the `withIndex()` function and not using the index variable.\n\nUse the \"Remove indices in 'for' loop\" quick-fix to clean up the code.\n\n**Examples:**\n\n\n      fun foo(bar: List<String>) {\n         for ((index : Int, value: String) in bar.withIndex()) { // <== 'index' is unused\n             println(value)\n         }\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun foo(bar: List<String>) {\n          for (value: String in bar) { // <== '.withIndex()' and 'index' are removed\n              println(value)\n          }\n      }\n"
        },
        {
          "shortName": "RedundantSuspendModifier",
          "displayName": "Redundant 'suspend' modifier",
          "enabled": false,
          "description": "Reports `suspend` modifier as redundant if no other suspending functions are called inside."
        },
        {
          "shortName": "RemoveRedundantBackticks",
          "displayName": "Redundant backticks",
          "enabled": false,
          "description": "Reports redundant backticks in references.\n\n\nSome of the Kotlin keywords are valid identifiers in Java, for example: `in`, `object`, `is`.\nIf a Java library uses a Kotlin keyword for a method, you can still call the method escaping it\nwith the backtick character (`````), for example, ``foo.`is`(bar)``.\nSometimes this escaping is redundant and can be safely omitted. The inspection discovers and reports such cases and is\npaired with the 'Remove redundant backticks' quick-fix, which allows you to amend the highlighted code.\n\n**Examples:**\n\n\n      fun `is`(x: String) {}\n      fun foo() {\n          `is`(\"bar\") // 'is' is a keyword, backticks are required\n      }\n\n      fun `test that smth works as designed`() {} // OK, complex identifier for readability improvement\n\n      val `a` = 1  // no need for backticks\n"
        },
        {
          "shortName": "ExplicitThis",
          "displayName": "Redundant explicit 'this'",
          "enabled": false,
          "description": "Reports an explicit `this` when it can be omitted.\n\n**Example:**\n\n\n      class C {\n          private val i = 1\n          fun f() = this.i\n      }\n\nThe quick-fix removes the redundant `this`:\n\n\n      class C {\n          private val i = 1\n          fun f() = i\n      }\n"
        },
        {
          "shortName": "NullChecksToSafeCall",
          "displayName": "Null-checks can be replaced with safe-calls",
          "enabled": false,
          "description": "Reports chained null-checks that can be replaced with safe-calls.\n\n**Example:**\n\n\n      fun test(my: My?) {\n          if (my != null && my.foo() != null) {}\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun test(my: My?) {\n          if (my?.foo() != null) {}\n      }\n"
        },
        {
          "shortName": "RemoveEmptyClassBody",
          "displayName": "Replace empty class body",
          "enabled": false,
          "description": "Reports declarations of classes and objects with an empty body.\n\nUse the 'Remove redundant empty class body' quick-fix to clean up the code.\n\n**Examples:**\n\n\n      class EmptyA() {} // <== empty body\n\n      class EmptyB {\n          companion object {} // <== empty body\n      }\n\n      fun emptyC() {\n         object {} // <== anonymous object, it's ok (not reported)\n      }\n\nAfter the quick fix is applied:\n\n\n      class EmptyA()\n\n      class EmptyB {\n          companion object\n      }\n\n      fun emptyC() {\n         object {}\n      }\n"
        },
        {
          "shortName": "CanBeParameter",
          "displayName": "Constructor parameter is never used as a property",
          "enabled": false,
          "description": "Reports primary constructor parameters that can have `val` or `var` removed.\n\n\nClass properties declared in the constructor increase memory consumption.\nIf the parameter value is only used in the constructor, you can omit them.\n\nNote that the referenced object might be garbage-collected earlier.\n\n**Example:**\n\n\n      class Task(val name: String) {\n          init {\n              print(\"Task created: $name\")\n          }\n      }\n\nA quick-fix removes the extra `val` or `var` keyword:\n\n\n      class Task(name: String) {\n          init {\n              print(\"Task created: $name\")\n          }\n      }\n"
        },
        {
          "shortName": "RedundantReturnLabel",
          "displayName": "Redundant 'return' label",
          "enabled": false,
          "description": "Reports redundant return labels outside of lambda expressions.\n\n**Example:**\n\n\n      fun test() {\n          return@test\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun test() {\n          return\n      }\n"
        },
        {
          "shortName": "RemoveRedundantQualifierName",
          "displayName": "Redundant qualifier name",
          "enabled": false,
          "description": "Reports redundant qualifiers (or their parts) on class names, functions, and properties.\n\n\nA fully qualified name is an unambiguous identifier that specifies which object, function, or property a call refers to.\nIn the contexts where the name can be shortened, the inspection informs on the opportunity and the associated\n'Remove redundant qualifier name' quick-fix allows amending the code.\n\n**Examples:**\n\n\n      package my.simple.name\n      import kotlin.Int.Companion.MAX_VALUE\n\n      class Foo\n\n      fun main() {\n          val a = my.simple.name.Foo()    // 'Foo' resides in the declared 'my.simple.name' package, qualifier is redundant\n          val b = kotlin.Int.MAX_VALUE    // Can be replaced with 'MAX_VALUE' since it's imported\n          val c = kotlin.Double.MAX_VALUE // Can be replaced with 'Double.MAX_VALUE' since built-in types are imported automatically\n      }\n\nAfter the quick-fix is applied:\n\n\n      package my.simple.name\n      import kotlin.Int.Companion.MAX_VALUE\n\n      class Foo\n\n      fun main() {\n          val a = Foo()\n          val b = MAX_VALUE\n          val c = Double.MAX_VALUE\n      }\n"
        },
        {
          "shortName": "RemoveCurlyBracesFromTemplate",
          "displayName": "Redundant curly braces in string template",
          "enabled": false,
          "description": "Reports usages of curly braces in string templates around simple identifiers.\n\nUse the 'Remove curly braces' quick-fix to remove the redundant braces.\n\n**Examples:**\n\n\n      fun redundant() {\n         val x = 4\n         val y = \"${x}\" // <== redundant\n      }\n\n      fun correctUsage() {\n          val x = \"x\"\n          val y = \"${x.length}\" // <== Ok\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun redundant() {\n         val x = 4\n         val y = \"$x\"\n      }\n\n      fun correctUsage() {\n          val x = \"x\" <== Updated\n          val y = \"${x.length}\"\n      }\n"
        },
        {
          "shortName": "RedundantElvisReturnNull",
          "displayName": "Redundant '?: return null'",
          "enabled": false,
          "description": "Reports redundant `?: return null`\n\n**Example:**\n\n\n      fun foo(): Int? {\n          ...\n      }\n\n      fun test() : Int? {\n          return foo() ?: return null\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun foo(): Int? {\n          ...\n      }\n\n      fun test() : Int? {\n          return foo()\n      }\n"
        },
        {
          "shortName": "RedundantUnitExpression",
          "displayName": "Redundant 'Unit'",
          "enabled": false,
          "description": "Reports redundant `Unit` expressions.\n\n\n`Unit` in Kotlin can be used as the return type of functions that do not return anything meaningful.\nThe `Unit` type has only one possible value, which is the `Unit` object.\n\n**Examples:**\n\n\n      fun redundantA(): Unit {\n          return Unit // redundant, 'Unit' is returned by default and matches the expected return type\n      }\n\n      fun requiredA(condition: Boolean): Any {\n          if (condition) return \"hello\"\n          return Unit // explicit 'Unit' is required since the expected type is 'Any'\n      }\n\n      fun redundantB(condition: Boolean): Any = if (condition) {\n          fun ancillary(): Int = 1\n          println(\"${ancillary()}\")\n          Unit // redundant since the last expression is already of type 'Unit'\n      } else {\n          println(\"else\")\n      }\n\n      fun requiredB(condition: Boolean): Any = if (condition) {\n          1024\n          Unit // required, otherwise '1024' (Int) would be the return value\n      } else {\n          println(\"else\")\n      }\n"
        },
        {
          "shortName": "KotlinDoubleNegation",
          "displayName": "Redundant double negation",
          "enabled": false,
          "description": "Reports redundant double negations.\n\n**Example:**\n\n      val truth = !!true\n"
        },
        {
          "shortName": "RedundantUnitReturnType",
          "displayName": "Redundant 'Unit' return type",
          "enabled": false,
          "description": "Reports a redundant `Unit` return type which can be omitted."
        },
        {
          "shortName": "UnusedReceiverParameter",
          "displayName": "Unused receiver parameter",
          "enabled": false,
          "description": "Reports receiver parameter of extension functions and properties that is not used.\n\n**Remove redundant receiver parameter** can be used to amend the code automatically."
        },
        {
          "shortName": "KotlinRedundantOverride",
          "displayName": "Redundant overriding method",
          "enabled": false,
          "description": "Reports redundant overriding declarations.\n\n\nAn override can be omitted if it does not modify the inherited signature semantics, for example, by changing visibility.\n\n**Example:**\n\n\n      open class Foo {\n          open fun singleExpression() {\n          }\n      }\n\n      class Bar : Foo() {\n          override fun singleExpression() = super.singleExpression()\n      }\n\nAfter the quick-fix is applied:\n\n\n      class Bar : Foo() {\n      }\n"
        },
        {
          "shortName": "RedundantNullableReturnType",
          "displayName": "Redundant nullable return type",
          "enabled": false,
          "description": "Reports functions and variables with nullable return type which never return or become `null`.\n\n**Example:**\n\n\n      fun greeting(user: String): String? = \"Hello, $user!\"\n\nAfter the quick-fix is applied:\n\n\n      fun greeting(user: String): String = \"Hello, $user!\"\n"
        }
      ]
    },
    {
      "name": "Portability",
      "inspections": [
        {
          "shortName": "RuntimeExec",
          "displayName": "Call to 'Runtime.exec()'",
          "enabled": false,
          "description": "Reports calls to `Runtime.exec()` or any of its variants. Calls to `Runtime.exec()` are inherently unportable."
        },
        {
          "shortName": "SystemExit",
          "displayName": "Call to 'System.exit()' or related methods",
          "enabled": false,
          "description": "Reports calls to `System.exit()`, `Runtime.exit()`, and `Runtime.halt()`.\n\n\nInvoking `System.exit()` or `Runtime.exit()`\ncalls the shutdown hooks and terminates the currently running Java\nvirtual machine. Invoking `Runtime.halt()` forcibly\nterminates the JVM without causing shutdown hooks to be started.\nEach of these methods should be used with extreme caution. Calls\nto these methods make the calling code unportable to most\napplication servers.\n\n\nUse the option to ignore calls in main methods."
        },
        {
          "shortName": "HardcodedFileSeparators",
          "displayName": "Hardcoded file separator",
          "enabled": false,
          "description": "Reports the forward (`/`) or backward (`\\`) slash in a string or character literal. These characters are commonly used as file separators, and portability may suffer if they are hardcoded.\n\n\nThe inspection will not report backward slashes inside escape sequences and forward slashes immediately following the '\\<' character\nor immediately preceding the '\\>' character, as those often indicate XML or HTML tags rather than file names.\nStrings representing a `java.util.TimeZone` ID, strings that are valid regular expressions,\nor strings that equal IANA-registered MIME media types will not be reported either.\n\n**Example:**\n\n\n      new File(\"C:\\\\Users\\\\Name\");\n\n\nUse the option to include `example/*` in the set of recognized media types.\nNormally, usage of the `example/*` MIME media type outside of an example (e.g. in a `Content-Type`\nheader) is an error."
        },
        {
          "shortName": "UseOfAWTPeerClass",
          "displayName": "Use of AWT peer class",
          "enabled": false,
          "description": "Reports uses of AWT peer classes. Such classes represent native windowing system widgets, and will be non-portable between different windowing systems.\n\n**Example:**\n\n\n      import java.awt.peer.ButtonPeer;\n\n      abstract class Sample implements ButtonPeer {\n        public void foo() {\n            Sample sample;\n        }\n      }\n"
        },
        {
          "shortName": "NativeMethods",
          "displayName": "Native method",
          "enabled": false,
          "description": "Reports methods declared `native`. Native methods are inherently unportable."
        },
        {
          "shortName": "HardcodedLineSeparators",
          "displayName": "Hardcoded line separator",
          "enabled": false,
          "description": "Reports linefeed (`\\n`) and carriage return (`\\r`) character escape sequences used in string literals, character literals or text blocks. These characters are commonly used as line separators, and portability may suffer if they are hardcoded.\n\n**Example:**\n\n\n      String count = \"first\\nsecond\\rthird\";\n"
        },
        {
          "shortName": "UseOfSunClasses",
          "displayName": "Use of 'sun.*' classes",
          "enabled": false,
          "description": "Reports uses of classes from the `sun.*` hierarchy. Such classes are non-portable between different JVMs."
        },
        {
          "shortName": "UseOfJDBCDriverClass",
          "displayName": "Use of concrete JDBC driver class",
          "enabled": false,
          "description": "Reports uses of specific JDBC driver classes. Use of such classes will bind your project to a specific database and driver, defeating the purpose of JDBC and resulting in loss of portability.\n\n**Example:**\n\n\n      import java.sql.Driver;\n\n      abstract class Sample implements Driver {\n        public void foo() {\n            Sample sample;\n        }\n      }\n"
        },
        {
          "shortName": "SystemGetenv",
          "displayName": "Call to 'System.getenv()'",
          "enabled": false,
          "description": "Reports calls to `System.getenv()`. Calls to `System.getenv()` are inherently unportable."
        },
        {
          "shortName": "UseOfProcessBuilder",
          "displayName": "Use of 'java.lang.ProcessBuilder' class",
          "enabled": false,
          "description": "Reports uses of `java.lang.ProcessBuilder`, which might be unportable between operating systems because paths to executables, environment variables, command-line arguments and their escaping might vary depending on the OS."
        }
      ]
    },
    {
      "name": "Threading issues",
      "inspections": [
        {
          "shortName": "StaticInitializerReferencesSubClass",
          "displayName": "Static initializer references subclass",
          "enabled": true,
          "description": "Reports classes that refer to their subclasses in static initializers or static fields.\n\nSuch references can cause JVM-level deadlocks in multithreaded environment, when one thread tries to load the superclass\nand another thread tries to load the subclass at the same time.\n\n**Example:**\n\n\n      class Parent {\n        static final Child field = new Child();\n      }\n      class Child extends Parent { }\n"
        },
        {
          "shortName": "FieldAccessedSynchronizedAndUnsynchronized",
          "displayName": "Field accessed in both 'synchronized' and unsynchronized contexts",
          "enabled": true,
          "description": "Reports non-final fields that are accessed in both `synchronized` and non-`synchronized` contexts. `volatile` fields as well as accesses in constructors and initializers are ignored by this inspection.\n\n\nSuch \"partially synchronized\" access is often the result of a coding oversight\nand may lead to unexpectedly inconsistent data structures.\n\n**Example:**\n\n\n      public class Program {\n        Console console; // warning: Field 'console' is accessed in both synchronized and unsynchronized contexts\n\n        public synchronized void execute() {\n          console.print(\"running\");\n        }\n\n        public void check() {\n          console.check();\n        }\n      }\n\n\nUse the option to specify if simple getters and setters are counted as accesses too."
        },
        {
          "shortName": "NonSynchronizedMethodOverridesSynchronizedMethod",
          "displayName": "Unsynchronized method overrides 'synchronized' method",
          "enabled": true,
          "description": "Reports non-`synchronized` methods overriding `synchronized` methods.\n\n\nThe overridden method will not be automatically synchronized if the superclass method\nis declared as `synchronized`. This may result in unexpected race conditions when using the subclass.\n\n**Example:**\n\n\n      class Super {\n        synchronized void process() {}\n      }\n      class Sub extends Super {\n        // Unsynchronized method 'process()' overrides synchronized method\n        void process() {}\n      }  \n"
        },
        {
          "shortName": "WaitCalledOnCondition",
          "displayName": "'wait()' called on 'java.util.concurrent.locks.Condition' object",
          "enabled": false,
          "description": "Reports calls to `wait()` made on a `java.util.concurrent.locks.Condition` object. This is probably a programming error, and some variant of the `await()` method was intended instead.\n\n**Example:**\n\n\n      void acquire(Condition released) throws InterruptedException {\n        while (acquired) {\n          released.wait();\n        }\n      }\n\nGood code would look like this:\n\n\n      void acquire(Condition released) throws InterruptedException {\n        while (acquired) {\n          released.await();\n        }\n      }\n"
        },
        {
          "shortName": "WaitNotifyNotInSynchronizedContext",
          "displayName": "'wait()' or 'notify()' is not in synchronized context",
          "enabled": false,
          "description": "Reports calls to `wait()`, `notify()`, and `notifyAll()` that are not made inside a corresponding synchronized statement or synchronized method.\n\n\nCalling these methods on an object\nwithout holding a lock on that object causes `IllegalMonitorStateException`.\nSuch a construct is not necessarily an error, as the necessary lock may be acquired before\nthe containing method is called, but it's worth looking at.\n\n**Example:**\n\n\n      class Sync {\n        private final Object lock = new Object();\n\n        void test() throws InterruptedException {\n          synchronized (this) {\n            lock.wait(); // 'lock.wait()' is not synchronized on 'lock'\n          }\n        }\n      }\n"
        },
        {
          "shortName": "ExtendsThread",
          "displayName": "Class directly extends 'Thread'",
          "enabled": false,
          "description": "Reports classes that directly extend `java.lang.Thread`. It is usually recommended to prefer composition over inheritance to create more reusable code that is easier to modify later.\n\n**Example:**\n\n\n      class MainThread extends Thread {\n      }\n"
        },
        {
          "shortName": "ThreadStopSuspendResume",
          "displayName": "Call to 'Thread.stop()', 'suspend()' or 'resume()'",
          "enabled": false,
          "description": "Reports calls to `Thread.stop()`, `Thread.suspend()`, and `Thread.resume()`.\n\n\nThese calls are inherently prone to data corruption and deadlocks, and their use is strongly discouraged.\nIt is better to use cooperative cancellation instead of `stop`, and\ninterruption instead of direct calls to `suspend` and `resume`."
        },
        {
          "shortName": "SignalWithoutCorrespondingAwait",
          "displayName": "'signal()' without corresponding 'await()'",
          "enabled": false,
          "description": "Reports calls to `Condition.signal()` or `Condition.signalAll()` for which no call to a corresponding `Condition.await()` can be found.\n\nOnly calls that target fields of the current class are reported by this inspection.\n\n**Example:**\n\n\n      class Queue {\n        private final Condition isEmpty = ...;\n\n        void add(Object elem) {\n          // ...\n          isEmpty.signal(); // warning: Call to 'signal()' without corresponding 'await()'\n          // ...\n        }\n\n        void remove(Object elem) throws InterruptedException {\n          // ...\n          //      isEmpty.await();\n          // ...\n        }\n      }\n"
        },
        {
          "shortName": "MethodMayBeSynchronized",
          "displayName": "Method with single 'synchronized' block can be replaced with 'synchronized' method",
          "enabled": false,
          "description": "Reports methods whose body contains a single `synchronized` statement. A lock expression for this `synchronized` statement must be equal to `this` for instance methods or `[ClassName].class` for static methods.\n\n\nTo improve readability of such methods,\nyou can remove the `synchronized` wrapper and mark the method as `synchronized`.\n\n**Example:**\n\n\n      public int generateInt(int x) {\n        synchronized (this) {\n          return 1;\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      public synchronized int generateInt(int x) {\n        return 1;\n      }\n"
        },
        {
          "shortName": "SynchronizationOnLocalVariableOrMethodParameter",
          "displayName": "Synchronization on local variable or method parameter",
          "enabled": true,
          "description": "Reports synchronization on a local variable or parameter.\n\n\nIt is very difficult to guarantee correct operation when such synchronization is used.\nIt may be possible to improve such code, for example, by controlling access using a synchronized wrapper class or by synchronizing on a\nfield.\n\n**Example:**\n\n\n      void bar() {\n        final Object lock = new Object();\n        synchronized (lock) { }\n      }\n"
        },
        {
          "shortName": "ThreadYield",
          "displayName": "Call to 'Thread.yield()'",
          "enabled": false,
          "description": "Reports calls to `Thread.yield()`.\n\n\nThe behavior of `yield()` is non-deterministic and platform-dependent, and it is rarely appropriate to use this method.\nIts use should be combined with detailed profiling and benchmarking to ensure that it actually has the desired effect.\n\n**Example:**\n\n\n      public static void main(String[] args) {\n        Runnable r = () -> {\n          for (int i = 0; i < 10; i++) {\n            System.out.println(i);\n            Thread.yield();\n          }\n        };\n        new Thread(r).start();\n        new Thread(r).start();\n      }\n"
        },
        {
          "shortName": "AtomicFieldUpdaterIssues",
          "displayName": "Inconsistent 'AtomicFieldUpdater' declaration",
          "enabled": true,
          "description": "Reports issues with `AtomicLongFieldUpdater`, `AtomicIntegerFieldUpdater`, or `AtomicReferenceFieldUpdater` fields (the `java.util.concurrent.atomic` package).\n\nThe reported issues are identical to the runtime problems that can happen with atomic field updaters:\nspecified field not found, specified field not accessible, specified field has a wrong type, and so on.\n\n**Examples:**\n\n*\n\n\n        class A {\n          private static volatile int value = 0;\n          private static final AtomicIntegerFieldUpdater updater =\n          AtomicIntegerFieldUpdater.newUpdater((A.class), \"value\"); // warning: Field 'value' has 'static' modifier\n        }\n        \n*\n\n\n        class B {\n          private static final AtomicIntegerFieldUpdater updater =\n            AtomicIntegerFieldUpdater.newUpdater(B.class, \"value\"); // warning: No field named 'value' found in class 'B'\n        }\n        \n"
        },
        {
          "shortName": "ThreadStartInConstruction",
          "displayName": "Call to 'Thread.start()' during object construction",
          "enabled": true,
          "description": "Reports calls to `start()` on `java.lang.Thread` or any of its subclasses during object construction.\n\n\nWhile occasionally useful, such constructs should be avoided due to inheritance issues.\nSubclasses of a class that launches a thread during the object construction will not have finished\nany initialization logic of their own before the thread has launched.\n\nThis inspection does not report if the class that starts a thread is declared `final`.\n\n**Example:**\n\n\n      class MyThread extends Thread {\n        MyThread() {\n          start();\n        }\n      }\n"
        },
        {
          "shortName": "DoubleCheckedLocking",
          "displayName": "Double-checked locking",
          "enabled": true,
          "description": "Reports [double-checked locking](https://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html).\n\n\nDouble-checked locking tries to initialize a field on demand and in a thread-safe manner while avoiding the cost of synchronization.\nUnfortunately it is not thread-safe when used on a field that is not declared `volatile`.\nWhen using Java 1.4 or earlier, double-checked locking doesn't work even with `volatile` fields.\nRead the article linked above for the detailed explanation of the problem.\n\n\nExample of an incorrect double-checked locking:\n\n\n      class Foo {\n        private Helper helper = null;\n        public Helper getHelper() {\n          if (helper == null)\n            synchronized(this) {\n              if (helper == null) helper = new Helper();\n            }\n            return helper;\n          }\n        }\n        // other functions and members...\n      }\n"
        },
        {
          "shortName": "ThreadLocalNotStaticFinal",
          "displayName": "'ThreadLocal' field not declared 'static final'",
          "enabled": false,
          "description": "Reports fields of type `java.lang.ThreadLocal` that are not declared `static final`.\n\n\nIn the most common case, a `java.lang.ThreadLocal` instance associates state with a thread.\nA non-static non-final `java.lang.ThreadLocal` field associates state with an instance-thread combination.\nThis is usually unnecessary and quite often is a bug that can cause memory leaks and incorrect behavior.\n\n\nA quick-fix is suggested to make the field `static final`.\n\n\n**Example:**\n\n\n      private ThreadLocal tl = ThreadLocal.withInitial(() -> Boolean.TRUE);\n"
        },
        {
          "shortName": "ConditionSignal",
          "displayName": "Call to 'signal()' instead of 'signalAll()'",
          "enabled": false,
          "description": "Reports calls to `java.util.concurrent.locks.Condition.signal()`. While occasionally useful, in almost all cases `signalAll()` is a better and safer choice."
        },
        {
          "shortName": "CallToNativeMethodWhileLocked",
          "displayName": "Call to a 'native' method while locked",
          "enabled": false,
          "description": "Reports calls `native` methods within a `synchronized` block or method.\n\n\nWhen possible, it's better to keep calls to `native` methods out of the synchronized context\nbecause such calls cause an expensive context switch and may lead to performance issues.\n\n**Example:**\n\n\n      native void nativeMethod();\n\n      void example(){\n        synchronized (lock){\n          nativeMethod();//warning\n        }\n      }\n"
        },
        {
          "shortName": "WaitNotInLoop",
          "displayName": "'wait()' not called in loop",
          "enabled": true,
          "description": "Reports calls to `wait()` that are not made inside a loop.\n\n\n`wait()` is normally used to suspend a thread until some condition becomes true.\nAs the thread could have been waken up for a different reason,\nthe condition should be checked after the `wait()` call returns.\nA loop is a simple way to achieve this.\n\n**Example:**\n\n\n      class BoundedCounter {\n        private int count;\n        synchronized void inc() throws InterruptedException {\n          if (count >= 10) wait();\n          ++count;\n        }\n      }\n\nGood code should look like this:\n\n\n      class BoundedCounter {\n        private int count;\n        synchronized void inc() throws InterruptedException {\n          while (count >= 10) wait();\n          ++count;\n        }\n      }\n"
        },
        {
          "shortName": "SafeLock",
          "displayName": "Lock acquired but not safely unlocked",
          "enabled": false,
          "description": "Reports `java.util.concurrent.locks.Lock` resources that are not acquired in front of a `try` block or not unlocked in the corresponding `finally` block. Such resources may be inadvertently leaked if an exception is thrown before the resource is closed.\n\n**Example:**\n\n\n      lock.lock(); // will be reported since the 'finally' block is missing\n      try {\n        doSmthWithLock();\n      } catch (IOException e) {\n        throw new UncheckedIOException(e);\n      }\n      lock.unlock();\n"
        },
        {
          "shortName": "NakedNotify",
          "displayName": "'notify()' or 'notifyAll()' without corresponding state change",
          "enabled": false,
          "description": "Reports `Object.notify()` or `Object.notifyAll()` being called without any detectable state change occurring.\n\n\nNormally, `Object.notify()` and `Object.notifyAll()` are used to inform other threads that a state change has\noccurred. That state change should occur in a synchronized context that contains the `Object.notify()` or\n`Object.notifyAll()` call, and prior to the call. While not having such a state change isn't necessarily incorrect, it is\ncertainly worth examining.\n\n**Example:**\n\n\n      synchronized (this) {\n        notify();\n      }\n      // no state change\n      synchronized (this) {\n        notify(); // this notify might be redundant\n      }\n"
        },
        {
          "shortName": "EmptySynchronizedStatement",
          "displayName": "Empty 'synchronized' statement",
          "enabled": true,
          "description": "Reports `synchronized` statements with empty bodies.\n\n\nEmpty `synchronized` statements are sometimes used to wait for other threads to\nrelease a particular resource. However, there is no guarantee that the same resource\nwon't be acquired again right after the empty `synchronized` statement finishes.\nFor proper synchronization, the resource should be utilized inside the `synchronized` block.\n\n\nAlso, an empty `synchronized` block may appear after a refactoring\nwhen redundant code was removed. In this case, the `synchronized` block\nitself will be redundant and should be removed as well.\n\nExample:\n\n\n      synchronized(lock) {}\n\n\nA quick-fix is suggested to remove the empty synchronized statement.\n\n\nThis inspection is disabled in JSP files."
        },
        {
          "shortName": "SharedThreadLocalRandom",
          "displayName": "'ThreadLocalRandom' instance might be shared",
          "enabled": false,
          "description": "Reports `java.util.concurrent.ThreadLocalRandom` instances which might be shared between threads.\n\n\nA `ThreadLocalRandom` should not be shared between threads because that is not thread-safe.\nThe inspection reports instances that are assigned to a field used as a method argument,\nor assigned to a local variable and used in anonymous or nested classes as they might get shared between threads.\n\n\nUsages of `ThreadLocalRandom` should typically look like `ThreadLocalRandom.current().nextInt(...)`\n(or `nextDouble(...)` etc.).\nWhen all usages are in this form, `ThreadLocalRandom` instances cannot be used accidentally by multiple threads.\n\n**Example:**\n\n\n        class Main {\n          void printRandomNumbersAsync() {\n            ThreadLocalRandom random = ThreadLocalRandom.current();\n            CompletableFuture.supplyAsync(() -> generateNumbers(random))\n              .thenAccept(numbers -> System.out.println(Arrays.toString(numbers)));\n          }\n\n          private int[] generateNumbers(Random random) {\n            return random.ints(1000, 0, 100).toArray();\n          }\n        }\n      \n\nUse the options to list methods that are safe to be passed to `ThreadLocalRandom` instances as an argument.\nIt's possible to use regular expressions for method names."
        },
        {
          "shortName": "NonAtomicOperationOnVolatileField",
          "displayName": "Non-atomic operation on 'volatile' field",
          "enabled": true,
          "description": "Reports non-atomic operations on volatile fields.\n\n\nAn example of a non-atomic operation is updating the field using the increment operator.\nAs the operation involves read and write, and other modifications may happen in between, data may become corrupted.\nThe operation can be made atomic by surrounding it with a `synchronized` block or\nusing one of the classes from the `java.util.concurrent.atomic` package.\n\n**Example:**\n\n\n      private volatile int v = 1;\n\n      void foo() {\n        v = 2 * v;\n      }\n"
        },
        {
          "shortName": "ObjectNotify",
          "displayName": "Call to 'notify()' instead of 'notifyAll()'",
          "enabled": true,
          "description": "Reports calls to `Object.notify()`. While occasionally useful, in almost all cases `Object.notifyAll()` is a better choice because calling `Object.notify()` may lead to deadlocks. See Doug Lea's *Concurrent Programming in Java* for a discussion."
        },
        {
          "shortName": "UnconditionalWait",
          "displayName": "Unconditional 'wait()' call",
          "enabled": false,
          "description": "Reports `wait()` being called unconditionally within a synchronized context.\n\n\nNormally, `wait()` is used to block a thread until some condition is true. If\n`wait()` is called unconditionally, it often indicates that the condition was\nchecked before a lock was acquired. In that case a data race may occur, with the condition\nbecoming true between the time it was checked and the time the lock was acquired.\n\n\nWhile constructs found by this inspection are not necessarily incorrect, they are certainly worth examining.\n\n**Example:**\n\n\n      class Bar {\n          void foo() throws InterruptedException {\n              synchronized (this) {\n                  wait(); // warning\n              }\n          }\n      }\n"
        },
        {
          "shortName": "WaitOrAwaitWithoutTimeout",
          "displayName": "'wait()' or 'await()' without timeout",
          "enabled": false,
          "description": "Reports calls to `Object.wait()` or `Condition.await()` without specifying a timeout.\n\n\nSuch calls may be dangerous in high-availability programs, as failures in one\ncomponent may result in blockages of the waiting component\nif `notify()`/`notifyAll()`\nor `signal()`/`signalAll()` never get called.\n\n**Example:**\n\n\n      void foo(Object bar) throws InterruptedException {\n        bar.wait();\n      }\n"
        },
        {
          "shortName": "ThreadPriority",
          "displayName": "Call to 'Thread.setPriority()'",
          "enabled": false,
          "description": "Reports calls to `Thread.setPriority()`. Modifying priorities of threads is an inherently non-portable operation, as no guarantees are given in the Java specification of how priorities are used in scheduling threads, or even whether they are used at all."
        },
        {
          "shortName": "AccessToStaticFieldLockedOnInstance",
          "displayName": "Access to 'static' field locked on instance data",
          "enabled": false,
          "description": "Reports access to non-constant static fields that are locked on either `this` or an instance field of `this`.\n\n\nLocking a static field on instance data does not prevent the field from being\nmodified by other instances, and thus may result in unexpected race conditions.\n\n**Example:**\n\n\n      static String test;\n      public void foo() {\n          synchronized (this) {\n              System.out.println(test); // warning\n          }\n      }\n\n\nThere is a quick-fix that allows ignoring static fields of specific types.\nYou can manage those ignored types in the inspection options.\n\n\nUse the inspection options to specify which classes used for static fields should be ignored."
        },
        {
          "shortName": "NestedSynchronizedStatement",
          "displayName": "Nested 'synchronized' statement",
          "enabled": true,
          "description": "Reports nested `synchronized` statements. It is recommended to avoid nested synchronization if possible, because in some cases it may lead to a deadlock.\n\n**Example:**\n\n\n      synchronized (lockA){\n        //thread 1 is waiting for lockB\n        synchronized (lockB){ //warning\n        }\n      }\n      ...\n      synchronized (lockB) {\n        //thread 2 is waiting for lockA\n        synchronized (lockA) { //warning\n        }\n      }\n"
        },
        {
          "shortName": "WaitWithoutCorrespondingNotify",
          "displayName": "'wait()' without corresponding 'notify()'",
          "enabled": false,
          "description": "Reports calls to `Object.wait()`, for which no call to the corresponding `Object.notify()` or `Object.notifyAll()` can be found.\n\nThis inspection only reports calls with qualifiers referencing fields of the current class.\n\n**Example:**\n\n\n      public class Foo {\n        public Object foo = new Object();\n\n        void bar() throws InterruptedException {\n          this.foo.wait();\n        }\n      }\n"
        },
        {
          "shortName": "SynchronizationOnGetClass",
          "displayName": "Synchronization on 'getClass()'",
          "enabled": true,
          "description": "Reports synchronization on a call to `getClass()`.\n\n\nIf the class containing the synchronization is subclassed, the subclass\nwill\nsynchronize on a different class object. Usually the call to `getClass()` can be replaced with a class literal expression, for\nexample `String.class`. An even better solution is synchronizing on a `private static final` lock object, access to\nwhich can be completely controlled.\n\n**Example:**\n\n     synchronized(getClass()) {}\n"
        },
        {
          "shortName": "SystemRunFinalizersOnExit",
          "displayName": "Call to 'System.runFinalizersOnExit()'",
          "enabled": true,
          "description": "Reports calls to `System.runFinalizersOnExit()`.\n\n\nThis call is one of the most dangerous in the Java language. It is inherently non-thread-safe,\nmay result in data corruption, a deadlock, and may affect parts of the program far removed from its call point.\nIt is deprecated and was removed in JDK 11, and its use is strongly discouraged.\n\nThis inspection only reports if the language level of the project or module is 10 or lower."
        },
        {
          "shortName": "PublicFieldAccessedInSynchronizedContext",
          "displayName": "Non-private field accessed in 'synchronized' context",
          "enabled": true,
          "description": "Reports non-`final`, non-`private` fields that are accessed in a synchronized context.\n\n\nA non-`private` field cannot be guaranteed to always be accessed in a synchronized manner, and such \"partially synchronized\"\naccess may result in unexpectedly inconsistent data structures.\n\n**Example:**\n\n\n      class Bar {\n        public String field1;\n      }\n      public Bar myBar;\n\n      synchronized public void sample() {\n       myBar.field1 = \"bar\";\n      }\n"
        },
        {
          "shortName": "WaitWhileHoldingTwoLocks",
          "displayName": "'wait()' while holding two locks",
          "enabled": true,
          "description": "Reports calls to `wait()` methods that may occur while the current thread is holding two locks.\n\n\nSince calling `wait()` only releases one lock on its target,\nwaiting with two locks held can easily lead to a deadlock.\n\n**Example:**\n\n\n      synchronized (lockA) {\n        synchronized (lockB) {\n          lockB.wait(); //warning\n          //thread A is stuck here holding lockA\n        }\n      }\n\n      synchronized (lockA) { //thread B can't enter the block and release thread A\n        lockB.notify();\n      }\n"
        },
        {
          "shortName": "WhileLoopSpinsOnField",
          "displayName": "'while' loop spins on field",
          "enabled": true,
          "description": "Reports `while` loops that spin on the value of a non-`volatile` field, waiting for it to be changed by another thread.\n\n\nIn addition to being potentially extremely CPU intensive when little work is done inside the loop, such\nloops are likely to have different semantics from what was intended. The Java Memory Model allows such loop to never complete even\nif another thread changes the field's value.\n\n**Example:**\n\n\n      class SpinsOnField {\n        boolean ready = false;\n\n        void run() {\n          while (!ready) { // the loop may never complete even after markAsReady call\n                           // from the other thread\n          }\n          // do some work\n        }\n\n        void markAsReady() {\n          ready = true;\n        }\n      }\n\n\nAdditionally, since Java 9 it's recommended to call `Thread.onSpinWait()` inside a spin loop\non a `volatile` field, which may significantly improve performance on some hardware.\n\n\nUse the inspection options to only report empty `while` loops."
        },
        {
          "shortName": "SynchronizeOnLock",
          "displayName": "Synchronization on a 'Lock' object",
          "enabled": false,
          "description": "Reports `synchronized` blocks that lock on an instance of `java.util.concurrent.locks.Lock`. Such synchronization is almost certainly unintended, and appropriate versions of `.lock()` and `.unlock()` should be used instead.\n\n**Example:**\n\n\n      final ReentrantLock lock = new ReentrantLock();\n\n      public void foo() {\n        synchronized (lock) {}\n      }\n"
        },
        {
          "shortName": "AtomicFieldUpdaterNotStaticFinal",
          "displayName": "'AtomicFieldUpdater' field not declared 'static final'",
          "enabled": true,
          "description": "Reports fields of types:\n\n* `java.util.concurrent.atomic.AtomicLongFieldUpdater`\n* `java.util.concurrent.atomic.AtomicIntegerFieldUpdater`\n* `java.util.concurrent.atomic.AtomicReferenceFieldUpdater`\n\nthat are not `static final`. Because only one atomic field updater is needed for updating a `volatile` field in all instances of a class, it can almost always be `static`.\n\nMaking the updater `final` allows the JVM to optimize access for improved performance.\n\n**Example:**\n\n\n      class Main {\n        private volatile int id;\n        private AtomicIntegerFieldUpdater<Main> idFieldUpdater = AtomicIntegerFieldUpdater.newUpdater(Main.class, \"id\");\n      }\n\nAfter the quick-fix is applied:\n\n\n      class Main {\n        private volatile int id;\n        private static final AtomicIntegerFieldUpdater<Main> idFieldUpdater = AtomicIntegerFieldUpdater.newUpdater(Main.class, \"id\");\n      }\n"
        },
        {
          "shortName": "NotifyCalledOnCondition",
          "displayName": "'notify()' or 'notifyAll()' called on 'java.util.concurrent.locks.Condition' object",
          "enabled": false,
          "description": "Reports calls to `notify()` or `notifyAll()` made on `java.util.concurrent.locks.Condition` object.\n\n\nThis is probably a programming error, and some variant of the `signal()` or\n`signalAll()` method was intended instead, otherwise `IllegalMonitorStateException` may occur.\n\n**Example:**\n\n\n      class C {\n        final Lock l = new ReentrantLock();\n        final Condition c = l.newCondition();\n\n        void release() {\n          l.lock();\n          try {\n            c.notifyAll(); // probably 'signalAll()' was intended here\n          } finally {\n            l.unlock();\n          }\n        }\n      }\n"
        },
        {
          "shortName": "SynchronizedOnLiteralObject",
          "displayName": "Synchronization on an object initialized with a literal",
          "enabled": false,
          "description": "Reports `synchronized` blocks that lock on an object initialized with a literal.\n\n\nString literals are interned and `Character`, `Boolean` and `Number` literals can be allocated from a cache.\nBecause of this, it is possible that some other part of the system, which uses an object initialized with the same literal, is actually\nholding a reference to the exact same object. This can create unexpected dead-lock situations, if the lock object was thought to be private.\n\n**Example:**\n\n\n      class Main {\n        final String mutex = \"Mutex\";\n        void method() {\n          synchronized (mutex) {\n          }\n        }\n      }\n\n\nUse the **Warn on all possible literals** option to report any synchronization on\n`String`, `Character`, `Boolean` and `Number` objects."
        },
        {
          "shortName": "AccessToNonThreadSafeStaticFieldFromInstance",
          "displayName": "Non-thread-safe 'static' field access",
          "enabled": false,
          "description": "Reports access to `static` fields that are of a non-thread-safe type.\n\n\nWhen a `static` field is accessed from an instance method or a non-synchronized block,\nmultiple threads can access that field.\nThis can lead to unspecified side effects, like exceptions and incorrect results.\n\n**Example:**\n\n\n      class Sample {\n        private static final SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd\");\n        String method() {\n          return df.format(\"\");\n        }\n      }\n\n\nYou can specify which types should be considered not thread-safe.\nOnly fields with these exact types or initialized with these exact types are reported,\nbecause there may exist thread-safe subclasses of these types."
        },
        {
          "shortName": "AwaitNotInLoop",
          "displayName": "'await()' not called in loop",
          "enabled": false,
          "description": "Reports `java.util.concurrent.locks.Condition.await()` not being called inside a loop.\n\n\n`await()` and related methods are normally used to suspend a thread until some condition becomes true.\nAs the thread could have been woken up for a different reason,\nthe condition should be checked after the `await()` call returns.\nA loop is a simple way to achieve this.\n\n**Example:**\n\n\n      void acquire(Condition released) throws InterruptedException {\n        released.await();\n      }\n\nGood code should look like this:\n\n\n      void acquire(Condition released) throws InterruptedException {\n        while (acquired) {\n          released.await();\n        }\n      }\n"
        },
        {
          "shortName": "SynchronizedMethod",
          "displayName": "'synchronized' method",
          "enabled": false,
          "description": "Reports the `synchronized` modifier on methods.\n\n\nThere are several reasons a `synchronized` modifier on a method may be a bad idea:\n\n1. As little work as possible should be performed under a lock. Therefore it is often better to use a `synchronized` block and keep there only the code that works with shared state.\n2. Synchronization becomes a part of a method's interface. This makes a transition to a different locking mechanism difficult.\n3. Keeping track of what is locking a particular object gets harder.\n4. The DoS (denial-of-service) attack becomes feasible either on purpose or unknowingly when inheriting the method's class.\n\n\nAs an alternative, consider synchronizing on a `private final` lock object, access to which can be completely controlled.\n\nA quick-fix is provided to wrap the method body with `synchronized(this)`.\n\n**Example:**\n\n\n      class Main {\n        public synchronized void fooBar() {\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      class Main {\n        public void fooBar() {\n          synchronized (this) {\n          }\n        }\n      }\n\nYou can configure the following options for this inspection:\n\n1. **Include native methods** - include native methods into the inspection's scope.\n2. **Ignore methods overriding a synchronized method** - do not report methods that override a `synchronized` method."
        },
        {
          "shortName": "SynchronizeOnNonFinalField",
          "displayName": "Synchronization on a non-final field",
          "enabled": true,
          "description": "Reports `synchronized` statement lock expressions that consist of a non-`final` field reference. Such statements are unlikely to have useful semantics, as different threads may acquire different locks even when operating on the same object.\n\n**Example:**\n\n\n      private Object o;\n      public void foo() {\n        synchronized (o) // synchronization on a non-final field\n        { }\n      }\n"
        },
        {
          "shortName": "ThreadWithDefaultRunMethod",
          "displayName": "Instantiating a 'Thread' with default 'run()' method",
          "enabled": true,
          "description": "Reports code that instantiates `Thread` without specifying a `Runnable` parameter or overriding the `run()` method.\n\n\nSuch threads do nothing useful."
        },
        {
          "shortName": "VolatileArrayField",
          "displayName": "Volatile array field",
          "enabled": false,
          "description": "Reports array fields that are declared `volatile`. Such declarations may be confusing because accessing the array itself follows the rules for `volatile` fields, but accessing the array's contents does not.\n\n**Example:**\n\n\n      class Data {\n        private volatile int[] idx = new int[0];\n      }\n\n\nIf such volatile access is needed for array contents, consider using\n`java.util.concurrent.atomic` classes instead:\n\n\n      class Data {\n        private final AtomicIntegerArray idx = new AtomicIntegerArray(new int[0]);\n      }\n"
        },
        {
          "shortName": "SynchronizeOnThis",
          "displayName": "Synchronization on 'this'",
          "enabled": true,
          "description": "Reports synchronization on `this` or `class` expressions. The reported constructs include `synchronized` blocks and calls to `wait()`, `notify()` or `notifyAll()`.\n\nThere are several reasons synchronization on `this` or `class` expressions may be a bad idea:\n\n1. it makes synchronization a part of the external interface of the class, which makes a future change to a different locking mechanism difficult,\n2. it becomes hard to track just who is locking on a given object,\n3. it makes a denial-of-service attack possible, either on purpose or it can happen easily by accident when subclassing.\n\nAs an alternative, consider synchronizing on a `private final` lock object, access to which can be completely controlled.\n\n**Example:**\n\n\n      public void print() {\n        synchronized(this) { // warning: Lock operations on 'this' may have unforeseen side-effects\n          System.out.println(\"synchronized\");\n        }\n      }\n      \n"
        },
        {
          "shortName": "NotifyWithoutCorrespondingWait",
          "displayName": "'notify()' without corresponding 'wait()'",
          "enabled": false,
          "description": "Reports calls to `Object.notify()` or `Object.notifyAll()` for which no call to a corresponding `Object.wait()` can be found.\n\nOnly calls that target fields of the current class are reported by this inspection.\n\n**Example:**\n\n\n      synchronized (synList) {\n        synList.notify(); //synList.wait() is never called\n      }\n"
        },
        {
          "shortName": "SynchronizationOnStaticField",
          "displayName": "Synchronization on 'static' field",
          "enabled": false,
          "description": "Reports synchronization on `static` fields. While not strictly incorrect, synchronization on `static` fields can lead to bad performance because of contention."
        },
        {
          "shortName": "AwaitWithoutCorrespondingSignal",
          "displayName": "'await()' without corresponding 'signal()'",
          "enabled": false,
          "description": "Reports calls to `Condition.await()`, for which no call to a corresponding `Condition.signal()` or `Condition.signalAll()` can be found.\n\n\nCalling `Condition.await()` in a thread without corresponding `Condition.signal()` may cause the thread\nto become disabled until it is interrupted or \"spurious wakeup\" occurs.\n\nOnly calls that target fields of the current class are reported by this inspection.\n\n**Example:**\n\n\n      class Queue {\n        private final Condition isEmpty = ...;\n\n        void add(Object elem) {\n          // ...\n          // isEmpty.signal();\n          // ...\n        }\n\n        void remove(Object elem) throws InterruptedException {\n          // ...\n          isEmpty.await(); // 'await()' doesn't contain corresponding 'signal()'/'signalAll()' call\n          // ...\n        }\n      }\n"
        },
        {
          "shortName": "BusyWait",
          "displayName": "Busy wait",
          "enabled": true,
          "description": "Reports calls to `java.lang.Thread.sleep()` that occur inside loops.\n\nSuch calls\nare indicative of \"busy-waiting\". Busy-waiting is often inefficient, and may result in unexpected deadlocks\nas busy-waiting threads do not release locked resources.\n\n**Example:**\n\n\n      class X {\n         volatile int x;\n         public void waitX() throws Exception {\n          while (x > 0) {\n            Thread.sleep(10);//warning: Call to 'Thread.sleep()' in a loop, probably busy-waiting\n          }\n        }\n      }\n"
        },
        {
          "shortName": "SleepWhileHoldingLock",
          "displayName": "Call to 'Thread.sleep()' while synchronized",
          "enabled": false,
          "description": "Reports calls to `java.lang.Thread.sleep()` methods that occur within a `synchronized` block or method.\n\n\n`sleep()` within a\n`synchronized` block may result in decreased performance, poor scalability, and possibly\neven deadlocking. Consider using `wait()` instead,\nas it will release the lock held.\n\n**Example:**\n\n\n      synchronized (lock) {\n        Thread.sleep(100);\n      }\n"
        },
        {
          "shortName": "GroovyThreadStopSuspendResume",
          "displayName": "Call to Thread.stop(), Thread.suspend(), or Thread.resume()",
          "enabled": false,
          "description": "Reports calls to `Thread.stop()`,`Thread.suspend()`, or `Thread.resume()`.\n\n\nThese calls are inherently prone to data corruption and deadlock, and their use is strongly\ndiscouraged."
        },
        {
          "shortName": "GroovyDoubleCheckedLocking",
          "displayName": "Double-checked locking",
          "enabled": false,
          "description": "Reports double-checked locking.\n\n\nDouble-checked locking tries to initialize a field on demand and in a thread-safe manner, while avoiding the cost of synchronization.\nUnfortunately it is not thread safe when used on a field that is not declared `volatile`.\nWhen using Java 1.4 or older, double-checked locking doesn't work even with a `volatile` field.\nSee [the article](https://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html) for an explanation of the problem.\n\n**Example:**\n\n\n      class Foo {\n          private Helper helper = null\n\n          Helper getHelper() {\n              if (helper == null)\n                  synchronized(this) {\n                      if (helper == null) {\n                          helper = new Helper()\n                      }\n                  }\n              }\n              return helper;\n          }\n      }\n"
        },
        {
          "shortName": "GroovySynchronizedMethod",
          "displayName": "Synchronized method",
          "enabled": false,
          "description": "Reports the `synchronized` modifier on methods.\n\n\nSome coding standards\nprohibit the use of the `synchronized` modifier, in favor of `synchronized` statements."
        },
        {
          "shortName": "GroovyUnconditionalWait",
          "displayName": "Unconditional 'wait' call",
          "enabled": false,
          "description": "Reports **wait()**\nbeing called unconditionally within a synchronized context.\nNormally, **wait()** is\nused to block a thread until some condition is true. If **wait()**\nis called unconditionally, that often indicates that the condition was checked before a lock was\nacquired. In that case, a data race may occur, with the condition becoming true between the time\nit was checked and the time the lock was acquired. While constructs found by this inspection\nare not necessarily incorrect, they are certainly worth examining."
        },
        {
          "shortName": "GroovyUnsynchronizedMethodOverridesSynchronizedMethod",
          "displayName": "Unsynchronized method overrides synchronized method",
          "enabled": false,
          "description": "Reports non-**synchronized** methods overriding **synchronized** methods.\n\n**Example:**\n\n\n      abstract class Base {\n          synchronized void foo() {\n              // ...\n          }\n      }\n      class Derived extends Base {\n          @Override\n          void foo() {\n              super.foo()\n                // ...\n            }\n        }\n\nHere the non-synchronized method `foo()` in class `Bar` overrides synchronized method."
        },
        {
          "shortName": "GroovySynchronizationOnThis",
          "displayName": "Synchronization on 'this'",
          "enabled": false,
          "description": "Reports synchronization which uses `this` as its lock expression.\n\n\nConstructs reported include `synchronized`\nblocks which lock `this`, and calls to `wait()`\n`notify()` or `notifyAll()` which target `wait()`.\nSuch constructs, like synchronized methods, make it hard to track just who is locking on a given\nobject, and make possible \"denial of service\" attacks on objects. As an alternative, consider\nlocking on a private instance variable, access to which can be completely controlled."
        },
        {
          "shortName": "GroovyNestedSynchronizedStatement",
          "displayName": "Nested 'synchronized' statement",
          "enabled": false,
          "description": "Reports nested `synchronized` statements.\n\n\nNested `synchronized` statements\nare either redundant (if the lock objects are identical) or prone to deadlock."
        },
        {
          "shortName": "GroovyWaitCallNotInLoop",
          "displayName": "'wait()' not in loop",
          "enabled": false,
          "description": "Reports calls to `wait()` not made inside a loop.\n\n`wait()` is normally used to suspend a thread until a condition is true, and that condition should be checked after the `wait()`\nreturns. A loop is the clearest way to achieve this."
        },
        {
          "shortName": "GroovyAccessToStaticFieldLockedOnInstance",
          "displayName": "Access to static field locked on instance data",
          "enabled": false,
          "description": "Reports accesses to a non-constant static field which is locked on either `this` or an instance field of `this`.\n\n\nLocking a static field on instance data does not prevent the field from being\nmodified by other instances, and thus may result in surprising race conditions.\n\n**Example:**\n\n\n      static String s;\n      def foo() {\n          synchronized (this) {\n              System.out.println(s); // warning\n          }\n      }\n"
        },
        {
          "shortName": "GroovyWaitWhileNotSynchronized",
          "displayName": "'wait()' while not synced",
          "enabled": false,
          "description": "Reports calls to `wait()` not made inside a corresponding synchronized\nstatement or synchronized method.\n\nCalling `wait()` on an object\nwithout holding a lock on that object will result in an `IllegalMonitorStateException` being thrown.\nSuch a construct is not necessarily an error, as the necessary lock may be acquired before\nthe containing method is called, but its worth looking at."
        },
        {
          "shortName": "GroovySystemRunFinalizersOnExit",
          "displayName": "Call to System.runFinalizersOnExit()",
          "enabled": false,
          "description": "Reports calls to `System.runFinalizersOnExit()`.\n\n\nThis call is one of the most dangerous in the Java language. It is inherently non-thread-safe,\nmay result in data corruption, deadlock, and may affect parts of the program far removed from its call point.\nIt is deprecated, and its use is strongly discouraged."
        },
        {
          "shortName": "GroovyWhileLoopSpinsOnField",
          "displayName": "While loop spins on field",
          "enabled": false,
          "description": "Reports `while` loops, which spin on the\nvalue of a non-`volatile` field, waiting for it to be changed by another thread.\n\n\nIn addition to being potentially extremely CPU intensive when little work is done inside the loop, such\nloops likely have different semantics than intended. The Java Memory Model allows that loop to never complete even\nif another thread changes the field's value.\n\n**Example:**\n\n\n      class SpinsOnField {\n          boolean ready = false;\n\n          void run() {\n              // the loop may never complete even after\n              // markAsReady call from the other thread\n              while (!ready) {\n              }\n              // do some work\n          }\n\n          void markAsReady() {\n              ready = true;\n          }\n      }\n\n\nAdditionally since Java 9, calling `Thread.onSpinWait()` inside spin loop\non a `volatile` field is recommended, which may significantly improve performance on some hardware.\n\n\nUse the checkbox below to have this inspection report only empty `while` loops."
        },
        {
          "shortName": "GroovyEmptySyncBlock",
          "displayName": "Empty 'synchronized' block",
          "enabled": false,
          "description": "Reports `synchronized` statements with empty bodies. While theoretically this may be the semantics intended, this construction is confusing, and often the result of a typo.\n\n**Example:**\n\n\n    synchronized(lock) {\n    }\n\n"
        },
        {
          "shortName": "GroovyPublicFieldAccessedInSynchronizedContext",
          "displayName": "Non-private field accessed in synchronized context",
          "enabled": false,
          "description": "Reports non-`final`, non-`private` fields which are accessed in a synchronized context.\n\n\nA non-private field cannot be guaranteed to always be accessed in a synchronized manner, and such \"partially synchronized\"\naccess may result in unexpectedly inconsistent data structures. Accesses in constructors an initializers are ignored\nfor purposes of this inspection."
        },
        {
          "shortName": "GroovyNotifyWhileNotSynchronized",
          "displayName": "'notify()' or 'notifyAll()' while not synced",
          "enabled": false,
          "description": "Reports calls to `notify()` and `notifyAll()` not within a corresponding synchronized statement or synchronized method.\n\n\nCalling these methods on an object\nwithout holding a lock on that object will result in an `IllegalMonitorStateException` being thrown.\nSuch a construct is not necessarily an error, as the necessary lock may be acquired before\nthe containing method is called, but it's worth looking at."
        },
        {
          "shortName": "GroovyBusyWait",
          "displayName": "Busy wait",
          "enabled": false,
          "description": "Reports calls to `java.lang.Thread.sleep()` that occur inside loops.\n\n\nSuch calls are indicative of \"busy-waiting\". Busy-waiting is often inefficient, and may result in unexpected deadlocks\nas busy-waiting threads do not release locked resources."
        },
        {
          "shortName": "GroovySynchronizationOnVariableInitializedWithLiteral",
          "displayName": "Synchronization on variable initialized with literal",
          "enabled": false,
          "description": "Reports synchronized blocks which lock on an object which is initialized with a literal.\n\n\nString literals are interned and `Number` literals can be allocated from a cache. Because of\nthis, it is possible that some other part of the system which uses an object initialized with the same\nliteral, is actually holding a reference to the exact same object. This can create unexpected dead-lock\nsituations, if the string was thought to be private."
        },
        {
          "shortName": "GroovySynchronizationOnNonFinalField",
          "displayName": "Synchronization on non-final field",
          "enabled": false,
          "description": "Reports `synchronized` statements where the lock expression is a non-`final` field.\n\n\nSuch statements are unlikely to have useful semantics, as different\nthreads may be locking on different objects even when operating on the same object."
        }
      ]
    },
    {
      "name": "Internationalization",
      "inspections": [
        {
          "shortName": "CallToSuspiciousStringMethod",
          "displayName": "Call to suspicious 'String' method",
          "enabled": false,
          "description": "Reports calls of:\n\n* `equals()`\n* `equalsIgnoreCase()`\n* `compareTo()`\n* `compareToIgnoreCase()` and\n* `trim()`\n\n\non `String` objects.\nComparison of internationalized strings should probably use a `java.text.Collator` instead.\n`String.trim()` only removes control characters between 0x00 and 0x20.\nThe `String.strip()` method introduced in Java 11 is more Unicode aware and can be used as a replacement."
        },
        {
          "shortName": "StringToUpperWithoutLocale",
          "displayName": "Call to 'String.toUpperCase()' or 'toLowerCase()' without locale",
          "enabled": false,
          "description": "Reports `toUpperCase()` or `toLowerCase()` calls on `String` objects that do not specify a `java.util.Locale`. In these cases the default system locale is used, which can cause problems in an internationalized environment.\n\n\nFor example the code `\"i\".toUpperCase().equals(\"I\")` returns `false` in the Turkish and Azerbaijani locales, where\nthe dotted and dotless 'i' are separate letters. Calling `toUpperCase()` on an English string containing an 'i', when running\nin a Turkish locale, will return incorrect results. Alternatively, when dealing with strings that should be treated as locale-independent,\nlike HTML tags, this can lead to errors."
        },
        {
          "shortName": "AbsoluteAlignmentInUserInterface",
          "displayName": "Absolute alignment in AWT/Swing code",
          "enabled": false,
          "description": "Reports usages of absolute alignment constants from AWT and Swing. Internationalized applications use relative alignment because it respects the locale component orientation settings.\n\n**Example:**\n\n\n      JPanel panel = new JPanel(new BorderLayout(2, 2));\n      JLabel label = new JLabel(\"Hello World\");\n      panel.add(label, BorderLayout.NORTH);\n\nAfter the quick-fix is applied:\n\n\n      JPanel panel = new JPanel(new BorderLayout(2, 2));\n      JLabel label = new JLabel(\"Hello World\");\n      panel.add(label, BorderLayout.PAGE_START);\n"
        },
        {
          "shortName": "SimpleDateFormatWithoutLocale",
          "displayName": "'SimpleDateFormat' without locale",
          "enabled": false,
          "description": "Reports instantiations of `java.util.SimpleDateFormat` that do not specify `java.util.Locale`. These calls might be incorrect in an internationalized environment.\n\n`Example:`\n\n    new SimpleDateFormat(\"yyyy\");\n"
        },
        {
          "shortName": "TimeToString",
          "displayName": "Call to 'Time.toString()'",
          "enabled": false,
          "description": "Reports `toString()` calls on `java.sql.Time` objects. Such calls are usually incorrect in an internationalized environment."
        },
        {
          "shortName": "DateToString",
          "displayName": "Call to 'Date.toString()'",
          "enabled": false,
          "description": "Reports `toString()` calls on `java.util.Date` objects. Such calls are usually incorrect in an internationalized environment."
        },
        {
          "shortName": "ImplicitDefaultCharsetUsage",
          "displayName": "Implicit platform default charset",
          "enabled": false,
          "description": "Reports method and constructor calls that implicitly use the platform default charset. These calls can produce different results on systems that use different default charsets. It might result in unexpected behaviour.\n\n**Example:**\n\n    void foo(byte[] bytes) {\n      String s = new String(bytes);\n    }\n\nYou can use a quick-fix that specifies the explicit UTF-8 charset if the corresponding overloaded method is available.\nAfter the quick-fix is applied:\n\n    void foo(byte[] bytes) {\n      String s = new String(bytes, StandardCharsets.UTF_8);\n    }\n"
        },
        {
          "shortName": "UnnecessaryUnicodeEscape",
          "displayName": "Unnecessary unicode escape sequence",
          "enabled": false,
          "description": "Reports unnecessary unicode escape sequences. For example, when the file encoding can handle the character without escaping it. Unicode control characters are not reported by this inspection (except for a line feed and a tab).\n\n**Example:**\n\n    String s = \"\\u0062\";\n"
        },
        {
          "shortName": "StringTokenizer",
          "displayName": "Use of 'StringTokenizer'",
          "enabled": false,
          "description": "Reports usages of the `StringTokenizer` class. Excessive use of `StringTokenizer` is incorrect in an internationalized environment."
        },
        {
          "shortName": "NumericToString",
          "displayName": "Call to 'Number.toString()'",
          "enabled": false,
          "description": "Reports `toString()` calls on objects of a class extending `Number`. Such calls are usually incorrect in an internationalized environment and some locale specific formatting should be used instead.\n\n**Example:**\n\n\n      void print(Double d) {\n        System.out.println(d.toString());\n      }\n\nA possible way to fix this problem could be:\n\n\n      void print(Double d) {\n        System.out.printf(\"%f%n\", d);\n      }\n\nThis formats the number using the default locale which is set during the startup of the JVM and is based on the host environment."
        },
        {
          "shortName": "CharacterComparison",
          "displayName": "Character comparison",
          "enabled": false,
          "description": "Reports ordinal comparisons of `char` values. In an internationalized environment, such comparisons are rarely correct."
        },
        {
          "shortName": "MagicCharacter",
          "displayName": "Magic character",
          "enabled": false,
          "description": "Reports character literals that are used without constant declaration. These characters might result in bad code readability. Also, there might be errors if a character is changed only in one location but not everywhere in code.\n\n**Example:**\n\n    char c = 'c';\n"
        },
        {
          "shortName": "StringConcatenation",
          "displayName": "String concatenation",
          "enabled": false,
          "description": "Reports `String` concatenations. Concatenation might be incorrect in an internationalized environment and could be replaced by usages of `java.text.MessageFormat` or similar classes."
        },
        {
          "shortName": "ConvertToBasicLatin",
          "displayName": "Non-Basic Latin character",
          "enabled": false,
          "description": "Reports non-Basic Latin characters in literals and suggests replacing them with unicode entities.\n\nExample:\n\n\n      //  2021\n      char c = '';\n      String s = \"\";\n\nAfter the quick-fix is applied:\n\n\n      // &copy; 2021\n      char c = '\\u00a9';\n      String s = \"\\u00c1\\u00ee\";\n"
        },
        {
          "shortName": "HardCodedStringLiteral",
          "displayName": "Hardcoded strings",
          "enabled": false,
          "description": "Reports any instances of hardcoded `String` literals.\n\nHardcoded `String` literals are probably errors in an\ninternationalized environment. This inspection won't report empty strings and strings consisting only of whitespaces. A quick-fix is available\nto transform a string literal into a `java.util.ResourceBundle.getString()` method call.\n\nUse inspection's options to further specialize whether this inspection should report strings in:\n\n* Assert statements like in `assert str.equals(\"message\")`\n* Exception constructor calls like in `new Exception(\"message\")`\n* JUnit assert calls like in `assertEquals(str, \"message\")`\n* The only argument to a method returning String like in `getStringByKey(\"key\")`\n* Literals with value of legal and existing class name like `Class.forName(\"java.lang.Object\")`\n* Literals with value of legal and existing property key `bundle.getString(\"authentication.failed\")`"
        },
        {
          "shortName": "DialogTitleCapitalization",
          "displayName": "Incorrect string capitalization",
          "enabled": false,
          "description": "Reports strings in method parameters and return values annotated with `@Nls` and having the capitalization parameter to conform to capitalization rules existing in most platform UI guidelines.\n\n**Example:**\n\n\n      void setTitle(@NlsContexts.DialogTitle String title) {}\n      setTitle(\"This is sentence capitalization but should be title\"); \n\nAfter the quick-fix is applied:\n\n\n      setTitle(\"This Is Sentence Capitalization but Should Be Title\"); \n"
        },
        {
          "shortName": "DuplicateStringLiteralInspection",
          "displayName": "Duplicate string literal",
          "enabled": false,
          "description": "Reports all string literals that are replicated unchanged throughout the project.\n\nExample:\n\n\n      class C1 { String CONST1 = \"duplicate string\"; }\n      class C2 { String CONST2 = \"duplicate string\"; }\n\nConfigure the inspection:\n\n* Use the **Min string length** field to set the minimal string length required to detect duplicates.\n* Use the **Ignore @PropertyKey expressions** option to ignore strings passed as arguments to methods annotated with `org.jetbrains.annotations.PropertyKey`."
        },
        {
          "shortName": "NonAsciiCharacters",
          "displayName": "Non-ASCII characters",
          "enabled": false,
          "description": "Reports code elements that use non-ASCII symbols in an unusual context.\n\nExample:\n\n* Non-ASCII characters used in identifiers, strings, or comments.\n* Identifiers written in different languages, such as `my`****`ollection` with the letter **C** written in Cyrillic.\n* Comments or strings containing Unicode symbols, such as long dashes and arrows."
        },
        {
          "shortName": "LossyEncoding",
          "displayName": "Lossy encoding",
          "enabled": false,
          "description": "Reports characters that cannot be displayed because of the current document encoding.\n\nExamples:\n\n* If you type international characters in a document with the **US-ASCII** charset, some characters will be lost on save.\n* If you load a **UTF-8** -encoded file using the **ISO-8859-1** one-byte charset, some characters will be displayed incorrectly.\n\nYou can fix this by changing the file encoding\neither by specifying the encoding directly in the file, e.g. by editing `encoding=` attribute in the XML prolog of XML file,\nor by changing the corresponding options in **Settings \\| Editor \\| File Encodings**."
        }
      ]
    },
    {
      "name": "Performance",
      "inspections": [
        {
          "shortName": "KeySetIterationMayUseEntrySet",
          "displayName": "Iteration over 'keySet()' can be optimized",
          "enabled": false,
          "description": "Reports iterations over the `keySet()` of a `java.util.Map` instance, where the iterated keys are used to retrieve the values from the map.\n\n\nSuch iteration may be more efficient when replaced with an iteration over the\n`entrySet()` or `values()` (if the key is not actually used).\n\n\nSimilarly, `keySet().forEach(key -> ...)`\ncan be replaced with `forEach((key, value) -> ...)` if values are retrieved\ninside a lambda.\n\n**Example:**\n\n\n      for (Object key : map.keySet()) {\n       Object val = map.get(key);\n      }\n\nAfter the quick-fix is applied:\n\n\n      for (Object val : map.values()) {}\n"
        },
        {
          "shortName": "StringConcatenationInLoops",
          "displayName": "String concatenation in loop",
          "enabled": true,
          "description": "Reports String concatenation in loops.\n\n\nAs every String concatenation copies the whole\nstring, usually it is preferable to replace it with explicit calls to `StringBuilder.append()` or\n`StringBuffer.append()`.\n\n**Example:**\n\n\n      String str = \"\";\n      for(int i=0; i<10; i++) {\n        str += i;\n      }\n\nAfter the quick-fix is applied:\n\n\n      String str = \"\";\n      StringBuilder strBuilder = new StringBuilder(str);\n      for(int i = 0; i<10; i++) {\n        strBuilder.append(i);\n      }\n      str = strBuilder.toString();\n\n\nSometimes, the quick-fixes allow you to convert a `String` variable to a `StringBuilder` or\nintroduce a new `StringBuilder`. Be careful if the original code specially handles the `null` value, as the\nreplacement may change semantics. If `null` is possible, null-safe fixes that generate\nnecessary null-checks are suggested. Also, it's not guaranteed that the automatic replacement will always be more performant."
        },
        {
          "shortName": "DynamicRegexReplaceableByCompiledPattern",
          "displayName": "Dynamic regular expression could be replaced by compiled 'Pattern'",
          "enabled": false,
          "description": "Reports calls to the regular expression methods (such as `matches()` or `replace()`) of `java.lang.String` using constants arguments.\n\n\nSuch calls may be profitably replaced with a `private static final Pattern` field\nso that the regular expression does not have to be compiled each time it is used.\n\n**Example:**\n\n\n      text.replace(\"abc\", replacement);\n\nAfter the quick-fix is applied:\n\n\n      private static final Pattern ABC = Pattern.compile(\"abc\", Pattern.LITERAL);\n      ABC.matcher(text).replaceAll(Matcher.quoteReplacement(replacement));\n"
        },
        {
          "shortName": "ManualArrayCopy",
          "displayName": "Manual array copy",
          "enabled": true,
          "description": "Reports manual copying of array contents which can be replaced with `System.arraycopy()`.\n\n**Example:**\n\n\n      for (int i = 0; i < array.length; i++) {\n        newArray[i] = array[i];\n      }\n\nAfter the quick-fix is applied:\n\n\n      System.arraycopy(array, 0, newArray, 0, array.length);\n"
        },
        {
          "shortName": "LengthOneStringInIndexOf",
          "displayName": "Single character string argument in 'String.indexOf()' call",
          "enabled": false,
          "description": "Reports single character strings being used as an argument in `String.indexOf()` and `String.lastIndexOf()` calls.\n\nA quick-fix is suggested to replace such string literals with equivalent character literals, gaining some performance enhancement.\n\n**Example:**\n\n\n      return s.indexOf(\"x\");\n\nAfter the quick-fix is applied:\n\n\n      return s.indexOf('x');\n"
        },
        {
          "shortName": "RandomDoubleForRandomInteger",
          "displayName": "Using 'Random.nextDouble()' to get random integer",
          "enabled": false,
          "description": "Reports calls to `java.util.Random.nextDouble()` that are used to create a positive integer number by multiplying the call by a factor and casting to an integer.\n\n\nFor generating a random positive integer in a range,\n`java.util.Random.nextInt(int)` is simpler and more efficient.\n\n**Example:**\n\n\n      int getRandomInt() {\n        return (int) ((new Random()).nextDouble() * SIZE);\n      }\n      \nAfter the quick-fix is applied:\n\n\n      int getRandomInt() {\n        return (new Random()).nextInt(SIZE);\n      }\n"
        },
        {
          "shortName": "UnnecessaryTemporaryOnConversionFromString",
          "displayName": "Unnecessary temporary object in conversion from 'String'",
          "enabled": true,
          "description": "Reports unnecessary creation of temporary objects when converting from `String` to primitive types.\n\n**Example:**\n\n\n      new Integer(\"3\").intValue()\n\nAfter the quick-fix is applied:\n\n\n      Integer.valueOf(\"3\")\n"
        },
        {
          "shortName": "IOStreamConstructor",
          "displayName": "'InputStream' and 'OutputStream' can be constructed using 'Files' methods",
          "enabled": false,
          "description": "Reports `FileInputStream` or `FileOutputStream` constructors when it is possible to replace them with `Files.newInputStream()` or `Files.newOutputStream()` accordingly.   \nThe streams created using `Files` methods are usually more efficient than those created by stream constructors.\n\nExample:\n\n\n    InputStream is = new BufferedInputStream(new FileInputStream(file));\n\nAfter the quick-fix is applied:\n\n\n    InputStream is = new BufferedInputStream(Files.newInputStream(file.toPath()));\n\nThis inspection does not show warning if the language level 10 or higher, but the quick-fix is still available.\n\nThis inspection only reports if the language level of the project or module is 7 or higher.\n\nNew in 2022.1"
        },
        {
          "shortName": "TrivialStringConcatenation",
          "displayName": "Concatenation with empty string",
          "enabled": true,
          "description": "Reports string concatenations where one of the arguments is the empty string. Such a concatenation is unnecessary and inefficient, particularly when used as an idiom for formatting non-`String` objects or primitives into `String`s.\n\n\nA quick-fix is suggested to simplify the concatenation.\n\n**Example:**\n\n\n      void foo(int x, int y) {\n        String s = \"\" + x + \" ; \" + y;\n      }\n\nAfter the quick-fix is applied:\n\n\n      void foo(int x, int y) {\n        String s = x + \" ; \" + y;\n      }\n"
        },
        {
          "shortName": "AutoUnboxing",
          "displayName": "Auto-unboxing",
          "enabled": false,
          "description": "Reports expressions that are affected by unboxing conversion (automatic unwrapping of objects into primitive values). Try not to use objects instead of primitives. It might significantly affect the performance.\n\n**Example:**\n\n    int x = new Integer(42);\n\nThe quick-fix makes the conversion explicit:\n\n    int x = new Integer(42).intValue();\n\nAutoboxing conversion is not supported in Java 1.4 and earlier JVM."
        },
        {
          "shortName": "EqualsHashCodeCalledOnUrl",
          "displayName": "'equals()' or 'hashCode()' called on 'URL' object",
          "enabled": false,
          "description": "Reports `hashCode()` and `equals()` calls on `java.net.URL` objects.\n\n\n`URL`'s `equals()` and `hashCode()` methods can perform a DNS lookup to resolve the host name.\nThis may cause significant delays, depending on the availability and speed of the network and the DNS server.\nUsing `java.net.URI` instead of `java.net.URL` will avoid the DNS lookup.\n\n**Example:**\n\n\n      int equalsHashCode(URL url1, URL url2) {\n        return url1.hashCode() == url2.hashCode();\n      }\n"
        },
        {
          "shortName": "FieldMayBeStatic",
          "displayName": "Field can be made 'static'",
          "enabled": true,
          "description": "Reports instance variables that can safely be made `static`. A field can be static if it is declared `final` and initialized with a constant.\n\n**Example:**\n\n\n      public final String str = \"sample\";\n"
        },
        {
          "shortName": "CollectionsMustHaveInitialCapacity",
          "displayName": "Collection without initial capacity",
          "enabled": false,
          "description": "Reports attempts to instantiate a new `Collection` object without specifying an initial capacity.\n\n\nIf no initial capacity is specified, a default capacity is used, which will rarely be optimal. Failing\nto specify initial capacities for collections may result in performance issues if space needs to be reallocated and\nmemory copied when the initial capacity is exceeded.\nThis inspection checks allocations of classes listed in the inspection's settings.\n\n**Example:**\n\n\n      new HashMap<String, String>();\n\nUse the following options to configure the inspection:\n\n* List collection classes that should be checked.\n* Whether to ignore field initializers."
        },
        {
          "shortName": "MethodMayBeStatic",
          "displayName": "Method can be made 'static'",
          "enabled": false,
          "description": "Reports methods that can safely be made `static`. Making methods static when possible can reduce memory consumption and improve your code quality.\n\nA method can be `static` if:\n\n* it is not `synchronized`, `native` or `abstract`,\n* does not reference any of non-static methods and non-static fields from the containing class,\n* is not an override and is not overridden in a subclass.\n\nUse the following options to configure the inspection:\n\n* Whether to report only `private` and `final` methods, which increases the performance of this inspection.\n* Whether to ignore empty methods.\n* Whether to ignore default methods in interface when using Java 8 or higher.\n* Whether to let the quick-fix replace instance qualifiers with class references in calls to methods which are made `static`, that is, call `myClass.m()` would be replaced with `MyClass.m()`."
        },
        {
          "shortName": "InstantiatingObjectToGetClassObject",
          "displayName": "Instantiating object to get 'Class' object",
          "enabled": true,
          "description": "Reports code that instantiates a class to get its class object.\n\nIt is more performant to access the class object\ndirectly by name.\n\n**Example:**\n\n\n      Class<?> c = new Sample().getClass();\n\nAfter the quick-fix is applied:\n\n\n      Class<?> c = Sample.class;\n"
        },
        {
          "shortName": "AutoBoxing",
          "displayName": "Auto-boxing",
          "enabled": false,
          "description": "Reports expressions that are affected by autoboxing conversion (automatic wrapping of primitive values as objects). Try not to use objects instead of primitives. It might significantly affect performance.\n\n**Example:**\n\n    Integer x = 42;\n\nThe quick-fix makes the conversion explicit:\n\n    Integer x = Integer.valueOf(42);\n\nAutoboxing conversion is not supported in Java 1.4 and earlier JVM."
        },
        {
          "shortName": "ArraysAsListWithZeroOrOneArgument",
          "displayName": "Call to 'Arrays.asList()' with too few arguments",
          "enabled": true,
          "description": "Reports calls to `Arrays.asList()` with at most one argument.\n\n\nSuch calls could be replaced\nwith `Collections.singletonList()`, `Collections.emptyList()`,\nor `List.of()` on JDK 9 and later, which will save some memory.\n\nIn particular, `Collections.emptyList()` and `List.of()` with no arguments\nalways return a shared instance,\nwhile `Arrays.asList()` with no arguments creates a new object every time it's called.\n\nNote: the lists returned by `Collections.singletonList()` and `List.of()` are immutable,\nwhile the list returned `Arrays.asList()` allows calling the `set()` method.\nThis may break the code in rare cases.\n\n**Example:**\n\n\n      List<String> empty = Arrays.asList();\n      List<String> one = Arrays.asList(\"one\");\n\nAfter the quick-fix is applied:\n\n\n      List<String> empty = Collections.emptyList();\n      List<String> one = Collections.singletonList(\"one\");\n"
        },
        {
          "shortName": "ObjectAllocationInLoop",
          "displayName": "Object allocation in loop",
          "enabled": false,
          "description": "Reports object or array allocations inside loops. While not necessarily a problem, an object allocation inside a loop is a great place to look for memory leaks and performance issues.\n\n\nThe inspection reports the following constructs:\n\n* Explicit allocations via `new` operator\n* Methods known to return new object\n* Instance-bound method references\n* Lambdas that capture variables or `this` reference\n\n**Example:**\n\n\n      // Explicit allocation\n      for (Status status : Status.values()) {\n        declarationsMap.put(status, new ArrayList<>());\n      }\n\n      // Lambda captures variable\n      String message = \"Engine running.\";\n      for (Engine engine : engines) {\n          if (!isRunning(engine)) {\n              logger.warn(() -> {\n                  return String.format(message);\n              });\n          }\n      }\n\n      // Instance-bound method reference\n      for(Node node : nodes) {\n        descriptor = node.getDescription();\n        descriptor.ifPresent(dynamicTestExecutor::execute);\n      }\n\n"
        },
        {
          "shortName": "CallToSimpleGetterInClass",
          "displayName": "Call to simple getter from within class",
          "enabled": false,
          "description": "Reports calls to a simple property getter from within the property's class.\n\n\nA simple property getter is defined as one which simply returns the value of a field,\nand does no other calculations. Such simple getter calls can be safely inlined using the quick-fix.\nSome coding standards also suggest against the use of simple getters for code clarity reasons.\n\n**Example:**\n\n\n      public class Salient {\n        private String name;\n\n        public String getName() {\n          return name;\n        }\n\n        @Override\n        public String toString() {\n          return getName();\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      public class Salient {\n        private String name;\n\n        public String getName() {\n          return name;\n        }\n\n        @Override\n        public String toString() {\n          return name;\n        }\n      }\n\nUse the following options to configure the inspection:\n\n* Whether to only report getter calls on `this`, not on objects of the same type passed in as a parameter.\n* Whether to ignore non-`private` getters."
        },
        {
          "shortName": "LengthOneStringsInConcatenation",
          "displayName": "Single character string concatenation",
          "enabled": false,
          "description": "Reports concatenation with string literals that consist of one character.\n\nThese literals may be replaced with equivalent character literals, gaining some performance enhancement.\n\n**Example:**\n\n\n      String hello = hell + \"o\";\n\nAfter the quick-fix is applied:\n\n\n      String hello = hell + 'o';\n"
        },
        {
          "shortName": "ListRemoveInLoop",
          "displayName": "'List.remove()' called in loop",
          "enabled": true,
          "description": "Reports `List.remove(index)` called in a loop that can be replaced with `List.subList().clear()`.\n\nThe replacement\nis more efficient for most `List` implementations when many elements are deleted.\n\nExample:\n\n\n      void removeRange(List<String> list, int from, int to) {\n        for (int i = from; i < to; i++) {\n            list.remove(from);\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      void removeRange(List<String> list, int from, int to) {\n        if (to > from) {\n          list.subList(from, to).clear();\n        }\n      }\n\n\nThe quick-fix adds a range check automatically to prevent a possible `IndexOutOfBoundsException` when the minimal value is bigger\nthan the maximal value. It can be removed if such a situation is impossible in your code.\n\nNew in 2018.2"
        },
        {
          "shortName": "ObjectInstantiationInEqualsHashCode",
          "displayName": "Object instantiation inside 'equals()' or 'hashCode()'",
          "enabled": false,
          "description": "Reports construction of (temporary) new objects inside `equals()`, `hashCode()`, `compareTo()`, and `Comparator.compare()` methods.\n\n\nBesides constructor invocations, new objects can also be created by autoboxing or iterator creation inside a\n`foreach` statement.\nThis can cause performance problems, for example, when objects are added to a `Set` or `Map`,\nwhere these methods will be called often.\n\n\nThe inspection will not report when the objects are created in a `throw` or `assert` statement.\n\n**Example:**\n\n\n      class Person {\n        private String name;\n        private int age;\n\n        public boolean equals(Object o) {\n          return Arrays.equals(new Object[] {name, age}, new Object[] {((Foo)o).name, ((Foo)o).age});\n        }\n\n        public int hashCode() {\n          return (name + age).hashCode();\n        }\n      }\n\n\nIn this example, two additional arrays are created inside `equals()`, usages of `age` field require boxing,\nand `name + age` implicitly creates a new string."
        },
        {
          "shortName": "BooleanConstructor",
          "displayName": "Boolean constructor call",
          "enabled": true,
          "description": "Reports creation of `Boolean` objects.\n\n\nConstructing new `Boolean` objects is rarely necessary,\nand may cause performance problems if done often enough. Also, `Boolean`\nconstructors are deprecated since Java 9 and could be removed or made\ninaccessible in future Java versions.\n\n**Example:**\n\n\n      Boolean b1 = new Boolean(true);\n      Boolean b2 = new Boolean(str);\n\nAfter the quick-fix is applied:\n\n\n      Boolean b1 = Boolean.TRUE;\n      Boolean b2 = Boolean.valueOf(str);\n"
        },
        {
          "shortName": "IfStatementMissingBreakInLoop",
          "displayName": "Early loop exit in 'if' condition",
          "enabled": true,
          "description": "Reports loops with an `if` statement that can end with `break` without changing the semantics. This prevents redundant loop iterations.\n\n**Example:**\n\n\n      boolean found = false;\n      for (int i = 0; i < arr.length; i++) {\n        if (Objects.equals(value, arr[i])) {\n          found = true;\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      boolean found = false;\n      for (int i = 0; i < arr.length; i++) {\n        if (Objects.equals(value, arr[i])) {\n          found = true;\n          break;\n        }\n      }\n\nNew in 2019.2"
        },
        {
          "shortName": "RedundantStringFormatCall",
          "displayName": "Redundant call to 'String.format()'",
          "enabled": true,
          "description": "Reports calls to methods like `format()` and `printf()` that can be safely removed or simplified.\n\n**Example:**\n\n\n      System.out.println(String.format(\"Total count: %d\", 42));\n\nAfter the quick-fix is applied:\n\n\n      System.out.printf(\"Total count: %d%n\", 42);\n"
        },
        {
          "shortName": "TailRecursion",
          "displayName": "Tail recursion",
          "enabled": false,
          "description": "Reports tail recursion, that is, when a method calls itself as its last action before returning.\n\n\nTail recursion can always be replaced by looping, which will be considerably faster.\nSome JVMs perform tail-call optimization, while others do not. Thus, tail-recursive solutions may have considerably different\nperformance characteristics on different virtual machines.\n\nExample:\n\n\n      int factorial(int val, int runningVal) {\n        if (val == 1) {\n          return runningVal;\n        } else {\n          return factorial(val - 1, runningVal * val);\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      int factorial(int val, int runningVal) {\n        while (true) {\n          if (val == 1) {\n            return runningVal;\n          } else {\n            runningVal = runningVal * val;\n            val = val - 1;\n          }\n        }\n      }\n"
        },
        {
          "shortName": "StringEqualsEmptyString",
          "displayName": "'String.equals()' can be replaced with 'String.isEmpty()'",
          "enabled": false,
          "description": "Reports `equals()` being called to compare a `String` with an empty string. In this case, using `.isEmpty()` is better as it shows you exactly what you're checking.\n\n**Example:**\n\n\n      void checkString(String s){\n        if (\"\".equals(s)) throw new IllegalArgumentException();\n      }\n\nAfter the quick-fix is applied:\n\n\n      void checkString(String s){\n        if (s != null && s.isEmpty()) throw new IllegalArgumentException();\n      }\n\n\n`\"\".equals(str)` returns false when `str` is null. For safety, this inspection's quick-fix inserts an explicit\nnull-check when\nthe `equals()` argument is nullable. Use the option to make the inspection ignore such cases."
        },
        {
          "shortName": "ObjectEqualsCanBeEquality",
          "displayName": "'equals()' call can be replaced with '=='",
          "enabled": true,
          "description": "Reports calls to `equals()` that can be replaced by `==` or `!=` expressions without a change in semantics.\n\nThese calls can be replaced when they are used to compare `final` classes that don't have their own `equals()` implementation but use the default `Object.equals()`.\nThis replacement may result in better performance.\n\nThere is a separate inspection for `equals()` calls on `enum` values: 'equals()' called on Enum value."
        },
        {
          "shortName": "ToArrayCallWithZeroLengthArrayArgument",
          "displayName": "'Collection.toArray()' call style",
          "enabled": true,
          "description": "Reports `Collection.toArray()` calls that are not in the preferred style, and suggests applying the preferred style.\n\nThere are two styles to convert a collection to an array:\n\n* A pre-sized array, for example, `c.toArray(new String[c.size()])`\n* An empty array, for example, `c.toArray(new String[0])`\n\nIn older Java versions, using a pre-sized array was recommended, as the reflection\ncall necessary to create an array of proper size was quite slow.\n\nHowever, since late updates of OpenJDK 6, this call was intrinsified, making\nthe performance of the empty array version the same, and sometimes even better, compared\nto the pre-sized version. Also, passing a pre-sized array is dangerous for a concurrent or\nsynchronized collection as a data race is possible between the `size` and `toArray`\ncalls. This may result in extra `null`s at the end of the array if the collection was concurrently\nshrunk during the operation.\n\nUse the inspection options to select the preferred style."
        },
        {
          "shortName": "ReplaceInefficientStreamCount",
          "displayName": "Inefficient Stream API call chains ending with count()",
          "enabled": true,
          "description": "Reports Stream API call chains ending with the `count()` operation that could be optimized.\n\n\nThe following call chains are replaced by this inspection:\n\n* `Collection.stream().count()`  `Collection.size()`. In Java 8 `Collection.stream().count()` actually iterates over the collection elements to count them, while `Collection.size()` is much faster for most of the collections.\n* `Stream.flatMap(Collection::stream).count()`  `Stream.mapToLong(Collection::size).sum()`. Similarly, there's no need to iterate over all the nested collections. Instead, their sizes could be summed up.\n* `Stream.filter(o -> ...).count() > 0`  `Stream.anyMatch(o -> ...)`. Unlike the original call, `anyMatch()` may stop the computation as soon as a matching element is found.\n* `Stream.filter(o -> ...).count() == 0`  `Stream.noneMatch(o -> ...)`. Similar to the above.\n\n\nNote that if the replacement involves a short-circuiting operation like `anyMatch()`, there could be a visible behavior change,\nif the intermediate stream operations produce side effects. In general, side effects should be avoided in Stream API calls."
        },
        {
          "shortName": "ManualArrayToCollectionCopy",
          "displayName": "Manual array to collection copy",
          "enabled": true,
          "description": "Reports code that uses a loop to copy the contents of an array into a collection.\n\n\nA shorter and potentially faster (depending on the collection implementation) way to do this is using `Collection.addAll(Arrays.asList())` or `Collections.addAll()`.\n\n\nOnly loops without additional statements inside are reported.\n\n**Example:**\n\n\n      void addAll(List<String> list, String[] arr) {\n        for (int i = 0; i < arr.length; i++) {\n          String s = arr[i];\n          list.add(s);\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      void addAll(List<String> list, String[] arr) {\n        Collections.addAll(list, arr);\n      }\n"
        },
        {
          "shortName": "MapReplaceableByEnumMap",
          "displayName": "'Map' can be replaced with 'EnumMap'",
          "enabled": false,
          "description": "Reports instantiations of `java.util.Map` objects whose key types are enumerated classes. Such `java.util.Map` objects can be replaced with `java.util.EnumMap` objects.\n\n\n`java.util.EnumMap` implementations can be much more efficient\nbecause the underlying data structure is a simple array.\n\n**Example:**\n\n\n      Map<MyEnum, String> myEnums = new HashMap<>();\n\nAfter the quick-fix is applied:\n\n\n      Map<MyEnum, String> myEnums = new EnumMap<>(MyEnum.class);\n"
        },
        {
          "shortName": "BulkFileAttributesRead",
          "displayName": "Bulk 'Files.readAttributes' call can be used instead of multiple file attribute calls",
          "enabled": false,
          "description": "Reports multiple `java.io.File` attribute checks in a row, such as:\n\n* `isDirectory`\n* `isFile`\n* `lastModified`\n* `length`\n\nThese calls can be replaced with a bulk `Files.readAttributes` call. Usually the bulk method is more performant then multiple attribute checks.\n\nExample:\n\n\n    boolean isNewFile(File file, long lastModified) throws IOException {\n      return file.isFile() && file.lastModified() > lastModified;\n    }\n\nAfter the quick-fix is applied:\n\n\n    boolean isNewFile(File file, long lastModified) throws IOException {\n      BasicFileAttributes fileAttributes = Files.readAttributes(file.toPath(), BasicFileAttributes.class);\n      return fileAttributes.isRegularFile() && fileAttributes.lastModifiedTime().toMillis() > lastModified;\n    }\n\nThis inspection does not show a warning if `IOException` is not handled in the current context, but the quick-fix is still available.\n\nThis inspection only reports if the language level of the project or module is 7 or higher.\n\nNew in 2022.1"
        },
        {
          "shortName": "ExplicitArgumentCanBeLambda",
          "displayName": "Explicit argument can be lambda",
          "enabled": true,
          "description": "Reports method calls that accept a non-trivial expression and can be replaced with an equivalent method call which accepts a lambda instead.\n\n\nConverting an expression to a lambda ensures that the expression won't be evaluated\nif it's not used inside the method. For example, `optional.orElse(createDefaultValue())` can be converted\nto `optional.orElseGet(this::createDefaultValue)`.\n\nNew in 2018.1"
        },
        {
          "shortName": "UseBulkOperation",
          "displayName": "Bulk operation can be used instead of iteration",
          "enabled": true,
          "description": "Reports single operations inside loops that could be replaced with a bulk method.\n\n\nNot only are bulk methods shorter, but in some cases they may be more performant as well.\n\n**Example:**\n\n      void test(Collection<Integer> numbers) {\n        List<Integer> result = new ArrayList<>();\n        for (Integer i : numbers) {\n          result.add(i);\n        }\n      }\n\nAfter the fix is applied:\n\n\n      void test(Collection<Integer> numbers) {\n        List<Integer> result = new ArrayList<>();\n        result.addAll(numbers);\n      }\n\n\nThe **Use Arrays.asList() to wrap arrays** option allows to report arrays, even if the bulk method requires a collection.\nIn this case the quick-fix will automatically wrap the array in `Arrays.asList()` call.\n\nNew in 2017.1"
        },
        {
          "shortName": "SlowListContainsAll",
          "displayName": "Call to 'list.containsAll(collection)' may have poor performance",
          "enabled": false,
          "description": "Reports calls to `containsAll()` on `java.util.List`.\n\n\nThe time complexity of this method call is O(nm), where n is the number of elements in the list on which\nthe method is called, and m is the number of elements in the collection passed to the method as a parameter.\nWhen the list is large, this can be an expensive operation.\n\n\nThe quick-fix wraps the list in `new java.util.HashSet<>()` since the time required to create\n`java.util.HashSet` from `java.util.List` and execute `containsAll()` on\n`java.util.HashSet` is O(n+m).\n\n**Example:**\n\n      public boolean check(List<String> list, Collection<String> collection) {\n        // O(nm) complexity\n        return list.containsAll(collection);\n      }\n\nAfter the quick-fix is applied:\n\n      public boolean check(List<String> list, Collection<String> collection) {\n        // O(n+m) complexity\n        return new HashSet<>(list).containsAll(collection);\n      }\n\nNew in 2022.1"
        },
        {
          "shortName": "StringConcatenationInsideStringBufferAppend",
          "displayName": "String concatenation as argument to 'StringBuilder.append()' call",
          "enabled": true,
          "description": "Reports `String` concatenation used as the argument to `StringBuffer.append()`, `StringBuilder.append()` or `Appendable.append()`.\n\n\nSuch calls may profitably be turned into chained append calls on the existing `StringBuffer/Builder/Appendable`\nsaving the cost of an extra `StringBuffer/Builder` allocation.\nThis inspection ignores compile-time evaluated `String` concatenations, in which case the conversion would only\nworsen performance.\n\n**Example:**\n\n\n      void bar(StringBuilder builder, String name) {\n        builder.append(\"Hello,\" + name);    //warning\n        builder.append(\"Hello,\" + \"world\"); //no warning\n      }\n"
        },
        {
          "shortName": "BoxingBoxedValue",
          "displayName": "Boxing of already boxed value",
          "enabled": true,
          "description": "Reports boxing of already boxed values.\n\n\nThis is a redundant\noperation since any boxed value will first be auto-unboxed before boxing the\nvalue again. If done inside an inner loop, such code may cause performance\nproblems.\n\n**Example:**\n\n\n      Integer value = 1;\n      method(Integer.valueOf(value));\n\nAfter the quick fix is applied:\n\n\n      Integer value = 1;\n      method(value);\n"
        },
        {
          "shortName": "StringBufferMustHaveInitialCapacity",
          "displayName": "'StringBuilder' without initial capacity",
          "enabled": false,
          "description": "Reports attempts to instantiate a new `StringBuffer` or `StringBuilder` object without specifying its initial capacity.\n\n\nIf no initial capacity is specified, a default capacity is used, which will rarely be optimal.\nFailing to specify the initial capacity for `StringBuffer` may result\nin performance issues if space needs to be reallocated and memory copied\nwhen the initial capacity is exceeded.\n\nExample:\n\n\n      // Capacity is not specified\n      var sb = new StringBuilder();\n"
        },
        {
          "shortName": "StringReplaceableByStringBuffer",
          "displayName": "Non-constant 'String' can be replaced with 'StringBuilder'",
          "enabled": false,
          "description": "Reports variables declared as `java.lang.String` that are repeatedly appended to. Such variables could be declared more efficiently as `java.lang.StringBuffer` or `java.lang.StringBuilder`.\n\n**Example:**\n\n\n      String s = \"\";\n      for (int i = 0; i < names.length; i++) {\n        String name = names[i] + (i == names.length - 1 ? \"\" : \" \");\n        s = s + name;\n      }\n\nSuch a loop can be replaced with:\n\n\n      StringBuilder s = new StringBuilder();\n      for (int i = 0; i < names.length; i++) {\n        String name = names[i] + (i == names.length - 1 ? \"\" : \" \");\n        s.append(name);\n      }\n\nOr even with:\n\n\n      String s = String.join(\" \", names);\n\n\nUse the option to make this inspection only report when the variable is appended to in a loop."
        },
        {
          "shortName": "StringBufferToStringInConcatenation",
          "displayName": "'StringBuilder.toString()' in concatenation",
          "enabled": false,
          "description": "Reports `StringBuffer.toString()` or `StringBuilder.toString()` calls in string concatenations. Such calls are unnecessary when concatenating and can be removed, saving a method call and an object allocation, which may improve performance."
        },
        {
          "shortName": "CollectionContainsUrl",
          "displayName": "'Map' or 'Set' may contain 'URL' objects",
          "enabled": false,
          "description": "Reports `java.util.Set` and `java.util.Map` variables that contain `java.net.URL` objects. Such collections will call the `equals()` and `hashCode()` methods on inserted objects, which can cause performance problems on `URL` objects.\n\n\n`URL`'s `equals()` and `hashCode()` methods can perform a DNS lookup to resolve the host name.\nThis may cause significant delays, depending on the availability and speed of the network and the DNS server.\nUsing `java.net.URI` instead of `java.net.URL` will avoid the DNS lookup.\n\n**Example:**\n\n\n      Set<URL> set = new HashSet<URL>();\n"
        },
        {
          "shortName": "UnnecessaryTemporaryOnConversionToString",
          "displayName": "Unnecessary temporary object in conversion to 'String'",
          "enabled": true,
          "description": "Reports unnecessary creation of temporary objects when converting from a primitive type to `String`.\n\n**Example:**\n\n\n      String foo = new Integer(3).toString();\n\nAfter the quick-fix is applied:\n\n\n      String foo = Integer.toString(3);\n"
        },
        {
          "shortName": "ClassInitializerMayBeStatic",
          "displayName": "Class initializer may be 'static'",
          "enabled": true,
          "description": "Reports instance initializers which may be made `static`.\n\n\nAn instance initializer may be static if it does not reference any of its class' non-static members.\nStatic initializers are executed once the class is resolved,\nwhile instance initializers are executed on each instantiation of the class.\n\n**Example:**\n\n\n      class A {\n         public static String CONSTANT;\n         {\n            CONSTANT = \"Hello\";\n         }\n      }\n\nAfter the quick-fix is applied:\n\n\n      class A {\n         public static String CONSTANT;\n         static {\n            CONSTANT = \"Hello\"; //now initialized only once per class\n         }\n      }\n"
        },
        {
          "shortName": "SlowAbstractSetRemoveAll",
          "displayName": "Call to 'set.removeAll(list)' may work slowly",
          "enabled": true,
          "description": "Reports calls to `java.util.Set.removeAll()` with a `java.util.List` argument.\n\n\nSuch a call can be slow when the size of the argument is greater than or equal to the size of the set,\nand the set is a subclass of `java.util.AbstractSet`.\nIn this case, `List.contains()` is called for each element in the set, which will perform a linear search.\n\n**Example:**\n\n      public void check(String... ss) {\n        // possible O(n^2) complexity\n        mySet.removeAll(List.of(ss));\n      }\n\nAfter the quick fix is applied:\n\n      public void check(String... ss) {\n        // O(n) complexity\n        List.of(ss).forEach(mySet::remove);\n      }\n\nNew in 2020.3"
        },
        {
          "shortName": "SetReplaceableByEnumSet",
          "displayName": "'Set' can be replaced with 'EnumSet'",
          "enabled": false,
          "description": "Reports instantiations of `java.util.Set` objects whose content types are enumerated classes. Such `Set` objects can be replaced with `java.util.EnumSet` objects.\n\n\n`EnumSet` implementations can be much more efficient compared to\nother sets, as the underlying data structure is a bit vector. Use the quick-fix to replace the initializer with a call to\n`EnumSet.noneOf()`. This quick-fix is not available when the type of the variable is a sub-class of `Set`.\n\n**Example:**\n\n\n      enum MyEnum { FOO, BAR; }\n\n      Set<MyEnum> enums = new HashSet<MyEnum>();\n\nAfter the quick-fix is applied:\n\n\n      enum MyEnum { FOO, BAR; }\n\n      Set<MyEnum> enums = EnumSet.noneOf(MyEnum.class);\n"
        },
        {
          "shortName": "CallToSimpleSetterInClass",
          "displayName": "Call to simple setter from within class",
          "enabled": false,
          "description": "Reports calls to a simple property setter from within the property's class.\n\n\nA simple property setter is defined as one which simply assigns the value of its parameter to a field,\nand does no other calculations. Such simple setter calls can be safely inlined.\nSome coding standards also suggest against the use of simple setters for code clarity reasons.\n\n**Example:**\n\n\n      class Foo {\n      private int index;\n        public Foo(int idx) {\n           setIndex(idx);\n        }\n        public void setIndex(int idx) {\n           index = idx;\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      class Foo {\n        private int index;\n        public Foo(int idx) {\n          index = idx;\n        }\n        public void setIndex(int idx) {\n          index = idx;\n        }\n      }\n\nUse the following options to configure the inspection:\n\n* Whether to only report setter calls on `this`, not on objects of the same type passed in as a parameter.\n* Whether to ignore non-`private` setters."
        },
        {
          "shortName": "WrapperTypeMayBePrimitive",
          "displayName": "Wrapper type may be primitive",
          "enabled": true,
          "description": "Reports local variables of wrapper type that are mostly used as primitive types.\n\nIn some cases, boxing can be source of significant performance penalty, especially in loops.\n\nHeuristics are applied to estimate the number of boxing operations. For example, conversions inside loops are considered\nas much more numerous.\n\n**Example:**\n\n      public void example() {\n        Integer value = 12;\n        needBox(value);\n        for (int i = 0; i < 10; i++) {\n          // Loop usages considered as happening more often\n          needPrimitive(value);\n        }\n      }\n\n      void needPrimitive(int value) {}\n      void needBox(Integer value) {}\n\nAfter the quick-fix is applied:\n\n      public void example() {\n        int value = 12;\n        needBox(value);\n        for (int i = 0; i < 10; i++) {\n          // Loop usages considered as happening more often\n          needPrimitive(value);\n        }\n      }\n\n      void needPrimitive(int value) {}\n      void needBox(Integer value) {}\n\n\nNew in 2018.2"
        },
        {
          "shortName": "CollectionAddAllCanBeReplacedWithConstructor",
          "displayName": "Redundant 'Collection.addAll()' call",
          "enabled": true,
          "description": "Reports `Collection.addAll()` and `Map.putAll()` calls immediately after instantiation of a collection using the no-arg constructor.\n\nSuch constructs can be replaced with a single call to a parametrized constructor, which simplifies code. Also, for some collections the replacement\nmight be more performant.\n\n**Example:**\n\n      Set<String> set = new HashSet<>();\n      set.addAll(Arrays.asList(\"alpha\", \"beta\", \"gamma\"));\n\nCan be replaced with:\n\n      Set<String> set = new HashSet<>(Arrays.asList(\"alpha\", \"beta\", \"gamma\"));\n\n\nStandard JDK collection classes are supported by default. Additionally, you can specify other classes in the inspection options."
        }
      ]
    },
    {
      "name": "Class structure",
      "inspections": [
        {
          "shortName": "ConstantDeclaredInAbstractClass",
          "displayName": "Constant declared in 'abstract' class",
          "enabled": false,
          "description": "Reports constants (`public static final` fields) declared in abstract classes.\n\nSome coding standards require declaring constants in interfaces instead."
        },
        {
          "shortName": "ClassWithOnlyPrivateConstructors",
          "displayName": "Class with only 'private' constructors should be declared 'final'",
          "enabled": false,
          "description": "Reports classes with only `private` constructors.\n\nA class that only has `private` constructors cannot be extended outside a file and should be declared as `final`."
        },
        {
          "shortName": "NonFinalFieldInEnum",
          "displayName": "Non-final field in 'enum'",
          "enabled": false,
          "description": "Reports non-final fields in enumeration types as they are rarely needed and provide a global mutable state.\n\n**Example:**\n\n\n      enum Enum {\n        FIRST(\"first\"),\n        SECOND(\"second\");\n\n        public String str;\n\n        Enum(String str) {\n            this.str = str;\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      enum Enum {\n        FIRST(\"first\"),\n        SECOND(\"second\");\n\n        public final String str;\n\n        Enum(String str) {\n            this.str = str;\n        }\n      }\n\nConfigure the \\`Ignore field if quick-fix is not available\\` checkbox to only highlight fields that can be made final by the quick-fix."
        },
        {
          "shortName": "FinalMethod",
          "displayName": "Method can't be overridden",
          "enabled": false,
          "description": "Reports methods that are declared `final`. Such methods can't be overridden and may indicate a lack of object-oriented design. Some coding standards discourage `final` methods."
        },
        {
          "shortName": "Singleton",
          "displayName": "Singleton",
          "enabled": false,
          "description": "Reports singleton classes.\n\nSingleton classes are declared in a way that only one instance of the class can ever be instantiated. Singleton classes complicate testing,\nand their presence may indicate a lack of object-oriented design.\n\n**Example:**\n\n\n      class Singleton {\n        private static final Singleton ourInstance = new Singleton();\n\n        private Singleton() {\n        }\n\n        public Singleton getInstance() {\n            return ourInstance;\n        }\n      }\n"
        },
        {
          "shortName": "NonFinalUtilityClass",
          "displayName": "Utility class is not 'final'",
          "enabled": false,
          "description": "Reports utility classes that aren't `final`.\n\nUtility classes have all fields and methods declared as `static`.\nMaking them `final` prevents them from being accidentally subclassed."
        },
        {
          "shortName": "StaticNonFinalField",
          "displayName": "'static', non-'final' field",
          "enabled": false,
          "description": "Reports non-`final` `static` fields.\n\nA quick-fix is available to add the `final` modifier to a non-`final` `static` field.\n\nThis inspection doesn't check fields' mutability. For example, adding the `final` modifier to a field that has a value\nbeing set somewhere will cause a compilation error.\n\n\nUse the **Only report 'public' fields** option so that the inspection reported only `public` fields."
        },
        {
          "shortName": "ParameterCanBeLocal",
          "displayName": "Value passed as parameter never read",
          "enabled": true,
          "description": "Reports redundant method parameters that can be replaced with local variables.\n\nIf all local usages of a parameter are preceded by assignments to that parameter, the\nparameter can be removed and its usages replaced with local variables.\nIt makes no sense to have such a parameter, as values that are passed to it are overwritten.\nUsually, the problem appears as a result of refactoring.\n\nExample:\n\n\n      void test(int p) {\n        p = 1;\n        System.out.print(p);\n      }\n\nAfter the quick-fix is applied:\n\n\n      void test() {\n        int p = 1;\n        System.out.print(p);\n      }\n"
        },
        {
          "shortName": "NoopMethodInAbstractClass",
          "displayName": "No-op method in 'abstract' class",
          "enabled": false,
          "description": "Reports no-op (for \"no operation\") methods in `abstract` classes.\n\nIt is usually a better\ndesign to make such methods `abstract` themselves so that classes inheriting these\nmethods provide their implementations.\n\n**Example:**\n\n\n      abstract class Test {\n        protected void doTest() {\n        }\n      }\n"
        },
        {
          "shortName": "ClassInitializer",
          "displayName": "Non-'static' initializer",
          "enabled": false,
          "description": "Reports non-`static` initializers in classes.\n\nSome coding standards prohibit instance initializers and recommend using constructors or field initializers for initialization.\nAlso, deleting the `static` keyword may accidentally create non-`static` initializers and result in obscure bugs.\n\nThis inspection doesn't report instance initializers in anonymous classes.\n\n\nUse the **Only warn when the class has one or more constructors** option to ignore instance initializers in classes that don't have any constructors."
        },
        {
          "shortName": "UtilityClassWithPublicConstructor",
          "displayName": "Utility class with 'public' constructor",
          "enabled": true,
          "description": "Reports utility classes with `public` constructors.\n\nUtility classes have all fields and methods declared as `static`. Creating a `public`\nconstructor in such classes is confusing and may cause accidental class instantiation."
        },
        {
          "shortName": "UtilityClassCanBeEnum",
          "displayName": "Utility class can be 'enum'",
          "enabled": false,
          "description": "Reports utility classes that can be converted to enums.\n\nSome coding style guidelines declare to implement utility classes as enums\nto avoid code coverage issues in `private` constructors.\n\n**Example:**\n\n\n      class StringUtils {\n        public static final String EMPTY = \"\";\n      }\n\nAfter the quick-fix is applied:\n\n\n      enum StringUtils {\n        ;\n        public static final String EMPTY = \"\";\n      }\n"
        },
        {
          "shortName": "ListenerMayUseAdapter",
          "displayName": "Class may extend adapter instead of implementing listener",
          "enabled": false,
          "description": "Reports classes implementing listeners instead of extending corresponding adapters.\n\nA quick-fix is available to\nremove any redundant empty methods left after replacing a listener implementation with an adapter extension.\n\n\nUse the **Only warn when empty implementing methods are found** option to configure the inspection to warn even if no empty methods are found."
        },
        {
          "shortName": "FinalClass",
          "displayName": "Class is closed to inheritance",
          "enabled": false,
          "description": "Reports classes that are declared `final`. Such classes can't be inherited and may indicate a lack of object-oriented design. Some coding standards discourage `final` classes."
        },
        {
          "shortName": "UtilityClassWithoutPrivateConstructor",
          "displayName": "Utility class without 'private' constructor",
          "enabled": false,
          "description": "Reports utility classes without `private` constructors.\n\nUtility classes have all fields and methods declared as `static`. Creating `private`\nconstructors in utility classes prevents them from being accidentally instantiated.\n\n\nUse the **Ignore if annotated by** option to specify special annotations. The inspection ignores classes marked with one of\nthese annotations.\n\n\nUse the **Ignore classes with only a main method** option to ignore classes with no methods other than the main one."
        },
        {
          "shortName": "MarkerInterface",
          "displayName": "Marker interface",
          "enabled": false,
          "description": "Reports marker interfaces without any methods or fields.\n\nSuch interfaces may be confusing and typically indicate a design failure.\n\nThe inspection ignores interfaces that extend two or more interfaces and interfaces\nthat specify the generic type of their superinterface."
        },
        {
          "shortName": "InnerClassOnInterface",
          "displayName": "Inner class of interface",
          "enabled": false,
          "description": "Reports inner classes in `interface` classes.\n\nSome coding standards\ndiscourage the use of such classes. The inspection doesn't report enumeration and annotation classes.\n\n\nUse the **Ignore inner interfaces of interfaces** option to ignore inner interfaces. For example:\n\n\n      interface I {\n        interface Inner {\n        }\n      }\n"
        },
        {
          "shortName": "FieldCanBeLocal",
          "displayName": "Field can be local",
          "enabled": false,
          "description": "Reports redundant class fields that can be replaced with local variables.\n\nIf all local usages of a field are preceded by assignments to that field, the\nfield can be removed, and its usages can be replaced with local variables."
        },
        {
          "shortName": "UtilityClass",
          "displayName": "Utility class",
          "enabled": false,
          "description": "Reports utility classes.\n\nUtility classes have all fields and methods declared as `static` and their\npresence may indicate a lack of object-oriented design.\n\n\nUse the **Ignore if annotated by** option to specify special annotations. The inspection ignores classes annotated with one of\nthese annotations."
        },
        {
          "shortName": "ClassNameDiffersFromFileName",
          "displayName": "Class name differs from file name",
          "enabled": false,
          "description": "Reports top-level class names that don't match the name of a file containing them.\n\nWhile the Java specification allows for naming non-`public` classes this way,\nfiles with unmatched names may be confusing and decrease usefulness of various software tools."
        },
        {
          "shortName": "AnonymousInnerClass",
          "displayName": "Anonymous inner class can be replaced with inner class",
          "enabled": false,
          "description": "Reports anonymous inner classes.\n\nIn some cases, replacing anonymous inner classes with inner classes can lead to more readable and maintainable code.\nAlso, some code standards discourage anonymous inner classes."
        },
        {
          "shortName": "MultipleTopLevelClassesInFile",
          "displayName": "Multiple top level classes in single file",
          "enabled": false,
          "description": "Reports multiple top-level classes in a single Java file.\n\nPutting multiple\ntop-level classes in one file may be confusing and degrade the usefulness of various\nsoftware tools."
        },
        {
          "shortName": "LimitedScopeInnerClass",
          "displayName": "Local class",
          "enabled": false,
          "description": "Reports local classes.\n\nA local class is a named nested class declared inside a code block.\nLocal classes are uncommon and may therefore be confusing.\nIn addition, some code standards discourage the use of local classes.\n\n**Example:**\n\n\n      void test() {\n        class Local { // local class\n        }\n        new Local();\n      }\n"
        },
        {
          "shortName": "ClassMayBeInterface",
          "displayName": "Abstract 'class' may be 'interface'",
          "enabled": false,
          "description": "Reports `abstract` classes that can be converted to interfaces.\n\nUsing interfaces instead of classes is preferable as Java doesn't support multiple class inheritance,\nwhile a class can implement multiple interfaces.\n\nA class may be converted to an interface if it has no superclasses (other\nthan Object), has only `public static final` fields,\n`public abstract` methods, and `public` inner classes.\n\n\nExample:\n\n\n    abstract class Example {\n        public static final int MY_CONST = 42;\n        public abstract void foo();\n    }\n\n    class Inheritor extends Example {\n        @Override\n        public void foo() {\n            System.out.println(MY_CONST);\n        }\n    }\n\nAfter the quick-fix is applied:\n\n\n    interface Example {\n        int MY_CONST = 42;\n        void foo();\n    }\n\n    class Inheritor implements Example {\n        @Override\n        public void foo() {\n            System.out.println(MY_CONST);\n        }\n    }\n\nConfigure the inspection:\n\n\nUse the **Report classes containing non-abstract methods when using Java 8** option to report only the classes with `static` methods and non-abstract methods that can be converted to\n`default` methods (only applicable to language level of 8 or higher)."
        },
        {
          "shortName": "EmptyClass",
          "displayName": "Redundant empty class",
          "enabled": false,
          "description": "Reports empty classes and Java files without any defined classes.\n\nA class is empty if it\ndoesn't contain any fields, methods, constructors, or initializers. Empty classes often remain\nafter significant changes or refactorings.\n\nConfigure the inspection:\n\n* Use the **Ignore if annotated by** option to specify special annotations. The inspection will ignore the classes marked with these annotations.\n*\n  Use the **Ignore class if it is a parametrization of a super type** option to ignore classes that parameterize a superclass. For example:\n\n      class MyList extends ArrayList<String> {}\n\n* Use the **Ignore subclasses of java.lang.Throwable** to ignore classes that extend `java.lang.Throwable`.\n* Use the **Comments count as content** option to ignore classes that contain comments."
        },
        {
          "shortName": "InterfaceMayBeAnnotatedFunctional",
          "displayName": "Interface may be annotated as '@FunctionalInterface'",
          "enabled": false,
          "description": "Reports interfaces that can be annotated with `@FunctionalInterface` (available since JDK 1.8).\n\nAnnotating an interface with `@FunctionalInterface` indicates that the interface\nis functional and cannot have any more `abstract` methods.\n\nThis inspection only reports if the language level of the project or module is 8 or higher."
        },
        {
          "shortName": "FinalPrivateMethod",
          "displayName": "'private' method declared 'final'",
          "enabled": false,
          "description": "Reports methods that are marked with both `final` and `private` keywords.\n\nSince `private` methods cannot be meaningfully overridden because of their visibility, declaring them\n`final` is redundant."
        },
        {
          "shortName": "FinalStaticMethod",
          "displayName": "'static' method declared 'final'",
          "enabled": false,
          "description": "Reports static methods that are marked as `final`.\n\nSuch code might indicate an error or an incorrect assumption about the effect of the `final` keyword.\nStatic methods are not subject to runtime polymorphism, so the only purpose of the `final` keyword used with static methods\nis to ensure the method will not be hidden in a subclass."
        },
        {
          "shortName": "MethodReturnAlwaysConstant",
          "displayName": "Method returns per-class constant",
          "enabled": false,
          "description": "Reports methods that only return a constant, which may differ for various inheritors.\n\nAvailable only from **Code \\| Inspect Code** or\n**Code \\| Analyze Code \\| Run Inspection by Name** and isn't reported in the editor."
        },
        {
          "shortName": "PublicConstructor",
          "displayName": "'public' constructor can be replaced with factory method",
          "enabled": false,
          "description": "Reports `public` constructors.\n\nSome coding standards discourage the use of `public` constructors and recommend\n`static` factory methods instead.\nThis way the implementation can be swapped out without affecting the call sites.\n\n**Example:**\n\n\n      class Test {\n        private String name;\n\n        public Test(String name) {\n            this.name = name;\n        }\n\n        public void test() {\n            System.out.println(name);\n        }\n\n        public static void main(String[] args) {\n            new Test(\"str\").test();\n        }\n      }\n\nAfter quick-fix is applied:\n\n\n      class Test {\n        private String name;\n\n        private Test(String name) {\n            this.name = name;\n        }\n\n        public static Test getInstance(String name) {\n            return new Test(name);\n        }\n\n        public void test() {\n            System.out.println(name);\n        }\n\n        public static void main(String[] args) {\n            getInstance(\"str\").test();\n        }\n      }\n"
        },
        {
          "shortName": "ConstantDeclaredInInterface",
          "displayName": "Constant declared in interface",
          "enabled": false,
          "description": "Reports constants (`public static final` fields) declared in interfaces.\n\nSome coding standards require declaring constants in abstract classes instead."
        }
      ]
    },
    {
      "name": "Code style issues",
      "inspections": [
        {
          "shortName": "UnnecessaryQualifierForThis",
          "displayName": "Unnecessary qualifier for 'this' or 'super'",
          "enabled": false,
          "description": "Reports unnecessary qualification of `this` or `super`.\n\n\nUsing a qualifier on `this` or `super` to\ndisambiguate a code reference may easily become unnecessary via automatic refactorings and should be deleted for clarity.\n\n**Example:**\n\n\n      class Foo {\n        void foo() {}\n      }\n\n      class Bar extends Foo {\n        void bar() {\n          Bar.super.foo();\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      class Foo {\n        void foo() {}\n      }\n\n      class Bar extends Foo {\n        void bar() {\n          super.foo();\n        }\n      }\n"
        },
        {
          "shortName": "SizeReplaceableByIsEmpty",
          "displayName": "'size() == 0' can be replaced with 'isEmpty()'",
          "enabled": false,
          "description": "Reports `.size()` or `.length()` comparisons with a `0` literal that can be replaced with a call to `.isEmpty()`.\n\n**Example:**\n\n\n      boolean emptyList = list.size() == 0;\n\nAfter the quick-fix is applied:\n\n\n      boolean emptyList = list.isEmpty();\n      \n\nUse the **Ignored classes** table to add classes for which any `.size()` or `.length()` comparisons should not be replaced.\n\nUse the **Ignore expressions which would be replaced with `!isEmpty()`** option to ignore any expressions which would be replaced with `!isEmpty()`."
        },
        {
          "shortName": "ArrayCanBeReplacedWithEnumValues",
          "displayName": "Array can be replaced with enum values",
          "enabled": false,
          "description": "Reports arrays of enum constants that can be replaced with a call to `EnumType.values()`.\n\nUsually, when updating such an enum, you have to update the array as well. However, if you use `EnumType.values()`\ninstead, no modifications are required.\n\nExample:\n\n\n      enum States {\n         NOT_RUN, IN_PROGRESS, FINISHED;\n      }\n      \n      handleStates(new States[] {NOT_RUN, IN_PROGRESS, FINISHED});\n\nAfter the quick-fix is applied:\n\n\n      handleStates(States.values());\n\nNew in 2019.1"
        },
        {
          "shortName": "UnqualifiedStaticUsage",
          "displayName": "Unqualified static access",
          "enabled": false,
          "description": "Reports usage of static members that is not qualified with the class name.\n\n\nThis is legal if the static member is in\nthe same class, but may be confusing.\n\n**Example:**\n\n\n      class Foo {\n        static void foo() {}\n        static int x;\n\n        void bar() {\n          foo();\n          System.out.println(x);\n        }\n\n        static void baz() { foo(); }\n      }\n\nAfter the quick-fix is applied:\n\n\n      class Foo {\n        static void foo() {}\n        static int x;\n\n        void bar() {\n          Foo.foo();\n          System.out.println(Foo.x);\n        }\n\n        static void baz() { Foo.foo(); }\n      }\n\nUse the inspection settings to toggle the reporting for the following items:\n\n*\n  static fields access  \n\n  `void bar() { System.out.println(x); }`\n\n*\n  calls to static methods  \n\n  `void bar() { foo(); }`  \n\n  `static void baz() { foo(); }`\n\n\nYou can also configure the inspection to only report static member usage from a non-static context.\nIn the above example, `static void baz() { foo(); }` will not be reported."
        },
        {
          "shortName": "ControlFlowStatementWithoutBraces",
          "displayName": "Control flow statement without braces",
          "enabled": false,
          "description": "Reports any `if`, `while`, `do`, or `for` statements without braces. Some code styles, e.g. the [Google Java Style guide](https://google.github.io/styleguide/javaguide.html), require braces for all control statements.\n\n\nWhen adding further statements to control statements without braces, it is important not to forget adding braces.\nWhen commenting out a line of code, it is also necessary to be more careful when not using braces,\nto not inadvertently make the next statement part of the control flow statement.\nAlways using braces makes insertion or commenting out of a line of code safer.\n\n\nIt's likely the [goto fail vulnerability](https://www.imperialviolet.org/2014/02/22/applebug.html) would not have happened,\nif an always use braces code style was used.\nControl statements with braces make the control flow easier to see, without relying on, possibly incorrect, indentation.\n\nExample:\n\n\n      class Strange {\n        void x(boolean one, boolean two) {\n          if(one)\n            if(two)\n              foo();\n          else\n            bar();\n        }\n\n        void foo() {}\n        void bar() {}\n      }\n\nThe quick-fix wraps the statement body with braces:\n\n\n      class Strange {\n        void x(boolean one, boolean two) {\n          if(one) {\n            if(two) {\n              foo();\n            } else {\n              bar();\n            }\n          }\n        }\n\n        void foo() {}\n        void bar() {}\n      }\n"
        },
        {
          "shortName": "RedundantLabeledSwitchRuleCodeBlock",
          "displayName": "Labeled switch rule has redundant code block",
          "enabled": false,
          "description": "Reports labeled rules of `switch` statements or `switch` expressions that have a redundant code block.\n\nExample:\n\n\n      String s = switch (n) {\n        case 1 -> { yield Integer.toString(n); }\n        default -> \"default\";\n      };\n\nAfter the quick-fix is applied:\n\n\n      String s = switch (n) {\n        case 1 -> Integer.toString(n);\n        default -> \"default\";\n      };\n\nThis inspection only reports if the language level of the project or module is 14 or higher.\n\nNew in 2019.1"
        },
        {
          "shortName": "MultiCatchCanBeSplit",
          "displayName": "Multi-catch can be split into separate catch blocks",
          "enabled": false,
          "description": "Reports multi-`catch` sections and suggests splitting them into separate `catch` blocks.\n\nExample:\n\n\n      try {\n        int i = getIndex();\n      } catch (NullPointerException|IndexOutOfBoundsException e) {\n        e.printStackTrace();\n      }\n\nAfter the quick-fix is applied:\n\n\n      try {\n        int i = getIndex();\n      } catch (NullPointerException e) {\n        e.printStackTrace();\n      } catch (IndexOutOfBoundsException e) {\n        e.printStackTrace();\n      }\n\nThis inspection only reports if the language level of the project or module is 7 or higher."
        },
        {
          "shortName": "JoinDeclarationAndAssignmentJava",
          "displayName": "Assignment can be joined with declaration",
          "enabled": false,
          "description": "Reports variable assignments that can be joined with a variable declaration.\n\nExample:\n\n\n      int x;\n      x = 1;\n\nThe quick-fix converts the assignment into an initializer:\n\n\n      int x = 1;\n\nNew in 2018.3"
        },
        {
          "shortName": "UnnecessaryModifier",
          "displayName": "Unnecessary modifier",
          "enabled": false,
          "description": "Reports redundant modifiers and suggests to remove them. The resulting code will be shorter, but the behaviour and meaning will remain the same.\n\nExample 1:\n\n\n      // all code is implicitly strictfp under Java 17 and higher\n      strictfp class X {\n\n        // inner enums are implicitly static\n        static enum Inner {\n            A, B, C\n        }\n\n        // inner records are implicitly static\n        static record R() {\n        }\n      }\n\nExample 2:\n\n\n      final record R() {\n        // all records are implicitly final\n      }\n\n**Example 3:**\n\n\n      // all interfaces are implicitly abstract\n      abstract interface Printer {\n\n        // all interface members are implicitly public\n        public int size();\n\n        // all inner classes of interfaces are implicitly static\n        static class Inner {}\n      }\n"
        },
        {
          "shortName": "CStyleArrayDeclaration",
          "displayName": "C-style array declaration",
          "enabled": false,
          "description": "Reports array declarations written in C-style syntax in which the array indicator brackets are placed after the variable name or after the method parameter list.\n\nExample:\n\n\n      public String process(String value[])[] {\n        return value;\n      }\n\nMost code styles prefer Java-style array declarations in which the array indicator brackets are attached to the type name, for example:\n\n\n      public String[] process(String[] value) {\n        return value;\n      }\n\nConfigure the inspection:\n\n\nUse the **Ignore C-style declarations in variables** option to report C-style array declaration of method return types only."
        },
        {
          "shortName": "UnnecessaryConstructor",
          "displayName": "Redundant no-arg constructor",
          "enabled": false,
          "description": "Reports unnecessary constructors.\n\n\nA constructor is unnecessary if it is the only constructor of a class, has no parameters,\nhas the same access modifier as its containing class,\nand does not perform any initialization except explicitly or implicitly calling the superclass constructor without arguments.\nSuch a constructor can be safely removed as it will be generated by the compiler even if not specified.\n\n**Example:**\n\n\n      public class Foo {\n        public Foo() {}\n      }\n\nAfter the quick-fix is applied:\n\n\n      public class Foo {}\n\n\nUse the inspection settings to ignore unnecessary constructors that have an annotation."
        },
        {
          "shortName": "CallToStringConcatCanBeReplacedByOperator",
          "displayName": "Call to 'String.concat()' can be replaced with '+'",
          "enabled": false,
          "description": "Reports calls to `java.lang.String.concat()`.\n\n\nSuch calls can be replaced with the `+` operator for clarity and possible increased\nperformance if the method was invoked on a constant with a constant argument.\n\n**Example:**\n\n\n      String foo(String name) {\n        return name.concat(\"foo\");\n      }\n\nAfter the quick-fix is applied:\n\n\n      String foo(String name) {\n        return name + \"foo\";\n      }\n"
        },
        {
          "shortName": "ListIndexOfReplaceableByContains",
          "displayName": "'List.indexOf()' expression can be replaced with 'contains()'",
          "enabled": false,
          "description": "Reports any `List.indexOf()` expressions that can be replaced with the `List.contains()` method.\n\nExample:\n\n\n      boolean hasEmptyString(List<String> list) {\n        // Warning: can be simplified\n        return list.indexOf(\"\") >= 0;\n      }\n\nThe provided quick-fix replaces the `indexOf` call with the `contains` call:\n\n\n      boolean hasEmptyString(List<String> list) {\n        // Quick-fix is applied\n        return list.contains(\"\");\n      }\n"
        },
        {
          "shortName": "UnnecessaryParentheses",
          "displayName": "Unnecessary parentheses",
          "enabled": false,
          "description": "Reports any instance of unnecessary parentheses.\n\nParentheses are considered unnecessary if the evaluation order of an expression remains\nunchanged after you remove the parentheses.\n\nExample:\n\n\n      int n = 3 + (9 * 8);\n\nAfter quick-fix is applied:\n\n\n      int n = 3 + 9 * 8;\n\nConfigure the inspection:\n\n* Use the **Ignore clarifying parentheses** option to ignore parentheses that help clarify a binary expression. Parentheses are clarifying if the parenthesized expression is an `instanceof` expression that is a part of a larger expression or has a different operator than the parent expression.\n* Use the **Ignore parentheses around the condition of conditional expressions** option to ignore any parentheses around the condition of conditional expressions. Some coding standards specify that all such conditions must be surrounded by parentheses.\n* Use the **Ignore parentheses around single no formal type lambda parameter** option to ignore parentheses around a single lambda parameter within a lambda expression."
        },
        {
          "shortName": "NestedMethodCall",
          "displayName": "Nested method call",
          "enabled": false,
          "description": "Reports method calls used as parameters to another method call.\n\nThe quick-fix introduces a variable to make the code simpler and easier to debug.\n\n**Example:**\n\n\n      public int y() { return 1; }\n      public int f(int x) { return 2 * x; }\n\n      public void foo() {\n          int x = f(y());\n      }\n\nAfter the quick-fix is applied:\n\n\n      public int y() { return 1; }\n      public int f(int x) { return 2 * x; }\n\n      public void foo() {\n          int y = y();\n          int x = f(y);\n      }\n\n\nUse the inspection options to toggle the reporting of:\n\n* method calls in field initializers\n* calls to static methods\n* calls to simple getters"
        },
        {
          "shortName": "RecordCanBeClass",
          "displayName": "Record can be converted to class",
          "enabled": false,
          "description": "Reports record classes and suggests converting them to ordinary classes.\n\nThis inspection makes it possible to move a Java record to a codebase using an earlier Java version\nby applying the quick-fix to this record.\n\n\nNote that the resulting class is not completely equivalent to the original record:\n\n* The resulting class no longer extends `java.lang.Record`, so `instanceof Record` returns `false`.\n* Reflection methods like `Class.isRecord()` and `Class.getRecordComponents()` produce different results.\n* The generated `hashCode()` implementation may produce a different result because the formula to calculate record `hashCode` is deliberately not specified.\n* Record serialization mechanism differs from that of an ordinary class. Refer to *Java Object Serialization Specification* for details.\n\nExample:\n\n\n      record Point(int x, int y) {}\n\nAfter the quick-fix is applied:\n\n\n      final class Point {\n        private final int x;\n        private final int y;\n\n        Point(int x, int y) {\n          this.x = x;\n          this.y = y;\n        }\n\n        public int x() { return x; }\n\n        public int y() { return y; }\n\n        @Override\n        public boolean equals(Object obj) {\n          if (obj == this) return true;\n          if (obj == null || obj.getClass() != this.getClass()) return false;\n          var that = (Point)obj;\n          return this.x == that.x &&\n                 this.y == that.y;\n        }\n\n        @Override\n        public int hashCode() {\n          return Objects.hash(x, y);\n        }\n\n        @Override\n        public String toString() {\n          return \"Point[\" +\n                 \"x=\" + x + \", \" +\n                 \"y=\" + y + ']';\n        }\n      }\n\nThis inspection only reports if the language level of the project or module is 16 higher.\n\nNew in 2020.3"
        },
        {
          "shortName": "FuseStreamOperations",
          "displayName": "Subsequent steps can be fused into Stream API chain",
          "enabled": false,
          "description": "Detects transformations outside a Stream API chain that could be incorporated into it.\n\nExample:\n\n\n      List<String> list = stream.collect(Collectors.toList());\n      list.sort(null);\n      return list.toArray(new String[list.size()]);\n\nAfter the conversion:\n\n\n      return stream.sorted().toArray(String[]::new);\n\n\nNote that sometimes the converted stream chain may replace explicit `ArrayList` with `Collectors.toList()` or explicit\n`HashSet` with `Collectors.toSet()`. The current library implementation uses these collections internally. However,\nthis approach is not very reliable and might change in the future altering the semantics of your code.\n\nIf you are concerned about it, use the **Do not suggest 'toList()' or 'toSet()' collectors** option to suggest\n`Collectors.toCollection()` instead of `toList` and `toSet` collectors.\n\nThis inspection only reports if the language level of the project or module is 8 or higher."
        },
        {
          "shortName": "LocalCanBeFinal",
          "displayName": "Local variable or parameter can be 'final'",
          "enabled": false,
          "description": "Reports parameters or local variables found in the specified inspection scope to which the `final` modifier can be added.\n\nExample:\n\n\n      ArrayList<Integer> list = new ArrayList();\n      fill(list);\n      return list;\n\nAfter the quick-fix is applied:\n\n\n      final ArrayList<Integer> list = new ArrayList();\n      fill(list);\n      return list;\n\n\nUse the inspection's options to define whether parameters or local variables should be reported."
        },
        {
          "shortName": "UnnecessarilyQualifiedStaticUsage",
          "displayName": "Unnecessarily qualified static access",
          "enabled": false,
          "description": "Reports usages of static members qualified with the class name.\n\n\nSuch qualification is unnecessary and may be safely removed.\n\n**Example:**\n\n\n      class Foo {\n        static void foo() {}\n        static int x;\n\n        void bar() {\n          Foo.foo();\n          System.out.println(Foo.x);\n        }\n\n        static void baz() { Foo.foo(); }\n      }\n\nAfter the quick-fix is applied:\n\n\n      class Foo {\n        static void foo() {}\n        static int x;\n\n        void bar() {\n          foo();\n          System.out.println(x);\n        }\n\n        static void baz() { foo(); }\n      }\n\n\nUse the inspection options to toggle the reporting for:\n\n* Static fields access:  \n  `void bar() { System.out.println(Foo.x); }`\n\n* Calls to static methods:  \n  `void bar() { Foo.foo(); }`\n\n\nAlso, you can configure the inspection to only report static member usage\nin a static context. In this case, only `static void baz() { Foo.foo(); }` will be reported."
        },
        {
          "shortName": "TryStatementWithMultipleResources",
          "displayName": "'try' statement with multiple resources can be split",
          "enabled": false,
          "description": "Reports `try` statements with multiple resources that can be automatically split into multiple try-with-resources statements.\n\nThis conversion can be useful for further refactoring\n(for example, for extracting the nested `try` statement into a separate method).\n\nExample:\n\n\n      try (FileInputStream in = new FileInputStream(\"in.txt\");\n         FileOutputStream out = new FileOutputStream(\"out.txt\")) {\n         /*read and write*/\n      }\n\nAfter the quick-fix is applied:\n\n\n      try (FileInputStream in = new FileInputStream(\"in.txt\")) {\n        try (FileOutputStream out = new FileOutputStream(\"out.txt\")) {\n          /*read and write*/\n        }\n      }\n"
        },
        {
          "shortName": "LambdaParameterTypeCanBeSpecified",
          "displayName": "Lambda parameter type can be specified",
          "enabled": false,
          "description": "Reports lambda parameters that do not have their type specified and suggests adding the missing type declarations.\n\nExample:\n\n\n      Function<String, Integer> length = a -> a.length();\n\nAfter the quick-fix is applied:\n\n\n      Function<String, Integer> length = (String a) -> a.length();\n\nThis inspection only reports if the language level of the project or module is 8 or higher."
        },
        {
          "shortName": "ReturnThis",
          "displayName": "Return of 'this'",
          "enabled": false,
          "description": "Reports methods returning `this`.\n\n\nWhile such a return is valid, it is rarely necessary, and usually indicates that the method is intended to be used\nas part of a chain of similar method calls (for example, `buffer.append(\"foo\").append(\"bar\").append(\"baz\")`).\nSuch chains are frowned upon by many coding standards.\n\n**Example:**\n\n\n      public Builder append(String str) {\n        // [...]\n        return this;\n      }\n"
        },
        {
          "shortName": "UnnecessarilyQualifiedInnerClassAccess",
          "displayName": "Unnecessarily qualified inner class access",
          "enabled": false,
          "description": "Reports any references to inner classes that are unnecessarily qualified with the name of the enclosing class.\n\nSuch a qualification can be safely removed, which sometimes adds an import for the inner class.\n\nExample:\n\n\n      class X {\n         X.Y foo;\n         class Y{}\n      }\n\nAfter the quick-fix is applied:\n\n\n      class X {\n         Y foo;\n         class Y{}\n      }\n\nUse the **Ignore references for which an import is needed** option to ignore references to inner classes, where\nremoving the qualification adds an import."
        },
        {
          "shortName": "ChainedEquality",
          "displayName": "Chained equality comparisons",
          "enabled": false,
          "description": "Reports chained equality comparisons.\n\nSuch comparisons may be confusing: `a == b == c` means `(a == b) == c`,\nbut possibly `a == b && a == c` is intended.\n\n**Example:**\n\n\n      boolean chainedEquality(boolean a, boolean b, boolean c) {\n        return a == b == c;\n      }\n\nYou can use parentheses to make the comparison less confusing:\n\n\n      boolean chainedEquality(boolean a, boolean b, boolean c) {\n        return (a == b) == c;\n      }\n"
        },
        {
          "shortName": "RedundantFieldInitialization",
          "displayName": "Redundant field initialization",
          "enabled": false,
          "description": "Reports fields explicitly initialized to their default values.\n\n**Example:**\n\n\n      class Foo {\n        int foo = 0;\n        List bar = null;\n      }\n\nAfter the quick-fix is applied:\n\n\n      class Foo {\n        int foo;\n        List bar;\n      }\n\n\nUse the inspection settings to only report explicit `null` initialization, for example:\n\n\n      class Foo {\n        int foo = 0;     // no warning\n        List bar = null; // redundant field initialization warning\n      }\n"
        },
        {
          "shortName": "SimplifiableEqualsExpression",
          "displayName": "Unnecessary 'null' check before 'equals()' call",
          "enabled": false,
          "description": "Reports comparisons to `null` that are followed by a call to `equals()` with a constant argument.\n\n**Example:**\n\n\n      if (s != null && s.equals(\"literal\")) {}\n\nAfter the quick-fix is applied:\n\n\n      if (\"literal\".equals(s)) {}\n\n\nUse the inspection settings to report `equals()` calls with a non-constant argument\nwhen the argument to `equals()` is proven not to be `null`."
        },
        {
          "shortName": "MultipleVariablesInDeclaration",
          "displayName": "Multiple variables in one declaration",
          "enabled": false,
          "description": "Reports multiple variables that are declared in a single declaration and suggest creating a separate declaration for each variable.\n\nSome coding standards prohibit such declarations.\n\nExample:\n\n\n      int x = 1, y = 2;\n\nAfter the quick-fix is applied:\n\n\n      int x = 1;\n      int y = 2;\n\nConfigure the inspection:\n\n* Use the **Ignore 'for' loop declarations** option to ignore multiple variables declared in the initialization of a 'for' loop statement, for example:\n\n\n        for (int i = 0, max = list.size(); i > max; i++) {}\n\n* Use the **Only warn on different array dimensions in a single declaration** option to only warn when variables with different array dimensions are declared in a single declaration, for example:\n\n\n        String s = \"\", array[];\n\nNew in 2019.2"
        },
        {
          "shortName": "SimplifiableAnnotation",
          "displayName": "Simplifiable annotation",
          "enabled": false,
          "description": "Reports annotations that can be simplified to their 'single element' or 'marker' shorthand form.\n\nAnnotations that contain whitespace between the @-sign and the name\nof the annotation are also reported.\n\n**Example:**\n\n\n      @interface Foo { String[] value(); }\n\n      @ Foo({\"foo\"})\n      public String name;\n\nAfter the quick-fix is applied:\n\n\n      @interface Foo { String[] value(); }\n\n      @Foo(\"foo\")\n      public String name;\n"
        },
        {
          "shortName": "ImplicitCallToSuper",
          "displayName": "Implicit call to 'super()'",
          "enabled": false,
          "description": "Reports constructors that do not begin with a call to \"super\" constructor or another constructor of the same class.\n\nSuch constructors can be thought of as implicitly beginning with a\ncall to `super()`. Some coding standards prefer that such calls to\n`super()` be made explicitly.\n\n**Example:**\n\n\n      class Foo {\n        Foo() {}\n      }\n\nAfter the quick-fix is applied:\n\n\n      class Foo {\n        Foo() {\n          super();\n        }\n      }\n\n\nUse the inspection settings to ignore classes extending directly from `Object`.\nFor instance:\n\n\n      class Foo {\n        Foo() {} // Not reported\n      }\n\n      class Bar extends Foo {\n        Bar() {} // Implicit call to 'super()'\n      }\n"
        },
        {
          "shortName": "UnnecessaryThis",
          "displayName": "Unnecessary 'this' qualifier",
          "enabled": false,
          "description": "Reports unnecessary `this` qualifier.\n\n\nUsing `this` to disambiguate a code reference is discouraged by many coding styles\nand may easily become unnecessary\nvia automatic refactorings.\n\n**Example:**\n\n\n      class Foo {\n        int x;\n        void foo() {\n          this.x = 2;\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      class Foo {\n        int x;\n        void foo() {\n          x = 2;\n        }\n      }\n\n\nUse the inspection settings to ignore assignments to fields.\nFor instance, `this.x = 2;` won't be reported, but `int y = this.x;` will be."
        },
        {
          "shortName": "UnnecessarySemicolon",
          "displayName": "Unnecessary semicolon",
          "enabled": false,
          "description": "Reports any unnecessary semicolons, including semicolons that are used between class members, inside block statements, or after class definitions.\n\nEven though these semicolons are valid in Java, they are redundant and may be removed.\n\nExample:\n\n\n      class C {\n        ;\n        void m() throws Exception {\n            try (AutoCloseable r1 = createAutoCloseable();) {\n              ;\n            }\n        }\n        ;\n      }\n\nAfter the quick-fix is applied:\n\n\n      class C {\n        void m() throws Exception {\n          try (AutoCloseable r1 = createAutoCloseable()) {\n          }\n        }\n      }\n"
        },
        {
          "shortName": "SingleStatementInBlock",
          "displayName": "Code block contains single statement",
          "enabled": false,
          "description": "Reports control flow statements with a single statement in their code block and suggests removing the braces from the control flow statement body.\n\nExample:\n\n\n      if (x > 0) {\n        System.out.println(\"x is positive\");\n      }\n\nAfter the quick-fix is applied:\n\n\n      if (x > 0) System.out.println(\"x is positive\");\n"
        },
        {
          "shortName": "ExtendsObject",
          "displayName": "Class explicitly extends 'Object'",
          "enabled": false,
          "description": "Reports any classes that are explicitly declared to extend `java.lang.Object`.\n\nSuch declaration is redundant and can be safely removed.\n\nExample:\n\n\n      class MyClass extends Object {\n      }\n\nThe quick-fix removes the redundant `extends Object` clause:\n\n\n      class MyClass {\n      }\n"
        },
        {
          "shortName": "LiteralAsArgToStringEquals",
          "displayName": "String literal may be 'equals()' qualifier",
          "enabled": false,
          "description": "Reports `String.equals()` or `String.equalsIgnoreCase()` calls with a string literal argument.\n\nSome coding standards specify that string literals should be the qualifier of `equals()`, rather than\nargument, thus minimizing `NullPointerException`-s.\n\nA quick-fix is available to exchange the literal and the expression.\n\n**Example:**\n\n\n      boolean isFoo(String value) {\n        return value.equals(\"foo\");\n      }\n\nAfter the quick-fix is applied:\n\n\n      boolean isFoo(String value) {\n        return \"foo\".equals(value);\n      }\n"
        },
        {
          "shortName": "UnnecessarySuperQualifier",
          "displayName": "Unnecessary 'super' qualifier",
          "enabled": false,
          "description": "Reports unnecessary `super` qualifiers in method calls and field references.\n\n\nA `super` qualifier is unnecessary\nwhen the field or method of the superclass is not hidden/overridden in the calling class.\n\n**Example:**\n\n\n      class Foo {\n        void foo() {}\n      }\n\n      class Bar extends Foo {\n        void bar() {\n          super.foo();\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      class Foo {\n        void foo() {}\n      }\n\n      class Bar extends Foo {\n        void bar() {\n          foo();\n        }\n      }\n\n\nUse the inspection settings to ignore qualifiers that help to distinguish superclass members access\nfrom the identically named members of the outer class.\n\n\nSee also the following inspections:\n\n* *Java \\| Visibility \\| Access to inherited field looks like access to element from surrounding code*\n* *Java \\| Visibility \\| Call to inherited method looks like call to local method*"
        },
        {
          "shortName": "UnclearBinaryExpression",
          "displayName": "Multiple operators with different precedence",
          "enabled": false,
          "description": "Reports binary, conditional, or `instanceof` expressions that consist of different operators without parentheses. Such expressions can be less readable due to different precedence rules of operators.\n\nExample:\n\n\n      int n = 3 + 9 * 8 + 1;\n\nAfter quick-fix is applied:\n\n\n      int n = 3 + (9 * 8) + 1;\n"
        },
        {
          "shortName": "ChainedMethodCall",
          "displayName": "Chained method calls",
          "enabled": false,
          "description": "Reports method calls whose target is another method call. The quick-fix suggests to introduce a local variable.\n\n**Example:**\n\n\n      class X {\n        int foo(File f) {\n          return f.getName().length();\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      class X {\n        int foo(File f) {\n          final String name = f.getName();\n          return name.length();\n        }\n      }\n\nUse the inspection options to toggle warnings for the following cases:\n\n*\n  chained method calls in field initializers,\n  for instance, `private final int i = new Random().nextInt();`\n\n*\n  chained method calls operating on the same type,\n  for instance, `new StringBuilder().append(\"x: \").append(new X()).append(\"y: \").append(new Y()).toString();`."
        },
        {
          "shortName": "AssertMessageNotString",
          "displayName": "'assert' message is not a string",
          "enabled": false,
          "description": "Reports `assert` messages that are not of the `java.lang.String` type.\n\nUsing a string provides more information to help diagnose the failure\nor the assertion reason.\n\n**Example:**\n\n\n      void foo(List<Integer> myList) {\n        assert myList.isEmpty() : false;\n      }\n\n\nUse the **Only warn when the `assert` message type is 'boolean' or 'java.lang.Boolean'** option to only warn when the `assert` message type is `boolean` or `java.lang.Boolean`.\nA `boolean` detail message is unlikely to provide additional information about an assertion failure\nand could result from a mistakenly entered `:` instead of `&`."
        },
        {
          "shortName": "MethodRefCanBeReplacedWithLambda",
          "displayName": "Method reference can be replaced with lambda",
          "enabled": false,
          "description": "Reports method references, like `MyClass::myMethod` and `myObject::myMethod`, and suggests replacing them with an equivalent lambda expression.\n\nLambda expressions can be easier to modify than method references.\n\nExample:\n\n\n      System.out::println\n\nAfter the quick-fix is applied:\n\n\n      s -> System.out.println(s)\n\nBy default, this inspection does not highlight the code in the editor, but only provides a quick-fix."
        },
        {
          "shortName": "UnnecessaryFullyQualifiedName",
          "displayName": "Unnecessary fully qualified name",
          "enabled": false,
          "description": "Reports fully qualified class names that can be shortened.\n\nThe quick-fix shortens fully qualified names and adds import statements if necessary.\n\nExample:\n\n\n      class ListWrapper {\n        java.util.List<Integer> l;\n      }\n\nAfter the quick-fix is applied:\n\n\n      import java.util.List;\n      class ListWrapper {\n        List<Integer> l;\n      }\n\nConfigure the inspection:\n\n\nUse the **Ignore in Java 9 module statements** option to ignore fully qualified names inside the Java 9\n`provides` and `uses` module statements.\n\n\nIn [Settings \\| Editor \\| Code Style \\| Java \\| Imports](settings://preferences.sourceCode.Java?JavaDoc%20Inner),\nuse the following options to configure the inspection:\n\n* Use the **Insert imports for inner classes** option if references to inner classes should be qualified with the outer class.\n* Use the **Use fully qualified class names in JavaDoc** option to allow fully qualified names in Javadocs."
        },
        {
          "shortName": "LambdaBodyCanBeCodeBlock",
          "displayName": "Lambda body can be code block",
          "enabled": false,
          "description": "Reports lambdas whose body is an expression and suggests converting expression bodies to code blocks.\n\nExample:\n\n\n      n -> n + 1\n\nAfter the quick-fix is applied:\n\n    n -> {\n      return n + 1;\n    }\n"
        },
        {
          "shortName": "SwitchLabeledRuleCanBeCodeBlock",
          "displayName": "Labeled switch rule can have code block",
          "enabled": false,
          "description": "Reports rules of `switch` expressions or enhanced `switch` statements with an expression body. These can be converted to code blocks.\n\nExample:\n\n\n      String message = switch (errorCode) {\n        case 404 -> \"Not found!\";\n        ...\n      };\n\nAfter the quick-fix is applied:\n\n\n      String message = switch (errorCode) {\n        case 404 -> {\n                    yield \"Not found!\";\n                }\n        ...\n      };\n\nThe inspection only reports if the language level of the project or module is 14 or higher.\n\nNew in 2019.1"
        },
        {
          "shortName": "MoveFieldAssignmentToInitializer",
          "displayName": "Field assignment can be moved to initializer",
          "enabled": false,
          "description": "Suggests replacing initializations of a field via assignment with field initializers.\n\nThe code is highlighted only if the field initializer is located in the initializer, and\njoining it with the field declaration is likely to be safe.\nIn other cases, the inspection provides a quick-fix without code highlighting, as the fix may change the code semantics.\n\nExample:\n\n\n      class MyClass {\n        static final int intConstant;\n        \n        static {\n          intConstant = 10;\n        }\n      }\n\nThe quick fix moves the assigned value to the field initializer removing the class initializer section if possible:\n\n\n      class MyClass {\n        static final int intConstant = 10;\n      }\n\nSince 2017.2"
        },
        {
          "shortName": "UnqualifiedInnerClassAccess",
          "displayName": "Unqualified inner class access",
          "enabled": false,
          "description": "Reports references to inner classes that are not qualified with the name of the enclosing class.\n\n**Example:**\n\n\n      import foo.Foo.Bar;\n\n      class Foo {\n        class Bar {}\n      }\n\n      class Baz {\n        void f(Bar bar) {}\n      }\n\nAfter the quick-fix is applied:\n\n\n      class Foo {\n        class Bar {}\n      }\n\n      class Baz {\n        void f(Foo.Bar bar) {}\n      }\n\n\nUse the inspection settings to ignore references to inner classes within the same class,\nwhich therefore do not require an import."
        },
        {
          "shortName": "BlockMarkerComments",
          "displayName": "Block marker comment",
          "enabled": false,
          "description": "Reports comments which are used as code block markers. The quick-fix removes such comments.\n\nExample:\n\n\n      while (i < 10) {\n        i++;\n      } // end while\n\nAfter the quick-fix is applied:\n\n\n      while (i < 10) {\n        i++;\n      }\n"
        },
        {
          "shortName": "OptionalIsPresent",
          "displayName": "Non functional style 'Optional.isPresent()' usage",
          "enabled": false,
          "description": "Reports conditions, like `if(Optional.isPresent())`, that can be rewritten in the functional style, as it is shorter and easier to read.\n\nExample:\n\n\n      if (str.isPresent()) str.get().trim();\n\nAfter the quick-fix is applied:\n\n\n      str.ifPresent(String::trim);\n\nThis inspection only reports if the language level of the project or module is 8 or higher."
        },
        {
          "shortName": "ObjectsEqualsCanBeSimplified",
          "displayName": "'Objects.equals()' can be replaced with 'equals()'",
          "enabled": false,
          "description": "Reports calls to `Objects.equals(a, b)` in which the first argument is statically known to be non-null.\n\nSuch a call can be safely replaced with `a.equals(b)` or `a == b` if both arguments are primitives.\n\nExample:\n\n\n      String defaultName = \"default\";\n      boolean isDefault = Objects.equals(defaultName, name);\n\nAfter the quick-fix is applied:\n\n\n      String defaultName = \"default\";\n      boolean isDefault = defaultName.equals(name);\n\nNew in 2018.3"
        },
        {
          "shortName": "SimplifiableIfStatement",
          "displayName": "'if' statement can be replaced with conditional or boolean expression",
          "enabled": false,
          "description": "Reports `if` statements that can be replaced with conditions using the `&&`, `||`, `==`, `!=`, or `?:` operator.\n\nThe result is usually shorter, but not always clearer, so it's not advised to apply the fix in every case.\n\nExample:\n\n\n      if (condition) return true; else return foo;\n\nAfter the quick-fix is applied:\n\n\n      return condition || foo;\n\nConfigure the inspection:\n\n* Use the **Don't suggest '?:' operator** option to disable the warning when the `?:` operator is suggested. In this case, only `&&`, `||`, `==`, and `!=` suggestions will be highlighted. The quick-fix will still be available in the editor.\n* Use the **Ignore chained 'if' statements** option to disable the warning for `if-else` chains. The quick-fix will still be available in the editor.\n\nNew in 2018.2"
        },
        {
          "shortName": "EqualsCalledOnEnumConstant",
          "displayName": "'equals()' called on enum value",
          "enabled": false,
          "description": "Reports `equals()` calls on enum constants.\n\nSuch calls can be replaced by an identity comparison (`==`) because two\nenum constants are equal only when they have the same identity.\n\nA quick-fix is available to change the call to a comparison.\n\n**Example:**\n\n\n      boolean foo(MyEnum value) {\n        return value.equals(MyEnum.FOO);\n      }\n\nAfter the quick-fix is applied:\n\n\n      boolean foo(MyEnum value) {\n        return value == MyEnum.FOO;\n      }\n"
        },
        {
          "shortName": "UnnecessaryConstantArrayCreationExpression",
          "displayName": "Redundant 'new' expression in constant array creation",
          "enabled": false,
          "description": "Reports constant new array expressions that can be replaced with an array initializer. Array initializers can omit the type because it is already specified in the left side of the assignment.\n\n**Example:**\n\n\n      int[] foo = new int[] {42};\n\nAfter the quick-fix is applied:\n\n\n      int[] foo = {42};\n"
        },
        {
          "shortName": "OptionalContainsCollection",
          "displayName": "'Optional' contains array or collection",
          "enabled": false,
          "description": "Reports `java.util.Optional` or `com.google.common.base.Optional` types with an array or collection type parameter.\n\nIn such cases, it is more clear to just use an empty array or collection to indicate the absence of result.\n\n**Example:**\n\n\n      Optional<List<Integer>> foo() {\n        return Optional.empty();\n      }\n\nThis code could look like:\n\n\n      List<Integer> foo() {\n        return new List<>();\n      }\n      \n"
        },
        {
          "shortName": "CharsetObjectCanBeUsed",
          "displayName": "Standard 'Charset' object can be used",
          "enabled": false,
          "description": "Reports methods and constructors in which constant charset `String` literal (for example, `\"UTF-8\"`) can be replaced with the predefined `StandardCharsets.UTF_8` code.\n\nThe code after the fix may work faster, because the charset lookup becomes unnecessary.\nAlso, catching `UnsupportedEncodingException` may become unnecessary as well. In this case,\nthe catch block will be removed automatically.\n\nExample:\n\n\n      try {\n        byte[] bytes = \"str\".getBytes(\"UTF-8\");\n      } catch (UnsupportedEncodingException e) {\n      }\n\nAfter quick-fix is applied:\n\n\n      byte[] bytes = \"str\".getBytes(StandardCharsets.UTF_8);\n\nThe inspection is available in Java 7 and later.\n\nNew in 2018.2"
        },
        {
          "shortName": "ArrayCreationWithoutNewKeyword",
          "displayName": "Array creation without 'new' expression",
          "enabled": false,
          "description": "Reports array initializers without `new` array expressions and suggests adding them.\n\nExample:\n\n\n      int[] a = {42}\n\nAfter the quick-fix is applied:\n\n\n      int[] a = new int[]{42}\n"
        },
        {
          "shortName": "ConfusingOctalEscape",
          "displayName": "Confusing octal escape sequence",
          "enabled": false,
          "description": "Reports string literals containing an octal escape sequence immediately followed by a digit.\n\nSuch strings may be confusing, and are often the result of errors in escape code creation.\n\n**Example:**\n\n\n      System.out.println(\"\\1234\"); // Octal escape sequence '\\123' immediately followed by a digit\n"
        },
        {
          "shortName": "MissortedModifiers",
          "displayName": "Missorted modifiers",
          "enabled": false,
          "description": "Reports declarations whose modifiers are not in the canonical preferred order (as stated in the Java Language Specification).\n\n**Example:**\n\n\n      class Foo {\n        native public final void foo();\n      }\n\nAfter the quick-fix is applied:\n\n\n      class Foo {\n        public final native void foo();\n      }\n\nUse the inspection settings to:\n\n*\n  toggle the reporting of misplaced annotations:\n  (annotations with `ElementType.TYPE_USE` *not* directly\n  before the type and after the modifier keywords, or\n  other annotations *not* before the modifier keywords).\n  When this option is disabled, any annotation can be positioned before or after the modifier keywords.\n  Modifier lists with annotations in between the modifier keywords will always be reported.\n\n*\n  specify whether the `ElementType.TYPE_USE` annotation should be positioned directly before\n  a type, even when the annotation has other targets specified."
        },
        {
          "shortName": "TypeParameterExtendsObject",
          "displayName": "Type parameter explicitly extends 'Object'",
          "enabled": false,
          "description": "Reports type parameters and wildcard type arguments that are explicitly declared to extend `java.lang.Object`.\n\nSuch 'extends' clauses are redundant as `java.lang.Object` is a supertype for all classes.\n\n**Example:**\n\n      class ClassA<T extends Object> {}\n\n\nIf you need to preserve the 'extends Object' clause because of annotations, disable the\n**Ignore when java.lang.Object is annotated** option.\nThis might be useful, for example, when you use a nullness analyzer, and the 'extends Object' clause\nholds a `@Nullable`/`@NotNull` annotation.\n\n**Example:**\n\n      class MyClass<T extends @NotNull Object> {}\n"
        },
        {
          "shortName": "UnnecessaryToStringCall",
          "displayName": "Unnecessary call to 'toString()'",
          "enabled": false,
          "description": "Reports calls to `toString()` that are used in the following cases:\n\n* In string concatenations\n* In the `java.lang.StringBuilder#append()` or `java.lang.StringBuffer#append()` methods\n* In the methods of `java.io.PrintWriter` or `java.io.PrintStream`\n* in the methods `org.slf4j.Logger`\n\nIn these cases, conversion to string will be handled by the underlying library methods, and the explicit call to `toString()` is not needed.\n\nExample:\n\n\n      System.out.println(this.toString())\n\nAfter the quick-fix is applied:\n\n\n      System.out.println(this)\n\n\nNote that without the `toString()` call, the code semantics might be different: if the expression is null,\nthen the `null` string will be used instead of throwing a `NullPointerException`.\n\nUse the **Report only when qualifier is known to be not-null** option to avoid warnings for the values that could potentially be null."
        },
        {
          "shortName": "ReturnSeparatedFromComputation",
          "displayName": "'return' separated from the result computation",
          "enabled": false,
          "description": "Reports `return` statements that return a local variable where the value of the variable is computed somewhere else within the same method.\n\nThe quick-fix inlines the returned variable by moving the return statement to the location in which the value\nof the variable is computed.\nWhen the returned value can't be inlined into the `return` statement,\nthe quick-fix attempts to move the return statement as close to the computation of the returned value as possible.\n\nExample:\n\n\n      int n = -1;\n      for (int i = 0; i < a.length; i++) {\n        if (a[i] == b) {\n          n = i;\n          break;\n        }\n      }\n      return n;\n\nAfter the quick-fix is applied:\n\n\n      int n = -1;\n      for (int i = 0; i < a.length; i++) {\n        if (a[i] == b) {\n          return i;\n        }\n      }\n      return n;\n"
        },
        {
          "shortName": "FillPermitsList",
          "displayName": "Same file subclasses are missing from permits clause of a sealed class",
          "enabled": false,
          "description": "Reports sealed classes whose permits clauses do not contain some of the subclasses from the same file.\n\nExample:\n\n\n      sealed class A {}\n      final class B extends A {}\n\nAfter the quick-fix is applied:\n\n\n      sealed class A permits B {}\n      final class B extends A {}\n\nNew in 2020.3"
        },
        {
          "shortName": "UnqualifiedFieldAccess",
          "displayName": "Instance field access not qualified with 'this'",
          "enabled": false,
          "description": "Reports field access operations that are not qualified with `this` or some other qualifier.\n\n\nSome coding styles mandate that all field access operations are qualified to prevent confusion with local\nvariable or parameter access.\n\n**Example:**\n\n\n      class Foo {\n        int foo;\n\n        void bar() {\n          foo += 1;\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      class Foo {\n        int foo;\n\n        void bar() {\n          this.foo += 1;\n        }\n      }\n"
        },
        {
          "shortName": "UnnecessaryCallToStringValueOf",
          "displayName": "Unnecessary conversion to 'String'",
          "enabled": false,
          "description": "Reports calls to static methods like `String.valueOf()` or `Integer.toString()` when they are used in a string concatenation or as an argument of a library method in which the explicit string conversion is not needed.\n\nExample:\n\n\n      System.out.println(\"Number: \" + Integer.toString(count));\n\nAfter the quick-fix is applied:\n\n\n      System.out.println(\"Number: \" + count);\n\nLibrary methods in which explicit string conversion is considered redundant:\n\n* Classes `java.io.PrintWriter`, `java.io.PrintStream`\n  * `print()`, `println()`\n* Classes `java.lang.StringBuilder`, `java.lang.StringBuffer`\n  * `append()`\n* Class `org.slf4j.Logger`\n  * `trace()`, `debug()`, `info()`, `warn()`, `error()`"
        },
        {
          "shortName": "ConstantOnWrongSideOfComparison",
          "displayName": "Constant on wrong side of comparison",
          "enabled": false,
          "description": "Reports comparison operations where the constant value is on the wrong side.\n\nSome coding conventions specify that constants should be on a specific side of a comparison, either left or right.\n\n**Example:**\n\n\n      boolean compare(int x) {\n        return 1 > x; // Constant '1' on the left side of the comparison\n      }\n\nAfter the quick-fix is applied:\n\n\n      boolean compare(int x) {\n        return x < 1;\n      }\n\n\nUse the inspection settings to choose the side of constants in comparisons\nand whether to warn if `null` literals are on the wrong side.\n\nNew in 2019.2"
        },
        {
          "shortName": "UnnecessarilyQualifiedStaticallyImportedElement",
          "displayName": "Unnecessarily qualified statically imported element",
          "enabled": false,
          "description": "Reports usage of statically imported members qualified with their containing class name.\n\nSuch qualification is unnecessary and can be removed\nbecause statically imported members can be accessed directly by member name.\n\n**Example:**\n\n\n      import static foo.Test.WIDTH;\n\n      class Bar {\n        void bar() {\n          System.out.println(Test.WIDTH);\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      import static foo.Test.WIDTH;\n\n      class Bar {\n        void bar() {\n          System.out.println(WIDTH);\n        }\n      }\n"
        },
        {
          "shortName": "LambdaCanBeReplacedWithAnonymous",
          "displayName": "Lambda can be replaced with anonymous class",
          "enabled": false,
          "description": "Reports lambda expressions that can be replaced with anonymous classes.\n\n\nExpanding lambda expressions to anonymous classes may be useful if you need to implement other\nmethods inside an anonymous class or if you need to downgrade to one of the previous Java versions.\n\nExample:\n\n\n      s -> System.out.println(s)\n\nAfter the quick-fix is applied:\n\n    new Consumer<String>() {\n      @Override\n      public void accept(String s) {\n        System.out.println(s);\n      }\n    }\n\nThis inspection is available in Java 8 and later."
        },
        {
          "shortName": "ConditionalCanBeOptional",
          "displayName": "Conditional can be replaced with Optional",
          "enabled": false,
          "description": "Reports null-check conditions and suggests replacing them with `Optional` chains.\n\nExample:\n\n\n      return str == null ? \"\" : str.trim();\n\nAfter applying the quick-fix:\n\n    return Optional.ofNullable(str).map(String::trim).orElse(\"\");\n\nWhile the replacement is not always shorter, it could be helpful for further refactoring\n(for example, for changing the method return value to `Optional`).\n\nNote that when a not-null branch of the condition returns null, the corresponding mapping step will\nproduce an empty `Optional` possibly changing the semantics. If it cannot be statically\nproven that semantics will be preserved, the quick-fix action name will contain the \"(may change semantics)\"\nnotice, and the inspection highlighting will be turned off.\n\nThis inspection only reports if the language level of the project or module is 8 or higher.\n\nNew in 2018.1"
        },
        {
          "shortName": "ConstantExpression",
          "displayName": "Constant expression can be evaluated",
          "enabled": false,
          "description": "Reports compile-time constant expressions and suggests replacing them with their actual values. For example, you will be prompted to replace \"2 + 2\" with \"4\".\n\nNew in 2018.1"
        },
        {
          "shortName": "StreamToLoop",
          "displayName": "Stream API call chain can be replaced with loop",
          "enabled": false,
          "description": "Reports Stream API chains, `Iterable.forEach()`, and `Map.forEach()` calls that can be automatically converted into classical loops.\n\n**Example:**\n\n\n      String joinNonEmpty(List<String> list) {\n        return list.stream() // Stream can be converted to loop\n          .filter(s -> !s.isEmpty())\n          .map(String::trim)\n          .collect(Collectors.joining(\", \"));\n      }\n\nAfter the quick-fix is applied:\n\n\n      String joinNonEmpty(List<String> list) {\n        StringJoiner joiner = new StringJoiner(\", \");\n        for (String s : list) {\n          if (!s.isEmpty()) {\n            String trim = s.trim();\n            joiner.add(trim);\n          }\n        }\n        return joiner.toString();\n      }\n\n\nNote that sometimes this inspection might cause slight semantic changes.\nSpecial care should be taken when it comes to short-circuiting, as it's not specified how many elements will be actually read when\nthe stream short-circuits.\n\nConfigure the inspection:\n\nUse the **Iterate unknown Stream sources via Stream.iterator()** option to suggest conversions for streams with unrecognized source.\nIn this case, iterator will be created from the stream.\nFor example, when checkbox is selected, the conversion will be suggested here:\n\n\n      List<ProcessHandle> handles = ProcessHandle.allProcesses().collect(Collectors.toList());\n\nIn this case, the result will be as follows:\n\n\n      List<ProcessHandle> handles = new ArrayList<>();\n      for (Iterator<ProcessHandle> it = ProcessHandle.allProcesses().iterator(); it.hasNext(); ) {\n        ProcessHandle allProcess = it.next();\n        handles.add(allProcess);\n      }\n\nNew in 2017.1"
        },
        {
          "shortName": "OptionalToIf",
          "displayName": "'Optional' can be replaced with sequence of 'if' statements",
          "enabled": false,
          "description": "Reports `Optional` call chains that can be replaced with a sequence of `if` statements.\n\nExample:\n\n\n      return Optional.ofNullable(name)\n        .map(this::extractInitials)\n        .map(initials -> initials.toUpperCase(Locale.ENGLISH))\n        .orElseGet(this::getDefault);\n\nAfter the quick-fix is applied:\n\n\n      if (name != null) {\n        String initials = extractInitials(name);\n        if (initials != null) return initials.toUpperCase(Locale.ENGLISH);\n      }\n      return getDefault();\n\nThis inspection only reports if the language level of the project or module is 8 or higher.\n\nNew in 2020.2"
        },
        {
          "shortName": "UnnecessaryFinalOnLocalVariableOrParameter",
          "displayName": "Unnecessary 'final' on local variable or parameter",
          "enabled": false,
          "description": "Reports local variables or parameters unnecessarily declared `final`.\n\nSome coding standards frown upon variables declared `final` for reasons of terseness.\n\n**Example:**\n\n\n      class Foo {\n        Foo(Object o) {}\n\n        void bar(final Object o) {\n          new Foo(o);\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      class Foo {\n        Foo(Object o) {}\n\n        void bar(Object o) {\n          new Foo(o);\n        }\n      }\n\n\nUse the inspection options to toggle the reporting for:\n\n* local variables\n* parameters (including parameters of `catch` blocks and enhanced `for` statements)\n\n\nAlso, you can configure the inspection to only report `final` parameters of `abstract` or interface\nmethods, which may be considered extra unnecessary as such markings don't\naffect the implementation of these methods."
        },
        {
          "shortName": "UnnecessaryBlockStatement",
          "displayName": "Unnecessary code block",
          "enabled": false,
          "description": "Reports code blocks that are redundant to the semantics of the program and can be replaced with their contents.\n\nThe code blocks that are the bodies of `if`, `do`,\n`while`, or `for` statements will not be reported by this\ninspection.\n\nExample:\n\n\n      void foo() {\n        { // unnecessary\n          int result = call();\n          analyze(result);\n        } // unnecessary\n      }\n\nConfigure the inspection:\n\n\nUse the **Ignore branches of 'switch' statements** option to ignore the code blocks that are used as branches of switch statements."
        },
        {
          "shortName": "OptionalAssignedToNull",
          "displayName": "Null value for Optional type",
          "enabled": false,
          "description": "Reports `null` assigned to `Optional` variable or returned from method returning `Optional`.\n\nIt's recommended that you use `Optional.empty()` (or `Optional.absent()` for Guava) to denote an empty value.\n\nExample:\n\n\n      Optional<Integer> foo(boolean flag) {\n        return flag ? Optional.of(42) : null;\n      }\n\nAfter the quick-fix is applied:\n\n\n      Optional<Integer> foo(boolean flag) {\n        return flag ? Optional.of(42) : Optional.empty();\n      }\n\nConfigure the inspection:\n\n\nUse the **Report comparison of Optional with null** option to also report comparisons like `optional == null`. While in rare cases (e.g. lazily initialized\noptional field) this might be correct, optional variable is usually never null, and probably `optional.isPresent()` was\nintended.\n\nThis inspection only reports if the language level of the project or module is 8 or higher.\n\nNew in 2017.2"
        },
        {
          "shortName": "FieldMayBeFinal",
          "displayName": "Field may be 'final'",
          "enabled": false,
          "description": "Reports fields that can be safely made `final`. All `final` fields have a value and this value does not change, which can make the code easier to reason about.\n\nTo avoid too expensive analysis, this inspection only reports if the field has a `private` modifier\nor it is defined in a local or anonymous class.\nA field can be `final` if:\n\n* It is `static` and initialized once in its declaration or in one `static` initializer.\n* It is non-`static` and initialized once in its declaration, in one instance initializer or in every constructor\n\nAnd it is not modified anywhere else.\n\n**Example:**\n\n\n      public class Person {\n        private String name; // can be final\n\n        Person(String name) {\n          this.name = name;\n        }\n\n        public String getName() {\n          return name;\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      public class Person {\n        private final String name;\n\n        Person(String name) {\n          this.name = name;\n        }\n\n        public String getName() {\n          return name;\n        }\n      }\n"
        },
        {
          "shortName": "SingleElementAnnotation",
          "displayName": "Non-normalized annotation",
          "enabled": false,
          "description": "Reports annotations in a shorthand form and suggests rewriting them in a normal form with an attribute name.\n\nExample:\n\n\n      @SuppressWarnings(\"foo\")\n\nAfter the quick-fix is applied:\n\n\n      @SuppressWarnings(value = \"foo\")\n"
        },
        {
          "shortName": "BoundedWildcard",
          "displayName": "Can use bounded wildcard",
          "enabled": false,
          "description": "Reports generic method parameters that can make use of [bounded wildcards](https://en.wikipedia.org/wiki/Wildcard_(Java)).\n\n**Example:**\n\n\n      void process(Consumer<Number> consumer);\n\nshould be replaced with:\n\n\n      void process(Consumer<? super Number> consumer);\n\n\nThis method signature is more flexible because it accepts more types: not only\n`Consumer<Number>`, but also `Consumer<Object>`.\n\nLikewise, type parameters in covariant position:\n\n\n      T produce(Producer<T> p);\n\nshould be replaced with:\n\n\n      T produce(Producer<? extends T> p);\n\n\nTo quote [Joshua Bloch](https://en.wikipedia.org/wiki/Joshua_Bloch#Effective_Java) in *Effective Java* third Edition:\n>\n> #### Item 31: Use bounded wildcards to increase API flexibility\n>\n> Using wildcard types in your APIs, while tricky, makes the APIs far more flexible. If you write a library that will be widely used, the proper use of wildcard types should be considered mandatory. Remember the basic rule: producer-extends, consumer-super (PECS). Also remember that all Comparables and Comparators are consumers.\n\n\nUse the inspection options to toggle the reporting for:\n\n*\n  invariant classes. An example of an invariant class is `java.util.List<T>` because it both accepts values\n  (via the `List.add(T)` method)\n  and produces values (via the `T List.get()` method).\n\n\n  On the\n  other hand, `contravariant` classes only receive values, for example, `java.util.function.Consumer<T>`\n  with the only method `accept(T)`. Similarly, `covariant` classes\n  only produce values, for example, `java.util.function.Supplier<T>`\n  with the only method `T get()`.\n\n\n  People often use bounded wildcards in covariant/contravariant\n  classes but avoid wildcards in invariant classes, for example, `void process(List<? extends T> l)`.\n  Disable this option to ignore such invariant classes and leave them rigidly typed, for example, `void\n  process(List<T> l)`.\n*\n  `private` methods, which can be considered as not a part of the public API\n\n*\n  instance methods"
        },
        {
          "shortName": "UnqualifiedMethodAccess",
          "displayName": "Instance method call not qualified with 'this'",
          "enabled": false,
          "description": "Reports calls to non-`static` methods on the same instance that are not qualified with `this`.\n\n**Example:**\n\n\n      class Foo {\n        void bar() {}\n\n        void foo() {\n          bar();\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      class Foo {\n        void bar() {}\n\n        void foo() {\n          this.bar();\n        }\n      }\n"
        },
        {
          "shortName": "UnnecessarySuperConstructor",
          "displayName": "Unnecessary call to 'super()'",
          "enabled": false,
          "description": "Reports calls to no-arg superclass constructors during object construction.\n\nSuch calls are unnecessary and may be removed.\n\n**Example:**\n\n\n      class Foo {\n        Foo() {\n          super();\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      class Foo {\n        Foo() {\n        }\n      }\n"
        },
        {
          "shortName": "DiamondCanBeReplacedWithExplicitTypeArguments",
          "displayName": "Diamond can be replaced with explicit type arguments",
          "enabled": false,
          "description": "Reports instantiation of generic classes in which the **\\<\\>** symbol (diamond) is used instead of type parameters.\n\nThe quick-fix replaces **\\<\\>** (diamond) with explicit type parameters.\nThis action can be useful to make the code compatible with Java 6.\n\nExample:\n\n    List <String> list = new ArrayList<>()\n\nAfter the quick-fix is applied:\n\n    List <String> list = new ArrayList<String>()\n"
        }
      ]
    },
    {
      "name": "Probable bugs",
      "inspections": [
        {
          "shortName": "SubtractionInCompareTo",
          "displayName": "Subtraction in 'compareTo()'",
          "enabled": false,
          "description": "Reports subtraction in `compareTo()` methods and methods implementing `java.util.Comparator.compare()`.\n\n\nWhile it is a common idiom to\nuse the results of integer subtraction as the result of a `compareTo()`\nmethod, this construct may cause subtle and difficult bugs in cases of integer overflow.\nComparing the integer values directly and returning `-1`, `0`, or `1` is a better practice in most cases.\n\n\nSubtraction on floating point values that is immediately cast to integral type is also reported because precision loss is possible due to\nrounding.\n\n\nThe inspection doesn't report when it's statically determined that value ranges are limited, and overflow never occurs.\nAdditionally, subtraction on `int` numbers greater than or equal to `0` will never overflow.\nTherefore, this inspection tries not to warn in those cases.\n\n\nMethods that always return zero or greater can be marked with the\n`javax.annotation.Nonnegative` annotation or specified in this inspection's options.\n\n**Example:**\n\n\n      class DoubleHolder implements Comparable<DoubleHolder> {\n        double d;\n        public int compareTo(DoubleHolder that) {\n            return (int)(this.d - that.d);\n        }\n     }\n\nA no-warning example because `String.length()` is known to be non-negative:\n\n\n      class A implements Comparable<A> {\n        final String s = \"\";\n        public int compareTo(A a) {\n            return s.length() - a.s.length();\n        }\n     }\n\n\nUse the options to list methods that are safe to use inside a subtraction.\nMethods are safe when they return an `int` value that is always greater than or equal to `0`."
        },
        {
          "shortName": "NumberEquality",
          "displayName": "Number comparison using '==', instead of 'equals()'",
          "enabled": true,
          "description": "Reports code that uses **==** or **!=** instead of `equals()` to test for `Number` equality.\n\n\nWith auto-boxing, it is easy\nto make the mistake of comparing two instances of a wrapper type instead of two primitives, for example `Integer` instead of\n`int`.\n\n**Example:**\n\n      void foo(Integer a, Integer b) {\n        final boolean bool = a == b;\n      }\n\nIf `a` is known to be non-null, then it's safe to apply the \"unsafe\" quick-fix and get the result similar to the following:\n\n      void foo(Integer a, Integer b) {\n        final boolean bool = a.equals(b);\n      }\n"
        },
        {
          "shortName": "MathRandomCastToInt",
          "displayName": "'Math.random()' cast to 'int'",
          "enabled": true,
          "description": "Reports calls to `Math.random()` which are immediately cast to `int`.\n\nCasting a `double` between `0.0` (inclusive) and\n`1.0` (exclusive) to `int` will always round down to zero. The value\nshould first be multiplied by some factor before casting it to an `int` to\nget a value between zero (inclusive) and the multiplication factor (exclusive).\nAnother possible solution is to use the `nextInt()` method of\n`java.util.Random`.\n\n**Example:**\n\n      int r = (int)Math.random() * 10;\n\nAfter the quick fix is applied:\n\n      int r = (int)(Math.random() * 10);\n"
        },
        {
          "shortName": "MismatchedStringCase",
          "displayName": "Mismatched case in 'String' operation",
          "enabled": true,
          "description": "Reports `String` method calls that always return the same value (`-1` or `false`) because a lowercase character is searched in an uppercase-only string or vice versa.\n\nReported methods include `equals`, `startsWith`, `endsWith`, `contains`,\n`indexOf`, and `lastIndexOf`.\n\n**Example:**\n\n```\n  if (columnName.toLowerCase().equals(\"ID\")) {...}\n```\n\nNew in 2019.3"
        },
        {
          "shortName": "NewStringBufferWithCharArgument",
          "displayName": "StringBuilder constructor call with 'char' argument",
          "enabled": true,
          "description": "Reports calls to `StringBuffer` and `StringBuilder` constructors with `char` as the argument. In this case, `char` is silently cast to an integer and interpreted as the initial capacity of the buffer.\n\n**Example:**\n\n\n      new StringBuilder('(').append(\"1\").append(')');\n\nAfter the quick-fix is applied:\n\n\n      new StringBuilder(\"(\").append(\"1\").append(')');\n"
        },
        {
          "shortName": "ClassGetClass",
          "displayName": "Suspicious 'Class.getClass()' call",
          "enabled": true,
          "description": "Reports `getClass()` methods that are called on a `java.lang.Class` instance.\n\nThis is usually a mistake as the result is always equivalent to `Class.class`.\nIf it's a mistake, then it's better to remove the `getClass()` call and use the qualifier directly.\nIf the behavior is intended, then it's better to write `Class.class` explicitly to avoid confusion.\n\nExample:\n\n\n      void test(Class<?> clazz) {\n        String name = clazz.getClass().getName();\n      }\n\nAfter one of the possible quick-fixes is applied:\n\n\n      void test(Class<?> clazz) {\n        String name = clazz.getName();\n      }\n\nNew in 2018.2"
        },
        {
          "shortName": "ResultOfObjectAllocationIgnored",
          "displayName": "Result of object allocation ignored",
          "enabled": false,
          "description": "Reports object allocations where the allocated object is ignored and neither assigned to a variable nor used in another way.\n\n\nSuch allocation expressions are legal in Java, but are usually either unintended, or\nevidence of a very odd object initialization strategy.\n\n\nUse the options to list classes whose allocations should be ignored by this inspection."
        },
        {
          "shortName": "MisspelledEquals",
          "displayName": "'equal()' instead of 'equals()'",
          "enabled": true,
          "description": "Reports declarations of `equal()` with a single parameter. Normally, this is a typo and `equals()` is actually intended.\n\nA quick-fix is suggested to rename the method to `equals`.\n\n**Example:**\n\n\n      class Main {\n        public boolean equal(Object obj) {\n          return true;\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      class Main {\n        public boolean equals(Object obj) {\n          return true;\n        }\n      }\n"
        },
        {
          "shortName": "MismatchedStringBuilderQueryUpdate",
          "displayName": "Mismatched query and update of 'StringBuilder'",
          "enabled": true,
          "description": "Reports `StringBuilder` or `StringBuffer` objects whose contents are read but not written to, or written to but not read.\n\nSuch inconsistent reads and writes are pointless and probably indicate\ndead, incomplete, or erroneous code.\n\n**Example:**\n\n\n      public void m1() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"a\");\n      }\n"
        },
        {
          "shortName": "SuspiciousArrayCast",
          "displayName": "Suspicious array cast",
          "enabled": false,
          "description": "Reports suspicious array casts. An array cast is considered suspicious when it casts to a more specific array type. Such a cast is legal at compile time but may fail with a `ClassCastException` at runtime.\n\n**Example:**\n\n\n      Number[] numbers = new Number[]{1L, 2L, 4L};\n      Long[] longs = (Long[])numbers;\n"
        },
        {
          "shortName": "StringConcatenationMissingWhitespace",
          "displayName": "Whitespace may be missing in string concatenation",
          "enabled": false,
          "description": "Reports string concatenations with missing whitespaces, that is where the left-hand side ends with a Unicode letter or digit and the right-hand side starts with a Unicode letter or digit.\n\n**Example:**\n\n\n      String sql = \"SELECT column\" +\n                   \"FROM table\";\n\n\nUse the **Ignore concatenations with variable strings** option to only report\nwhen both the left and right side of the concatenation are literals."
        },
        {
          "shortName": "ResultSetIndexZero",
          "displayName": "Use of index 0 in JDBC ResultSet",
          "enabled": false,
          "description": "Reports attempts to access column 0 of `java.sql.ResultSet` or `java.sql.PreparedStatement`. For historical reasons, columns of `java.sql.ResultSet` and `java.sql.PreparedStatement` are numbered starting with **1** , rather than with **0** , and accessing column 0 is a common error in JDBC programming.\n\n**Example:**\n\n\n      String getName(ResultSet rs) {\n        return rs.getString(0);\n      }\n"
        },
        {
          "shortName": "SuspiciousInvocationHandlerImplementation",
          "displayName": "Suspicious 'InvocationHandler' implementation",
          "enabled": true,
          "description": "Reports implementations of `InvocationHandler` that do not proxy standard `Object` methods like `hashCode()`, `equals()`, and `toString()`.\n\nFailing to handle these methods might cause unexpected problems upon calling them on a proxy instance.\n\n**Example:**\n\n\n      InvocationHandler myHandler = (proxy, method, params) -> {\n        System.out.println(\"Hello World!\");\n        return null;\n      };\n      Runnable myProxy = (Runnable) Proxy.newProxyInstance(\n        Thread.currentThread().getContextClassLoader(),\n        new Class[] {Runnable.class}, myHandler\n      );\n\n\nThis code snippet is designed to only proxy the `Runnable.run()` method.\nHowever, calls to any `Object` methods, like `hashCode()`, are proxied as well.\nThis can lead to problems like a `NullPointerException`, for example, when adding `myProxy` to a `HashSet`.\n\nNew in 2020.2"
        },
        {
          "shortName": "EqualsUsesNonFinalVariable",
          "displayName": "Non-final field referenced in 'equals()'",
          "enabled": false,
          "description": "Reports implementations of `equals()` that access non-`final` variables. Such access may result in `equals()` returning different results at different points in the object's lifecycle, which may in turn cause problems when using the standard collections classes.\n\n**Example:**\n\n\n      public class Person {\n        private String lastName;\n\n        @Override\n        public boolean equals(Object obj) {\n          ...\n          Person other = (Person) obj;\n          if (lastName == null) {\n            if (!lastName.equals(other.lastName)) {\n            return false;\n          ...\n          }\n        }\n      }\n      \n"
        },
        {
          "shortName": "StringConcatenationInMessageFormatCall",
          "displayName": "String concatenation as argument to 'MessageFormat.format()' call",
          "enabled": false,
          "description": "Reports non-constant string concatenations used as an argument to a call to `MessageFormat.format()`.\n\n\nWhile occasionally intended, this is usually a misuse of the formatting method\nand may even cause unexpected exceptions if the variables used in the concatenated string contain\nspecial characters like `{`.\n\n\nAlso, sometimes this could be the result\nof mistakenly concatenating a string format argument by typing a `+` when a `,` was meant.\n\n**Example:**\n\n\n      String formatGreeting(String userName, int balance) {\n        return MessageFormat.format(\"Hello, \" + userName + \"! Your balance is {0}.\", balance);\n      }\n\n\nHere, the `userName` will be interpreted as a part of the format string, which may result\nin `IllegalArgumentException` (for example, if `userName` is `\"{\"`).\nThis call should be probably replaced with `MessageFormat.format(\"Hello, {0}! Your balance is {1}.\", userName, balance)`."
        },
        {
          "shortName": "ComparatorResultComparison",
          "displayName": "Suspicious usage of compare method",
          "enabled": true,
          "description": "Reports comparisons of the result of `Comparator.compare()` or `Comparable.compareTo()` calls with non-zero constants. By contract, these methods can return any integer (not just -1, 0 or 1), so comparing against particular numbers is bad practice. Some widely used comparison methods (e.g. `String.compareTo()`) actually return values outside the \\[-1..1\\] range, and such a comparison may cause incorrect program behavior.\n\nExample:\n\n\n      void validate(String s1, String s2) {\n        // Comparing to 1 is incorrect\n        if (s1.compareTo(s2) == 1) {\n          throw new IllegalArgumentException(\"Incorrect order\");\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      void validate(String s1, String s2) {\n        if (s1.compareTo(s2) > 0) {\n          throw new IllegalArgumentException(\"Incorrect order\");\n        }\n      }\n\nNew in 2017.2"
        },
        {
          "shortName": "ImplicitArrayToString",
          "displayName": "Call to 'toString()' on array",
          "enabled": true,
          "description": "Reports arrays used in `String` concatenations or passed as parameters to `java.io.PrintStream` methods, such as `System.out.println()`.\n\n\nUsually, the content of the array is meant to be used and not the array object itself.\n\n**Example:**\n\n\n      void print(Object[] objects) {\n        System.out.println(objects);\n      }\n\nAfter the quick-fix is applied:\n\n\n      void print(Object[] objects) {\n        System.out.println(Arrays.toString(objects));\n      }\n"
        },
        {
          "shortName": "SuspiciousToArrayCall",
          "displayName": "Suspicious 'Collection.toArray()' call",
          "enabled": true,
          "description": "Reports suspicious calls to `Collection.toArray()`.\n\nThe following types of calls are considered suspicious:\n\n* when the type of the array argument is not the same as the array type to which the result is casted.\n* when the type of the array argument does not match the type parameter in the collection declaration.\n\n**Example:**\n\n\n    void m1(List list) {\n      Number[] ns = (Number[]) list.toArray(new String[0]);\n    }\n\n    void m2(List<Number> list) {\n      Number[] ns = list.toArray(new String[0]);\n    }\n"
        },
        {
          "shortName": "CompareToUsesNonFinalVariable",
          "displayName": "Non-final field referenced in 'compareTo()'",
          "enabled": false,
          "description": "Reports access to a non-`final` field inside a `compareTo()` implementation.\n\n\nSuch access may result in `compareTo()`\nreturning different results at different points in the object's lifecycle, which may in turn cause problems when\nusing the standard collections classes, for example `java.util.TreeSet`.\n\n\nA quick-fix to make the field `final` is available\nonly when there is no write access to the field, otherwise no fixes are suggested.\n\n**Example:**\n\n\n      class Foo implements Comparable<Foo>{\n        private int index;\n        Foo(int idx) {\n          index = idx;\n        }\n        @Override\n        public int compareTo(Foo foo) {\n         return Integer.compare(this.index, foo.index);\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      class Foo implements Comparable<Foo>{\n        private final int index;\n        Foo(int idx) {\n          index = idx;\n        }\n        @Override\n        public int compareTo(Foo foo) {\n          return Integer.compare(this.index, foo.index);\n        }\n      }\n"
        },
        {
          "shortName": "SuspiciousSystemArraycopy",
          "displayName": "Suspicious 'System.arraycopy()' call",
          "enabled": true,
          "description": "Reports suspicious calls to `System.arraycopy()`.\n\nSuch calls are suspicious when:\n\n* the source or destination is not of an array type\n* the source and destination are of different types\n* the copied chunk length is greater than `src.length - srcPos`\n* the copied chunk length is greater than `dest.length - destPos`\n* the ranges always intersect when the source and destination are the same array\n\n**Example:**\n\n\n      void foo() {\n        int[] src = new int[] { 1, 2, 3, 4 };\n        System.arraycopy(src, 0, src, 1, 2); // warning: Copying to the same array with intersecting ranges\n      }\n"
        },
        {
          "shortName": "MalformedFormatString",
          "displayName": "Malformed format string",
          "enabled": true,
          "description": "Reports format strings that don't comply with the standard Java syntax.\n\nBy default, the inspection considers a compile-time constant a format string if it's used as an argument to the corresponding methods on\n`java.util.Formatter`, `java.lang.String`, `java.io.PrintWriter` or `java.io.PrintStream`.\n\n**Example:**\n\n\n      String.format(\"x = %d, y = %d\", 42);\n\nUse the inspection settings to mark additional classes and methods as related to string formatting.\n\nAs an alternative, you can use the `org.intellij.lang.annotations.PrintFormat` annotation\nto mark the format string method parameter. In this case,\nthe format arguments parameter must immediately follow the format string and be the last method parameter. Example:\n\n\n      void myFormatMethod(int mode, @PrintFormat String formatString, Object... args) {...}\n\n\nMethods annotated in this way will also be recognized by this inspection."
        },
        {
          "shortName": "EndlessStream",
          "displayName": "Non-short-circuit operation consumes infinite stream",
          "enabled": true,
          "description": "Reports non-short-circuit operations consuming an infinite stream. Such operations can be completed only by throwing an exception.\n\nExample:\n\n\n      Stream.iterate(0, i -> i + 1).collect(Collectors.toList())\n"
        },
        {
          "shortName": "ArrayEquals",
          "displayName": "'equals()' called on array",
          "enabled": true,
          "description": "Reports `equals()` calls that compare two arrays.\n\nCalling `equals()` on an array compares identity and is equivalent to using `==`.\nUse `Arrays.equals()` to compare the contents of two arrays, or `Arrays.deepEquals()` for\nmulti-dimensional arrays.\n\n**Example:**\n\n\n      void sample(int[] first, int[] second){\n        if (first.equals(second)) return;\n      }\n\nAfter the quick-fix is applied:\n\n\n      void sample(int[] first, int[] second){\n        if (Arrays.equals(first, second)) return;\n      }\n"
        },
        {
          "shortName": "ThrowableNotThrown",
          "displayName": "'Throwable' not thrown",
          "enabled": true,
          "description": "Reports instantiations of `Throwable` or its subclasses, where the created `Throwable` is never actually thrown. Additionally, this inspection reports method calls that return instances of `Throwable` or its subclasses, when the result of the method call is not thrown.\n\nCalls to methods annotated with the Error Prone's or AssertJ's `@CanIgnoreReturnValue` annotation will not be reported.\n\n**Example:**\n\n\n        void leftBehind() throws Throwable {\n            RuntimeException e = new RuntimeException(\"throw me\");\n            // ...\n        }\n"
        },
        {
          "shortName": "CapturingCleaner",
          "displayName": "Cleaner captures object reference",
          "enabled": true,
          "description": "Reports `Runnable` passed to a `Cleaner.register()` capturing reference being registered. If the reference is captured, it will never be phantom reachable and the cleaning action will never be invoked.\n\nPossible sources of this problem:\n\n* Lambda using non-static methods, fields, or `this` itself\n* Non-static inner class (anonymous or not) always captures this reference in java up to 18 version\n* Instance method reference\n* Access to outer class non-static members from non-static inner class\n\nSample of code that will be reported:\n\n\n      int fileDescriptor;\n      Cleaner.Cleanable cleanable = Cleaner.create().register(this, () -> {\n        System.out.println(\"adsad\");\n        //this is captured via fileDescriptor\n        fileDescriptor = 0;\n      });\n\nThis inspection only reports if the language level of the project or module is 9 or higher.\n\nNew in 2018.1"
        },
        {
          "shortName": "MismatchedArrayReadWrite",
          "displayName": "Mismatched read and write of array",
          "enabled": true,
          "description": "Reports arrays whose contents are read but not updated, or updated but not read. Such inconsistent reads and writes are pointless and probably indicate dead, incomplete or erroneous code.\n\n**Example:**\n\n\n      final int[] bar = new int[3];\n      bar[2] = 3;\n"
        },
        {
          "shortName": "TextLabelInSwitchStatement",
          "displayName": "Text label in 'switch' statement",
          "enabled": true,
          "description": "Reports labeled statements inside of `switch` statements. While occasionally intended, this construction is often the result of a typo.\n\n**Example:**\n\n\n      switch (x) {\n          case 1:\n          case2:   //warning: Text label 'case2:' in 'switch' statement\n          case 3:\n              break;\n      }\n"
        },
        {
          "shortName": "WriteOnlyObject",
          "displayName": "Write-only object",
          "enabled": true,
          "description": "Reports objects that are modified but never queried.\n\nThe inspection relies on the method mutation contract, which could be inferred\nor pre-annotated for some library methods. This inspection does not report collections, maps, and string builders, as these types\nare reported by other more precise inspections.\n\nExample:\n\n\n      AtomicReference<String> ref = new AtomicReference<>();\n      ref.set(\"hello\"); // ref is never used again\n\n\nUse the **Ignore impure constructors** option to control whether to process objects created by constructor or method whose purity is not known.\nUnchecking the option may introduce some false-positives if the object reference is intentionally leaked during the construction.\n**New in 2021.2**"
        },
        {
          "shortName": "StringTokenizerDelimiter",
          "displayName": "Duplicated delimiters in 'StringTokenizer'",
          "enabled": true,
          "description": "Reports either a `StringTokenizer` constructor or a `nextToken` method call that contains duplicate characters in the delimiter argument, e.g. `tokenizer.nextToken(\"\\n\\n\")`."
        },
        {
          "shortName": "ReflectionForUnavailableAnnotation",
          "displayName": "Reflective access to a source-only annotation",
          "enabled": true,
          "description": "Reports attempts to reflectively check for the presence of a non-runtime annotation.\n\nUsing `Class.isAnnotationPresent()` to test for an annotation\nwhose retention policy is set to `SOURCE` or `CLASS`\n(the default) will always have a negative result. This mistake is easy to overlook.\n\n**Example:**\n\n\n      {\n        getClass().isAnnotationPresent(SourceAnnotation.class); //always false\n      }\n\n      @Retention(RetentionPolicy.SOURCE)\n      @interface SourceAnnotation {}\n"
        },
        {
          "shortName": "ConstantAssertCondition",
          "displayName": "Constant condition in 'assert' statement",
          "enabled": false,
          "description": "Reports `assert` statement conditions that are constants. `assert` statements with constant conditions will either always fail or always succeed. Such statements might be left over after a refactoring and are probably not intended.\n\n**Example:**\n\n\n        void foo() {\n            assert true;\n        }\n"
        },
        {
          "shortName": "ArrayHashCode",
          "displayName": "'hashCode()' called on array",
          "enabled": true,
          "description": "Reports incorrect hash code calculation for arrays.\n\nIn order to\ncorrectly calculate the hash code for an array, use:\n\n* `Arrays.hashcode()` for linear arrays\n* `Arrays.deepHashcode()` for multidimensional arrays\n\nThese methods should also be used with `Objects.hash()` when the sequence of input values includes arrays, for example: `Objects.hash(string, Arrays.hashcode(array))`"
        },
        {
          "shortName": "ConfusingMainMethod",
          "displayName": "Confusing 'main()' method",
          "enabled": false,
          "description": "Reports methods that are named \"main\", but do not have the `public static void main(String[])` signature.\n\nSuch methods may be confusing, as methods named \"main\"\nare expected to be application entry points.\n\n**Example:**\n\n\n      class Main {\n        void main(String[] args) {} //a warning here because there are no \"public static\" modifiers\n      }\n\nA quick-fix that renames such methods is available only in the editor."
        },
        {
          "shortName": "StringEqualsCharSequence",
          "displayName": "'String.equals()' called with 'CharSequence' argument",
          "enabled": true,
          "description": "Reports calls to `String.equals()` with a `CharSequence` as the argument.\n\n\n`String.equals()` can only return `true` for `String` arguments.\nTo compare the contents of a `String` with a non-`String` `CharSequence` argument,\nuse the `contentEquals()` method.\n\n**Example:**\n\n\n      boolean equals(String s, CharSequence ch) {\n        return s.equals(ch);\n      }\n\nAfter quick-fix is applied:\n\n\n      boolean equals(String s, CharSequence ch) {\n        return s.contentEquals(ch);\n      }\n\n\nNew in 2017.3"
        },
        {
          "shortName": "AssertWithSideEffects",
          "displayName": "'assert' statement with side effects",
          "enabled": true,
          "description": "Reports `assert` statements that cause side effects.\n\n\nSince assertions can be switched off,\nthese side effects are not guaranteed, which can cause subtle bugs. Common unwanted side effects detected by this inspection are\nmodifications of variables and fields. When methods calls are involved, they are analyzed one level deep.\n\n**Example:**\n\n\n      assert i++ < 10;\n"
        },
        {
          "shortName": "CollectionAddedToSelf",
          "displayName": "Collection added to itself",
          "enabled": true,
          "description": "Reports cases where the argument of a method call on a `java.util.Collection` or `java.util.Map` is the collection or map itself. Such situations may occur as a result of copy-paste in code with raw types.\n\n**Example:**\n\n\n      ArrayList list = new ArrayList<>();\n      list.add(list); // warning here\n      return list.hashCode(); // throws StackOverflowError\n"
        },
        {
          "shortName": "EqualsOnSuspiciousObject",
          "displayName": "'equals()' called on 'StringBuilder'",
          "enabled": true,
          "description": "Reports `equals()` calls on `StringBuilder` or `StringBuffer` instances.\n\nThe `equals()` method is not overridden in these classes, so it may return `false` even when the contents of the two objects are the same.\nIf the reference equality is intended, it's better to use `==` to avoid confusion.\n\nExample:\n\n\n      public void test(StringBuilder sb1, StringBuilder sb2) {\n        boolean result = sb1.equals(sb2); // Suspicious\n      }\n\nNew in 2017.2"
        },
        {
          "shortName": "UseOfPropertiesAsHashtable",
          "displayName": "Use of 'Properties' object as a 'Hashtable'",
          "enabled": true,
          "description": "Reports calls to the following methods on `java.util.Properties` objects:\n\n* `java.util.Hashtable#put`\n* `java.util.Hashtable#putIfAbsent`\n* `java.util.Hashtable#putAll`\n* `java.util.Hashtable#get`\n\n\nFor historical reasons, `java.util.Properties` inherits `java.util.Hashtable`,\nbut using those methods is discouraged to prevent corruption of properties values of types other than `String`.\n\n\nAlthough `java.util.Properties#putAll` overrides `java.util.Hashtable#putAll` it doesn't get reported when\nboth the key and the value parameters in the map are of the `String` type.\n\n**Example:**\n\n\n      Object f(Properties props) {\n        props.put(\"hello\", \"world\");\n        props.putIfAbsent(\"hello\", \"world\");\n        props.putAll(new HashMap<>());\n        return props.get(\"Hello\");\n      }\n\nAfter the quick-fix is applied:\n\n\n      Object f(Properties props) {\n        props.setProperty(\"hello\", \"world\");\n        props.putIfAbsent(\"hello\", \"world\");\n        props.putAll(new HashMap<>());\n        return props.getProperty(\"hello\");\n      }\n"
        },
        {
          "shortName": "CopyConstructorMissesField",
          "displayName": "Copy constructor misses field",
          "enabled": true,
          "description": "Reports copy constructors that don't copy all the fields of the class.\n\n\n`final` fields with initializers and `transient` fields are considered unnecessary to copy.\n\n**Example:**\n\n\n      class Point {\n\n        private int x;\n        private int y;\n\n        Point(int x, int y) {\n          this.x = x;\n          this.y = y;\n        }\n\n        Point(Point other) {\n          // fields x and y are not initialized\n        }\n      }\n\nNew in 2018.1"
        },
        {
          "shortName": "InvalidComparatorMethodReference",
          "displayName": "Invalid method reference used for 'Comparator'",
          "enabled": true,
          "description": "Reports method references mapped to the `Comparator` interface that don't fulfill its contract.\n\n\nSome method references, like `Integer::max`, can be mapped to the `Comparator` interface.\nHowever, using them as `Comparator` is meaningless and the result might be unpredictable.\n\nExample:\n\n\n      ArrayList<Integer> ints = foo();\n      ints.sort(Math::min);\n\nAfter the quick-fix is applied:\n\n\n      ArrayList<Integer> ints = foo();\n      ints.sort(Comparator.reverseOrder());\n"
        },
        {
          "shortName": "SortedCollectionWithNonComparableKeys",
          "displayName": "Sorted collection with non-comparable elements",
          "enabled": true,
          "description": "Reports construction of sorted collections, for example `TreeSet`, that rely on natural ordering, whose element type doesn't implement the `Comparable` interface.\n\nIt's unlikely that such a collection will work properly.\n\n\nA false positive is possible if the collection element type is a non-comparable super-type,\nbut the collection is intended to only hold comparable sub-types. Even if this is the case,\nit's better to narrow the collection element type or declare the super-type as `Comparable` because the mentioned approach is error-prone.\n\n\nThe inspection also reports cases when the collection element is a type parameter which is not declared as `extends Comparable`.\nYou can suppress the warnings on type parameters using the provided option (for example, to keep the API compatibility).\n\n\nNew in 2018.3"
        },
        {
          "shortName": "EqualsBetweenInconvertibleTypes",
          "displayName": "'equals()' between objects of inconvertible types",
          "enabled": true,
          "description": "Reports calls to `equals()` where the target and argument are of incompatible types.\n\nWhile such a call might theoretically be useful, most likely it is a bug.\n\n**Example:**\n\n\n      new HashSet<String>().equals(new TreeSet<Integer>());\n"
        },
        {
          "shortName": "ObjectEquality",
          "displayName": "Object comparison using '==', instead of 'equals()'",
          "enabled": false,
          "description": "Reports code that uses `==` or `!=` rather than `equals()` to test for `Object` equality.\n\nComparing objects using `==` or `!=` is often a bug, because it compares objects by identity instead of\nequality.\nComparisons to `null` are not reported.\nArray, `String` and `Number` comparisons are reported by separate inspections.\n\n**Example:**\n\n      if (list1 == list2) {\n        return;\n      }\n\nAfter the quick-fix is applied:\n\n      if (Object.equals(list1, list2)) {\n        return;\n      }\n\n\nUse the inspection settings to configure exceptions for this inspection."
        },
        {
          "shortName": "IterableUsedAsVararg",
          "displayName": "Iterable is used as vararg",
          "enabled": true,
          "description": "Reports suspicious usages of `Collection` or `Iterable` in vararg method calls.\n\nFor example, in the following method:\n\n\n      <T> boolean contains(T needle, T... haystack) {...}\n\na call like\n\n\n      if(contains(\"item\", listOfStrings)) {...}\n\nlooks suspicious as the list will be wrapped into a single element array.\nSuch code can be successfully compiled and will likely run without\nexceptions, but it's probably used by mistake.\n\nNew in 2019.2"
        },
        {
          "shortName": "ReplaceAllDot",
          "displayName": "Suspicious regex expression argument",
          "enabled": true,
          "description": "Reports calls to `String.replaceAll()` or `String.split()` where the first argument is a single regex meta character argument.\n\n\nThe regex meta characters are one of `.$|()[{^?*+\\`. They have a special meaning in regular expressions.\nFor example, calling `\"ab.cd\".replaceAll(\".\", \"-\")` produces `\"-----\"`, because the dot matches any character.\nMost likely the escaped variant `\"\\\\.\"` was intended instead.\n\n**Example:**\n\n\n      s.replaceAll(\".\", \"-\");\n\nAfter the quick-fix is applied:\n\n\n      s.replaceAll(\"\\\\.\", \"-\");\n"
        },
        {
          "shortName": "ComparableImplementedButEqualsNotOverridden",
          "displayName": "'Comparable' implemented but 'equals()' not overridden",
          "enabled": true,
          "description": "Reports classes that implement `java.lang.Comparable` but do not override `equals()`.\n\n\nIf `equals()`\nis not overridden, the `equals()` implementation is not consistent with\nthe `compareTo()` implementation. If an object of such a class is added\nto a collection such as `java.util.SortedSet`, this collection will violate\nthe contract of `java.util.Set`, which is defined in terms of\n`equals()`.\n\n**Example:**\n\n\n      class Length implements Comparable<Length> {\n        private int cm = 0;\n\n        @Override\n        public int compareTo(@NotNull Length o) {\n          if (cm == o.cm) return 0;\n          return cm < o.cm ? -1 : 1;\n        }\n      }\n\nAfter the quick fix is applied:\n\n\n      class Length implements Comparable<Length> {\n        private int cm = 0;\n\n        @Override\n        public int compareTo(@NotNull Length o) {\n          if (cm == o.cm) return 0;\n          return cm < o.cm ? -1 : 1;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n          return o instanceof Length && compareTo((Length) o) == 0;\n        }\n      }\n"
        },
        {
          "shortName": "InstantiationOfUtilityClass",
          "displayName": "Instantiation of utility class",
          "enabled": false,
          "description": "Reports instantiation of utility classes using the `new` keyword.\n\n\nIn utility classes, all fields and methods are `static`.\nInstantiation of such classes is most likely unnecessary and indicates a mistake.\n\n**Example:**\n\n\n      class MyUtils {\n        public static double cube(double x) {\n          return x * x * x;\n        }\n      }\n      class Main {\n        public static void main(String[] args) {\n          // Instantiation of utility class\n          MyUtils utils = new MyUtils();\n        }\n      }\n\n\nTo prevent utility classes from being instantiated,\nit's recommended to use a `private` constructor."
        },
        {
          "shortName": "StringConcatenationInFormatCall",
          "displayName": "String concatenation as argument to 'format()' call",
          "enabled": false,
          "description": "Reports non-constant string concatenations used as a format string argument.\n\n\nWhile occasionally intended, this is usually a misuse of a formatting method\nand may even cause security issues if the variables used in the concatenated string\ncontain special characters like `%`.\n\n\nAlso, sometimes this could be the result\nof mistakenly concatenating a string format argument by typing a `+` when a `,` was meant.\n\n**Example:**\n\n\n      static String formatGreeting(String userName) {\n        return String.format(\"Hello, \" + userName);\n      }\n\n\nHere, the `userName` will be interpreted as a part of format string, which may result\nin `IllegalFormatException` (for example, if `userName` is `\"%\"`) or\nin using an enormous amount of memory (for example, if `userName` is `\"%2000000000%\"`).\nThe call should be probably replaced with `String.format(\"Hello, %s\", userName);`.\n\n\nThis inspection checks calls to formatting methods on\n`java.util.Formatter`,\n`java.lang.String`,\n`java.io.PrintWriter`,\nor `java.io.PrintStream`."
        },
        {
          "shortName": "SuspiciousListRemoveInLoop",
          "displayName": "Suspicious 'List.remove()' in loop",
          "enabled": true,
          "description": "Reports `list.remove(index)` calls inside an ascending counted loop.\n\n\nThis is suspicious as the list becomes\nshorter after the removal, and the next element gets skipped. A simple fix is to decrease the index variable\nafter the removal,\nbut probably removing via an iterator or using the `removeIf()` method (Java 8 and later) is a more robust alternative.\nIf you don't expect that `remove()` will be called more than once in a loop, consider adding a `break` after it.\n\n**Example:**\n\n      public static void main(String[] args) {\n        process(new ArrayList<>(\n          Arrays.asList(\"1\", \"2\", \"|\", \"3\", \"4\")));\n      }\n\n      static void process(List<String> list) {\n        for (int i = 0; i < list.size(); i++) {\n          if (list.get(i).equals(\"|\")) {\n            list.remove(i);\n            continue;\n          }\n          System.out.println(list.get(i));\n        }\n      }\n\nThe code looks like `1 2 3 4` is going to be printed, but in reality, `3` will be skipped in the output.\n\nNew in 2018.2"
        },
        {
          "shortName": "OptionalGetWithoutIsPresent",
          "displayName": "Optional.get() is called without isPresent() check",
          "enabled": true,
          "description": "Reports calls to `get()` on an `Optional` without checking that it has a value.\n\nCalling `Optional.get()` on an empty `Optional` instance will throw an exception.\n\n**Example:**\n\n\n      void x(List<Integer> list) {\n        final Optional<Integer> optional =\n          list.stream().filter(x -> x > 10).findFirst();\n        final Integer result = optional.get(); // problem here\n      }\n"
        },
        {
          "shortName": "RedundantOperationOnEmptyContainer",
          "displayName": "Redundant operation on empty container",
          "enabled": true,
          "description": "Reports redundant operations on empty collections, maps or arrays.\n\n\nIterating, removing elements, sorting,\nand some other operations on empty collections have no effect and can be removed. Also, they may be a signal of a bug.\n\n**Example:**\n\n\n      if (numbers.isEmpty()){\n        //error due to the missed negation\n        int max = numbers.stream().max(Comparator.naturalOrder()).get();\n        ...\n      }\n\nNew in 2019.1"
        },
        {
          "shortName": "WrongPackageStatement",
          "displayName": "Wrong package statement",
          "enabled": true,
          "description": "Detects `package` statements that do not correspond to the project directory structure. Also, reports classes without `package` statements if the class is not located directly in source root directory.\n\nWhile it's not strictly mandated by Java language, it's good to keep classes\nfrom package `com.example.myapp` inside the `com/example/myapp` directory under\nthe source root. Failure to do this may confuse code readers and make some tools working incorrectly."
        },
        {
          "shortName": "CovariantEquals",
          "displayName": "Covariant 'equals()'",
          "enabled": true,
          "description": "Reports `equals()` methods taking an argument type other than `java.lang.Object` if the containing class does not have other overloads of `equals()` that take `java.lang.Object` as its argument type.\n\n\nA covariant version of `equals()` does not override the\n`Object.equals(Object)` method. It may cause unexpected\nbehavior at runtime. For example, if the class is used to construct\none of the standard collection classes, which expect that the\n`Object.equals(Object)` method is overridden.\n\n**Example:**\n\n\n      class Foo {\n          public boolean equals(Foo foo) {  // warning\n              return false;\n          }\n      }\n      class Bar {\n          public boolean equals(Bar bar) {  // no warning here\n              return false;\n          }\n          @Override\n          public boolean equals(Object obj) {\n              return false;\n          }\n      }\n"
        },
        {
          "shortName": "EqualsWithItself",
          "displayName": "'equals()' called on itself",
          "enabled": true,
          "description": "Reports calls to `equals()` or `compareTo()` where an object is compared for equality with itself.\n\nAccording to the method contracts, these operations will always return\n`true` for `equals()` or `0` for `compareTo()`. The inspection also checks\nthe calls to `Objects.equals()`, `Objects.deepEquals()`,\n`Arrays.equals()`, `Comparator.compare`, and the like.\n\n**Example:**\n\n\n      class Foo {\n        boolean foo(Object o) {\n            return o.equals(o); // warning\n        }\n\n        boolean bar(String[] ss) {\n            return Arrays.equals(ss, ss); // warning\n        }\n    }\n"
        },
        {
          "shortName": "SuspiciousNameCombination",
          "displayName": "Suspicious variable/parameter name combination",
          "enabled": true,
          "description": "Reports assignments and function calls in which the name of the target variable or the function parameter does not match the name of the value assigned to it.\n\nExample 1:\n\n\n      int x = 0;\n      int y = x; // x is used as a y-coordinate\n      \nExample 2:\n\n\n      int x = 0, y = 0;\n      // x is used as a y-coordinate and y as an x-coordinate\n      Rectangle rc = new Rectangle(y, x, 20, 20);\n\nConfigure the inspection:\n\nUse the **Group of names** area to specify the names which should not be used together: an error is reported\nif the parameter name or assignment target name contains words from one group and the name of the assigned or passed\nvariable contains words from a different group.\n\nUse the **Ignore methods** area to specify the methods that should not be checked but have a potentially suspicious name.\nFor example, the `Integer.compare()` parameters are named `x` and `y` but are unrelated to coordinates."
        },
        {
          "shortName": "ComparatorMethodParameterNotUsed",
          "displayName": "Suspicious 'Comparator.compare()' implementation",
          "enabled": true,
          "description": "Reports problems in `Comparator.compare()` implementations.\n\nThe following cases are reported:\n\n* A parameter is not used. Most likely this is a typo and the other parameter is compared with itself, or the method is not implemented correctly.\n* It's evident that the comparator does not return `0` for the same elements. Such a comparator violates the contract and can produce unpredictable results when equal elements are encountered. In particular, sorting may fail with an exception on some data.\n\n**Example:**\n\n\n      Comparator<String> lambda =\n        (a, b) -> a.length() > b.length()\n                  ? 0\n                  : Math.random() > 0.5 ? -1 : 1;\n"
        },
        {
          "shortName": "PrimitiveArrayArgumentToVariableArgMethod",
          "displayName": "Confusing primitive array argument to varargs method",
          "enabled": true,
          "description": "Reports any calls to a variable arity method where the call has a primitive array in the variable arity parameter position (for example, `System.out.printf(\"%s\", new int[]{1, 2, 3})`). Such a primitive-array argument may be confusing, as it will be wrapped as a single-element array, rather than each individual element being boxed, as might be expected.\n\n**Example:**\n\n\n      String.format(\"%s\", new int[]{1, 2, 3});\n\nAfter the quick-fix is applied:\n\n\n      String.format(\"%s\", (Object) new int[]{1, 2, 3});\n"
        },
        {
          "shortName": "IteratorNextDoesNotThrowNoSuchElementException",
          "displayName": "'Iterator.next()' which can't throw 'NoSuchElementException'",
          "enabled": false,
          "description": "Reports implementations of `Iterator.next()` that cannot throw `java.util.NoSuchElementException`.\n\n\nSuch implementations violate the contract of `java.util.Iterator`,\nand may result in subtle bugs if the iterator is used in a non-standard way.\n\n**Example:**\n\n\n      class Numbers implements Iterator<Integer> {\n        @Override\n        public Integer next() { //warning\n            if (hasNext()) {\n                return generateNext();\n            } else {\n                return null; //throw NoSuchElementException instead\n            }\n        }\n\n        ...\n      }\n"
        },
        {
          "shortName": "SuspiciousTernaryOperatorInVarargsCall",
          "displayName": "Suspicious ternary operator in varargs method call",
          "enabled": true,
          "description": "Reports vararg method calls that use a ternary operator with mixed array and non-array branches.\n\n\nWhen compiled, both branches are wrapped in arrays. As a result, the array branch is turned into\na two-dimensional array, which may indicate a problem.\n\n\nThe quick-fix wraps the non-array branch in an array to prevent the compiler from doing the conversion.\n\n**Example:**\n\n\n        static void bar(boolean flag) {\n            Object[] a = {1, 2};\n            Object b = \"hello\";\n            foo(flag ? a : b);\n        }\n        static void foo(Object... obj) {\n        }\n\nAfter the quick-fix:\n\n\n        static void bar(boolean flag) {\n            Object[] a = {1, 2};\n            Object b = \"hello\";\n            foo(flag ? a : new Object[]{b});\n        }\n        static void foo(Object... obj) {\n        }\n\nNew in 2020.3"
        },
        {
          "shortName": "ArrayObjectsEquals",
          "displayName": "Use of shallow or 'Objects' methods with arrays",
          "enabled": true,
          "description": "Reports expressions that seem to use an inappropriate method for determining array equality or calculating their hashcode.\n\nThe following method calls are reported:\n\n* `Object.equals()` for any arrays\n* `Arrays.equals()` for multidimensional arrays\n* `Arrays.hashCode()` for multidimensional arrays"
        },
        {
          "shortName": "MeaninglessRecordAnnotationInspection",
          "displayName": "Meaningless record annotation",
          "enabled": true,
          "description": "Reports annotations used on record components that have no effect.\n\nThis can happen in two cases:\n\n* The reported annotation has the METHOD target, but the corresponding accessor is explicitly defined.\n* The reported annotation has the PARAMETER target, but the canonical constructor is explicitly defined.\n\nExample:\n\n\n    @Target(ElementType.METHOD)\n    @interface A { }\n      \n    // The annotation will not appear in bytecode at all,\n    // as it should be propagated to the accessor but accessor is explicitly defined \n    record R(@A int x) {\n      public int x() { return x; }\n    }\n\nNew in 2021.1"
        },
        {
          "shortName": "EqualsWhichDoesntCheckParameterClass",
          "displayName": "'equals()' method which does not check class of parameter",
          "enabled": true,
          "description": "Reports `equals()` methods that do not check the type of their parameter.\n\nFailure to check the type of the parameter\nin the `equals()` method may result in latent errors if the object is used in an untyped collection.\n\n**Example:**\n\n\n      class MyClass {\n        int x;\n\n        @Override\n        public boolean equals(Object obj) {\n          // equals method should return false if obj is not MyClass\n          return ((MyClass)obj).x == x;\n        }\n      }\n"
        },
        {
          "shortName": "SuspiciousIndentAfterControlStatement",
          "displayName": "Suspicious indentation after control statement without braces",
          "enabled": false,
          "description": "Reports suspicious indentation of statements after a control statement without braces.\n\n\nSuch indentation can make it look like the statement is inside the control statement,\nwhen in fact it will be executed unconditionally after the control statement.\n\n**Example:**\n\n\n      class Bar {\n          void foo(int i) {\n              if (i == 0)\n                  System.out.println(\"foo\");\n                  System.out.println(\"bar\"); // warning\n              if (i == 1);\n                  System.out.println(\"great\"); // warning\n              if (i == 42)\n                  System.out.println(\"answer\");\n                      System.out.println(\"question\"); // warning\n          }\n      }\n"
        },
        {
          "shortName": "SuspiciousDateFormat",
          "displayName": "Suspicious date format pattern",
          "enabled": true,
          "description": "Reports date format patterns that are likely used by mistake.\n\nThe following patterns are reported:\n\n* Uppercase \"Y\", unless \"w\" appears nearby. It stands for \"Week year\" that is almost always the same as normal \"Year\" (lowercase \"y\" pattern), but may point to the next year at the end of December.\n* Uppercase \"M\" (month) close to \"H\", \"K\", \"h\", or \"k\" (hour). It's likely that a lowercase \"m\" (minute) was intended.\n* Lowercase \"m\" (minute) close to \"y\" (year) or \"d\" (day in month). It's likely that an uppercase \"M\" (month) was intended.\n* Uppercase \"D\" (day in year) close to \"M\", or \"L\" (month). It's likely that a lowercase \"d\" (day in month) was intended.\n* Uppercase \"S\" (milliseconds) close to \"m\" (minutes). It's likely that a lowercase \"s\" (seconds) was intended.\n\n\nExamples:  \n\n`new SimpleDateFormat(\"YYYY-MM-dd\")`: likely `\"yyyy-MM-dd\"` was intended.  \n\n`new SimpleDateFormat(\"yyyy-MM-DD\")`: likely `\"yyyy-MM-dd\"` was intended.  \n\n`new SimpleDateFormat(\"HH:MM\")`: likely `\"HH:mm\"` was intended.\n\nNew in 2020.1"
        },
        {
          "shortName": "ClassNewInstance",
          "displayName": "Unsafe call to 'Class.newInstance()'",
          "enabled": false,
          "description": "Reports calls to `java.lang.Class.newInstance()`.\n\n\nThis method propagates exceptions thrown by\nthe no-arguments constructor, including checked exceptions. Usages of this method\neffectively bypass the compile-time exception checking that would\notherwise be performed by the compiler.\n\n\nA quick-fix is suggested to replace the call with a call to the\n`java.lang.reflect.Constructor.newInstance()` method, which\navoids this problem by wrapping any exception thrown by the constructor in a\n(checked) `java.lang.reflect.InvocationTargetException`.\n\n**Example:**\n\n\n      clazz.newInstance()\n\nAfter the quick-fix is applied:\n\n\n      clazz.getConstructor().newInstance();\n"
        },
        {
          "shortName": "MagicConstant",
          "displayName": "Magic Constant",
          "enabled": true,
          "description": "Reports expressions that can be replaced with \"magic\" constants.\n\nExample 1:\n\n\n      // Bare literal \"2\" is used, warning:\n      Font font = new Font(\"Arial\", 2)\n\nExample 2:\n\n\n      // Predefined constant is used, good:\n      Font font = new Font(\"Arial\", Font.ITALIC)\n\n\nWhen possible, the quick-fix inserts an appropriate predefined constant.\n\n\nThe behavior of this inspection is controlled by `org.intellij.lang.annotations.MagicConstant` annotation.\nSome standard Java library methods are pre-annotated, but you can use this annotation in your code as well."
        },
        {
          "shortName": "ConstantConditions",
          "displayName": "Constant conditions & exceptions",
          "enabled": true,
          "description": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases."
        },
        {
          "shortName": "StaticFieldReferenceOnSubclass",
          "displayName": "Static field referenced via subclass",
          "enabled": false,
          "description": "Reports accesses to static fields where the call is qualified by a subclass of the declaring class, rather than by the declaring class itself.\n\n\nJava allows such qualification, but such accesses may indicate a subtle confusion of inheritance and overriding.\n\n**Example:**\n\n\n      class Parent {\n        static int foo = 0;\n      }\n\n      class Child extends Parent { }\n\n      void bar() {\n        System.out.println(Child.foo);\n      }\n\nAfter the quick-fix is applied, the result looks like this:\n\n\n      class Parent {\n        static int foo = 0;\n      }\n\n      class Child extends Parent { }\n\n      void bar() {\n        System.out.println(Parent.foo);\n      }\n"
        },
        {
          "shortName": "IgnoreResultOfCall",
          "displayName": "Result of method call ignored",
          "enabled": true,
          "description": "Reports method calls whose result is ignored.\n\nFor many methods, ignoring the result is perfectly\nlegitimate, but for some it is almost certainly an error. Examples of methods where ignoring\nthe result is likely an error include `java.io.inputStream.read()`,\nwhich returns the number of bytes actually read, and any method on\n`java.lang.String` or `java.math.BigInteger`. These methods do not produce side-effects and thus pointless\nif their result is ignored.\n\nThe calls to the following methods are inspected:\n\n* Simple getters (which do nothing except return a field)\n* Methods specified in the settings of this inspection\n* Methods annotated with `org.jetbrains.annotations.Contract(pure=true)`\n* Methods annotated with .\\*.`CheckReturnValue`\n* Methods in a class or package annotated with `javax.annotation.CheckReturnValue`\n* Optionally, all non-library methods\n\nCalls to methods annotated with Error Prone's or AssertJ's `@CanIgnoreReturnValue` annotation are not reported.\n\n\nUse the inspection settings to specify the classes to check.\nMethods are matched by name or name pattern using Java regular expression syntax.\nFor classes, use fully-qualified names. Each entry applies to both the class and all its inheritors."
        },
        {
          "shortName": "MismatchedCollectionQueryUpdate",
          "displayName": "Mismatched query and update of collection",
          "enabled": true,
          "description": "Reports collections whose contents are either queried and not updated, or updated and not queried.\n\n\nSuch inconsistent queries and updates are pointless and may indicate\neither dead code or a typo.\n\n\nUse the inspection settings to specify name patterns that correspond to update/query methods.\nQuery methods that return an element are automatically detected, and only\nthose that write data to an output parameter (for example, an `OutputStream`) need to be specified.\n\n\n**Example:**\n\nSuppose you have your custom `FixedStack` class with method `store()`:\n\n\n      public class FixedStack<T> extends Collection<T> {\n        public T store(T t) {\n          // implementation\n        }\n      }\n\nYou can add `store` to the update methods table in order to report mismatched queries like:\n\n\n      void test(int i) {\n        FixedStack<Integer> stack = new FixedStack<>();\n        stack.store(i);\n      }\n"
        },
        {
          "shortName": "InnerClassReferencedViaSubclass",
          "displayName": "Inner class referenced via subclass",
          "enabled": false,
          "description": "Reports accesses of inner and nested classes where the call is qualified by a subclass of the declaring class, rather than the declaring class itself.\n\n\nJava allows such qualification, but such accesses may indicate a subtle confusion of inheritance and overriding.\n\n**Example:**\n\n\n      class Super {\n        static class Inner {}\n      }\n\n      class Sub extends Super {\n        void test() {\n          Sub.Inner s = new Sub.Inner(); // 'Inner' class is declared in 'Super' class, but referenced via 'Sub' class\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      class Super {\n        static class Inner {}\n      }\n\n      class Sub extends Super {\n        void test() {\n          Super.Inner s = new Super.Inner();\n        }\n      }\n"
        },
        {
          "shortName": "ScheduledThreadPoolExecutorWithZeroCoreThreads",
          "displayName": "'ScheduledThreadPoolExecutor' with zero core threads",
          "enabled": false,
          "description": "Reports any `java.util.concurrent.ScheduledThreadPoolExecutor` instances in which `corePoolSize` is set to zero via the `setCorePoolSize` method or the object constructor.\n\n\nA `ScheduledThreadPoolExecutor` with zero core threads will run nothing.\n\n**Example:**\n\n\n      void foo(int corePoolSize) {\n          if (corePoolSize != 0) return;\n          ThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(corePoolSize); // warning\n          executor.setCorePoolSize(corePoolSize); // warning\n      }\n"
        },
        {
          "shortName": "UnusedAssignment",
          "displayName": "Unused assignment",
          "enabled": true,
          "description": "Reports assignment values that are not used after the assignment. If the assignment value is unused, it's better to remove the assignment to shorten the code and avoid redundant allocations.\n\nThe following cases are reported:\n\n* The variable never gets read after the assignment.\n* The variable is always overwritten with a new value before it is read.\n* The variable initializer is redundant (for one of the two reasons above).\n\nConfigure the inspection:\n\n\nUse the **Report redundant initializers** option to report redundant initializers:\n\n\n      int getI() {\n        int i = 0; // redundant initialization\n        i = 2;\n        return i;\n      }\n\n\nUse the **Report ++i when may be replaced with (i + 1)** option to report the cases when `++i` expression\nmay be replaced with `i + 1`:\n\n\n      int preInc(int i) {\n        int res = i;\n        return ++res;\n      }\n\n\nUse the **Report i++ when changed value is not used afterwards** option to report the cases when the result of `i++` expression\nis not used later:\n\n\n      int postInc(int i) {\n        int res = i;\n        return res++;\n      }\n"
        },
        {
          "shortName": "HashCodeUsesNonFinalVariable",
          "displayName": "Non-final field referenced in 'hashCode()'",
          "enabled": false,
          "description": "Reports implementations of `hashCode()` that access non-`final` variables.\n\n\nSuch access may result in `hashCode()`\nreturning different values at different points in the object's lifecycle, which may in turn cause problems when\nusing the standard collections classes.\n\n**Example:**\n\n\n      class Drink {\n        String name;\n        Drink(String name) { this.name = name; }\n        @Override public int hashCode() {\n          return Objects.hash(name); //warning\n        }\n      }\n      ...\n        Drink coffee = new Drink(\"Coffee\");\n        priceMap.put(coffee, 10.0);\n        coffee.name = \"Tea\";\n        double coffeePrice = priceMap.get(coffee); //not found\n\nA quick-fix is suggested to make the field final:\n\n\n      class Drink {\n        final String name;\n        ...\n      }\n"
        },
        {
          "shortName": "ObjectToString",
          "displayName": "Call to default 'toString()'",
          "enabled": true,
          "description": "Reports calls to `toString()` that use the default implementation from `java.lang.Object`.\n\nThe default implementation is rarely intended but may be used by accident.\n\n\nCalls to `toString()` on objects with `java.lang.Object`,\ninterface or abstract class type are ignored by this inspection.\n\n**Example:**\n\n\n      class Bar {\n          void foo1(Bar bar) {\n              String s = bar.toString(); // warning\n              /* ... */\n          }\n\n          void foo2(Object obj) {\n              String s = obj.toString(); // no warning here\n              /* ... */\n          }\n      }\n"
        },
        {
          "shortName": "NewObjectEquality",
          "displayName": "New object is compared using '=='",
          "enabled": true,
          "description": "Reports code that applies `==` or `!=` to a newly allocated object instead of calling `equals()`.\n\n\nThe references to newly allocated objects cannot point at existing objects,\nthus the comparison will always evaluate to `false`. The inspection may also report newly\ncreated objects returned from simple methods.\n\n**Example:**\n\n\n      void test(Object obj) {\n        if (new Object() == obj) {...}\n      }\n\nAfter the quick-fix is applied:\n\n\n      void test(Object obj) {\n        if (new Object().equals(obj)) {...}\n      }\n\n\nNew in 2018.3"
        },
        {
          "shortName": "StringEquality",
          "displayName": "String comparison using '==', instead of 'equals()'",
          "enabled": true,
          "description": "Reports code that uses of **==** or **!=** to compare strings.\n\n\nThese operators determine referential equality instead of comparing content.\nIn most cases, strings should be compared using `equals()`,\nwhich does a character-by-character comparison when the strings are different objects.\n\n**Example:**\n\n\n      void foo(String s, String t) {\n        final boolean b = t == s;\n      }\n\nIf `t` is known to be non-null, then it's safe to apply the \"unsafe\" quick-fix and get the result similar to the following:\n\n\n      void foo(String s, String t) {\n        final boolean b = t.equals(s);\n      }\n"
        },
        {
          "shortName": "StaticCallOnSubclass",
          "displayName": "Static method referenced via subclass",
          "enabled": false,
          "description": "Reports static method calls where the call is qualified by a subclass of the declaring class, rather than by the declaring class itself.\n\n\nJava allows such qualification for classes, but such calls\nmay indicate a subtle confusion of inheritance and overriding.\n\n**Example:**\n\n\n      class Parent {\n        public static void print(String str) {}\n      }\n      class Child extends Parent {}\n\n      Child.print(\"Hello, world!\");\n\nAfter the quick-fix is applied:\n\n\n      Parent.print(\"Hello, world!\");\n"
        },
        {
          "shortName": "NonShortCircuitBoolean",
          "displayName": "Non-short-circuit boolean expression",
          "enabled": false,
          "description": "Reports usages of the non-short-circuit forms of boolean 'and' and 'or' (`&` and `|`). Although the non-short-circuit versions are occasionally useful, in most cases the short-circuit forms (`&&` and `||`) are intended and such unintentional usages may lead to subtle bugs.\n\n\nA quick-fix is suggested to use the short-circuit versions.\n\n**Example:**\n\n\n      void foo(boolean x, boolean y) {\n        if (x | y) { /**/ }\n      }\n\nAfter the quick-fix is applied:\n\n\n      void foo(boolean x, boolean y) {\n        if (x || y) { /**/ }\n      }\n"
        },
        {
          "shortName": "ArrayEquality",
          "displayName": "Array comparison using '==', instead of 'Arrays.equals()'",
          "enabled": true,
          "description": "Reports operators `==` and `!=` used to test for array equality. In most cases, testing for the equality of array contents is intended, which can be done with the `java.util.Arrays.equals()` method.\n\n\nA quick-fix is suggested to replace `==` with `java.util.Arrays.equals()`.\n\n**Example:**\n\n\n      void foo(Object[] x, Object[] y) {\n        boolean comparison = x == y;\n      }\n\nAfter the quick-fix is applied:\n\n\n      void foo(Object[] x, Object[] y) {\n        boolean comparison = Arrays.equals(x, y);\n      }\n"
        },
        {
          "shortName": "OverflowingLoopIndex",
          "displayName": "Loop executes zero or billions of times",
          "enabled": true,
          "description": "Reports loops that cannot be completed without an index overflow or loops that don't loop at all. It usually happens because of a mistake in the update operation.\n\nExample:\n\n\n      void foo(int s) {\n        for (int i = s; i > 12; i++) { // i-- should be here\n          System.out.println(i);\n        }\n      }\n\nNew in 2019.1"
        },
        {
          "shortName": "EmptyStatementBody",
          "displayName": "Statement with empty body",
          "enabled": true,
          "description": "Reports `if`, `while`, `do`, `for`, and `switch` statements with empty bodies.\n\nWhile occasionally intended, such code is confusing and is often the result of a typo.\n\nThis inspection is disabled in JSP files."
        },
        {
          "shortName": "IteratorHasNextCallsIteratorNext",
          "displayName": "'Iterator.hasNext()' which calls 'next()'",
          "enabled": true,
          "description": "Reports implementations of `Iterator.hasNext()` or `ListIterator.hasPrevious()` that call `Iterator.next()` or `ListIterator.previous()` on the iterator instance. Such calls are almost certainly an error, as methods like `hasNext()` should not modify the iterators state, while `next()` should.\n\n**Example:**\n\n\n      class MyIterator implements Iterator<Integer> {\n        public boolean hasNext() {\n          return next() != null;\n        }\n      }\n"
        },
        {
          "shortName": "EqualsAndHashcode",
          "displayName": "'equals()' and 'hashCode()' not paired",
          "enabled": true,
          "description": "Reports classes that override the `equals()` method but do not override the `hashCode()` method or vice versa, which can potentially lead to problems when the class is added to a `Collection` or a `HashMap`.\n\nThe quick-fix generates the default implementation for an absent method.\n\nExample:\n\n\n    class StringHolder {\n      String s;\n\n      @Override public int hashCode() {\n        return s != null ? s.hashCode() : 0;\n      }\n    }\n\nAfter the quick-fix is applied:\n\n\n    class StringHolder {\n      String s;\n\n      @Override public int hashCode() {\n        return s != null ? s.hashCode() : 0;\n      }\n\n      @Override\n      public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof StringHolder)) return false;\n\n        StringHolder holder = (StringHolder)o;\n\n        if (s != null ? !s.equals(holder.s) : holder.s != null) return false;\n\n        return true;\n      }\n    }\n"
        },
        {
          "shortName": "CastConflictsWithInstanceof",
          "displayName": "Cast conflicts with 'instanceof'",
          "enabled": true,
          "description": "Reports type cast expressions that are preceded by an `instanceof` check for a different type.\n\n\nAlthough this might be intended, such a construct is most likely an error, and will\nresult in a `java.lang.ClassCastException` at runtime.\n\n**Example:**\n\n\n      class Main {\n        int whenCharSequenceCastToNumber(Object o){\n          if (o instanceof CharSequence) {\n            return ((Number) o).intValue();\n          }\n          return 0;\n        }\n\n        int earlyReturnWhenNotCharSequence(Object o){\n          if (!(o instanceof CharSequence)) return 0;\n          return ((Number)o).intValue();\n        }\n      }\n"
        },
        {
          "shortName": "Contract",
          "displayName": "Contract issues",
          "enabled": true,
          "description": "Reports issues in method `@Contract` annotations. The types of issues that can be reported are:\n\n* Errors in contract syntax\n* Contracts that do not conform to the method signature (wrong parameter count)\n* Method implementations that contradict the contract (e.g. return `true` when the contract says `false`)\n\nExample:\n\n\n      // method has no parameters, but contract expects 1\n      @Contract(\"_ -> fail\")\n      void x() {\n        throw new AssertionError();\n      }\n"
        },
        {
          "shortName": "SuspiciousArrayMethodCall",
          "displayName": "Suspicious 'Arrays' method call",
          "enabled": true,
          "description": "Reports calls to non-generic-array manipulation methods like `Arrays.fill()` with mismatched argument types. Such calls don't do anything useful and are likely to be mistakes.\n\n**Example:**\n\n\n      int foo(String[] strings) {\n        return Arrays.binarySearch(strings, 1);\n      }\n\nNew in 2017.2"
        },
        {
          "shortName": "OverwrittenKey",
          "displayName": "Overwritten Map, Set, or array element",
          "enabled": true,
          "description": "Reports code that overwrites a `Map` key, a `Set` element, or an array element in a sequence of `add`/`put` calls or using a Java 9 factory method like `Set.of` (which will result in runtime exception).\n\nThis usually occurs due to a copy-paste error.\n\n**Example:**\n\n\n      map.put(\"A\", 1);\n      map.put(\"B\", 2);\n      map.put(\"C\", 3);\n      map.put(\"D\", 4);\n      map.put(\"A\", 5); // duplicating key \"A\", overwrites the previously written entry\n\nNew in 2017.3"
        },
        {
          "shortName": "SuspiciousIntegerDivAssignment",
          "displayName": "Suspicious integer division assignment",
          "enabled": true,
          "description": "Reports assignments whose right side is a division that shouldn't be truncated to integer.\n\nWhile occasionally intended, this construction is often buggy.\n\n**Example:**\n\n\n      int x = 18;\n      x *= 3/2; // doesn't change x because of the integer division result\n\n\nThis code should be replaced with:\n\n\n      int x = 18;\n      x *= 3.0/2;\n\n\nIn the inspection options, you can disable warnings for suspicious but possibly correct divisions,\nfor example, when the dividend can't be calculated statically.\n\n\n      void calc(int d) {\n         int x = 18;\n         x *= d/2;\n      }\n\n\nNew in 2019.2"
        },
        {
          "shortName": "CastToIncompatibleInterface",
          "displayName": "Casting to incompatible interface",
          "enabled": true,
          "description": "Reports type cast expressions where the cast type is an interface and the cast expression has a class type that neither implements the cast interface, nor has any visible subclasses that implement the cast interface.\n\n\nAlthough this might be intended, such a construct is most likely an error, and will\nresult in a `java.lang.ClassCastException` at runtime.\n\n**Example:**\n\n\n      interface A {}\n      interface Z {}\n      static class C {}\n\n      void x(C c) {\n        if (c instanceof Z) {\n          A a = ((A)c); // cast to incompatible interface 'A'\n        }\n      }\n"
        },
        {
          "shortName": "InstanceofIncompatibleInterface",
          "displayName": "'instanceof' with incompatible interface",
          "enabled": true,
          "description": "Reports `instanceof` expressions where the compared type is an interface, and the compared expression has a class type that neither implements the compared interface, nor has any visible subclasses which implement the compared interface.\n\n\nAlthough that might be intended, normally such a construct is most likely an error, where\nthe resulting `instanceof` expression always evaluates to `false`.\n\n**Example:**\n\n\n      interface I1 {}\n\n      interface I2 {}\n\n      interface I3 extends I1 {}\n\n      static class Sub1 implements I1 {}\n\n      static class Sub2 extends Sub1 implements I2 {\n        void test(Sub1 sub1) {\n          if (sub1 instanceof I3) { // here 'I3' is incompatible interface\n          }\n        }\n      }\n"
        },
        {
          "shortName": "NullArgumentToVariableArgMethod",
          "displayName": "Confusing argument to varargs method",
          "enabled": true,
          "description": "Reports calls to variable arity methods that have a single argument in the vararg parameter position, which is either a `null` or an array of a subtype of the vararg parameter. Such an argument may be confusing as it is unclear if a varargs or non-varargs call is desired.\n\n**Example:**\n\n\n      String[] ss = new String[]{\"foo\", \"bar\"};\n      System.out.printf(\"%s\", ss);\n\nIn this example only the first element of the array will be printed, not the entire array."
        },
        {
          "shortName": "InfiniteRecursion",
          "displayName": "Infinite recursion",
          "enabled": true,
          "description": "Reports methods that call themselves infinitely unless an exception is thrown.\n\n\nMethods reported by this inspection cannot return normally.\nWhile such behavior may be intended, in many cases this is just an oversight.\n\n**Example:**\n\n      int baz() {\n          return baz();\n      }\n"
        },
        {
          "shortName": "VariableNotUsedInsideIf",
          "displayName": "Reference checked for 'null' is not used inside 'if'",
          "enabled": false,
          "description": "Reports references to variables that are checked for nullability in the condition of an `if` statement or conditional expression but not used inside that `if` statement.\n\n\nUsually this either means that\nthe check is unnecessary or that the variable is not referenced inside the\n`if` statement by mistake.\n\n**Example:**\n\n\n      void test(Integer i) {\n        if (i != null) { // here 'i' is not used inside 'if' statement\n          System.out.println();\n        }\n      }\n"
        },
        {
          "shortName": "SuspiciousMethodCalls",
          "displayName": "Suspicious collection method call",
          "enabled": true,
          "description": "Reports method calls on parameterized collections, where the actual argument type does not correspond to the collection's elements type.\n\n**Example:**\n\n\n      List<Integer> list = getListOfElements();\n      list.remove(\"\"); // remove is highlighted\n\n\nIn the inspection settings, you can disable warnings for potentially correct code like the following:\n\n\n      public boolean accept(Map<Integer, String> map, Object key) {\n        return map.containsKey(key);\n      }\n"
        },
        {
          "shortName": "IncompleteDestructuring",
          "displayName": "Incomplete destructuring declaration",
          "enabled": false,
          "description": "Reports incomplete destructuring declaration.\n\n**Example:**\n\n\n      data class Person(val name: String, val age: Int)\n      val person = Person(\"\", 0)\n      val (name) = person\n\nThe quick fix completes destructuring declaration with new variables:\n\n\n      data class Person(val name: String, val age: Int)\n      val person = Person(\"\", 0)\n      val (name, age) = person\n"
        },
        {
          "shortName": "CanSealedSubClassBeObject",
          "displayName": "Sealed sub-class without state and overridden equals",
          "enabled": true,
          "description": "Reports direct inheritors of `sealed` classes that have no state and overridden `equals()` method.\n\nIt's highly recommended to override `equals()` to provide comparison stability, or convert the `class` to an `object` to reach the same effect.\n\n**Example:**\n\n\n      sealed class Receiver {\n          class Everyone : Receiver()\n          class User(val id: Int) : Receiver()\n      }\n\nA quick-fix converts a `class` into an `object`:\n\n\n      sealed class Receiver {\n          object Everyone : Receiver()\n          class User(val id: Int) : Receiver()\n      }\n"
        },
        {
          "shortName": "UselessCallOnCollection",
          "displayName": "Useless call on collection type",
          "enabled": true,
          "description": "Reports `filter...` calls from the standard library on already filtered collections.\n\nSeveral functions from the standard library such as `filterNotNull()` or `filterIsInstance`\nhave sense only when they are called on receivers that have types distinct from the resulting one. Otherwise,\nsuch calls can be omitted as the result will be the same.\n\n**Remove redundant call** quick-fix can be used to amend the code automatically.\n\nExample:\n\n\n      fun test(list: List<String>) {\n          val x = list.filterNotNull() // quick-fix simplifies to 'list'\n          val y = list.filterIsInstance<String>() // quick-fix simplifies to 'list'\n      }\n"
        },
        {
          "shortName": "KotlinCovariantEquals",
          "displayName": "Covariant 'equals()'",
          "enabled": true,
          "description": "Reports `equals()` that takes an argument type other than `Any?` if the class does not have another `equals()` that takes `Any?` as its argument type.\n\n**Example:**\n\n\n      class Foo {\n          fun equals(other: Foo?): Boolean {\n              return true\n          }\n      }\n\nTo fix the problem create `equals()` method that takes an argument of type `Any?`."
        },
        {
          "shortName": "WrapUnaryOperator",
          "displayName": "Ambiguous unary operator use with number constant",
          "enabled": true,
          "description": "Reports an unary operator followed by a dot qualifier such as `-1.inc()`.\n\nCode like `-1.inc()` can be misleading because `-` has a lower precedence than `.inc()`.\nAs a result, `-1.inc()` evaluates to `-2` and not `0` as it might be expected.\n\n**Wrap unary operator and value with ()** quick-fix can be used to amend the code automatically."
        },
        {
          "shortName": "ConflictingExtensionProperty",
          "displayName": "Extension property conflicting with synthetic one",
          "enabled": true,
          "description": "Reports extension properties that conflict with synthetic ones that have been automatically produced from Java `get` or `set` methods.\n\nSuch properties should be either removed or renamed to avoid breaking code by future changes in the compiler.\n\nA quick-fix deletes an extention property.\n\n**Example:**\n\n\n      val File.name: String\n          get() = getName()\n\nA quick-fix adds the `@Deprecated` annotation:\n\n\n      @Deprecated(\"Is replaced with automatic synthetic extension\", ReplaceWith(\"name\"), level = DeprecationLevel.HIDDEN)\n      val File.name: String\n          get() = getName()\n"
        },
        {
          "shortName": "SuspiciousVarProperty",
          "displayName": "Suspicious 'var' property: its setter does not influence its getter result",
          "enabled": true,
          "description": "Reports `var` properties with default setter and getter that do not reference backing field.\n\n\nSuch properties do not affect calling its setter; therefore, it will be clearer to change such property to `val` and delete the initializer.\n\n**Change to val and delete initializer** quick-fix can be used to amend the code automatically.\n\nExample:\n\n\n      // This property always returns '1' and it doesn't important that the property is a 'var'\n      var foo: Int = 0\n          get() = 1\n"
        },
        {
          "shortName": "ReplaceArrayEqualityOpWithArraysEquals",
          "displayName": "Arrays comparison via '==' and '!='",
          "enabled": true,
          "description": "Reports usages of `==` or `!=` operator for arrays that should be replaced with `contentEquals()`.\n\n\nThe `==` and `!=`operators compare array references instead of their content.\n\n**Examples:**\n\n      fun test() {\n          val a = arrayOf(1, 2, 3)\n          val b = arrayOf(1, 2, 3)\n          println(a == b) // references comparison\n      }\n\nAfter the quick-fix is applied:\n\n      fun test() {\n          val a = arrayOf(1, 2, 3)\n          val b = arrayOf(1, 2, 3)\n          println(a.contentEquals(b))\n      }\n"
        },
        {
          "shortName": "UnusedUnaryOperator",
          "displayName": "Unused unary operator",
          "enabled": true,
          "description": "Reports unary operators for number types on unused expressions.\n\nUnary operators break previous expression if they are used without braces.\nAs a result, mathematical expressions spanning multi lines can be misleading.\n\nExample:\n\n\n      fun main() {\n          val result = 1 + 2 * 3\n                      + 3              // <== note that '+ 3' doesn't belong to the 'result' variable, it is unused\n          println(\"Result = $result\")  // The result is '7' and not '10' as it might be expected\n      }\n"
        },
        {
          "shortName": "LateinitVarOverridesLateinitVar",
          "displayName": "'lateinit var' property overrides 'lateinit var' property",
          "enabled": true,
          "description": "Reports `lateinit var` properties that override other `lateinit var` properties.\n\nA subclass instance will have two fields for a single property, and the one from the superclass will remain effectively unused.\n\n**Example:**\n\n\n        open class BaseClass {\n          open lateinit var name: String\n        }\n\n        class RealClass : BaseClass() {\n          override lateinit var name: String\n        }\n"
        },
        {
          "shortName": "KotlinEqualsBetweenInconvertibleTypes",
          "displayName": "'equals()' between objects of inconvertible types",
          "enabled": true,
          "description": "Reports calls to `equals()` where the receiver and the argument are of incompatible primitive, enum, or string types.\n\nWhile such a call might theoretically be useful, most likely it represents a bug.\n\n**Example:**\n\n      5.equals(\"\");\n"
        },
        {
          "shortName": "DataClassPrivateConstructor",
          "displayName": "Private data class constructor is exposed via the 'copy' method",
          "enabled": true,
          "description": "Reports the `private` primary constructor in data classes.\n\n\n`data` classes have a `copy()` factory method that can be used similarly to a constructor.\nA constructor should not be marked as `private` to provide enough safety.\n\n**Example:**\n\n\n      data class User private constructor(val name: String)\n\nA quick-fix changes the constructor visibility modifier to `public`:\n\n\n      data class User(val name: String)\n"
        },
        {
          "shortName": "SetterBackingFieldAssignment",
          "displayName": "Existing backing field without assignment",
          "enabled": true,
          "description": "Reports property setters that don't update the backing field.\n\nThe quick-fix adds an assignment to the backing field.\n\n**Example:**\n\n\n      class Test {\n          var foo: Int = 1\n              set(value) {\n              }\n      }\n\nAfter the quick-fix is applied:\n\n\n      class Test {\n          var foo: Int = 1\n              set(value) {\n                  field = value\n              }\n      }\n"
        },
        {
          "shortName": "DelegationToVarProperty",
          "displayName": "Delegating to 'var' property",
          "enabled": true,
          "description": "Reports interface delegation to a `var` property.\n\nOnly initial value of a property is used for delegation, any later assignments do not affect it.\n\n**Example:**\n\n\n      class Example(var text: CharSequence): CharSequence by text\n\nA quick-fix replaces a property with immutable one:\n\n\n      class Example(val text: CharSequence): CharSequence by text\n\nAlternative way, if you rely on mutability for some reason:\n\n\n      class Example(text: CharSequence): CharSequence by text {\n          var text = text\n      }\n"
        },
        {
          "shortName": "ConvertNaNEquality",
          "displayName": "Convert equality check with 'NaN' to 'isNaN' call",
          "enabled": true,
          "description": "Reports an equality check with `Float.NaN` or `Double.NaN` that should be replaced with an `isNaN()` check.\n\n\nAccording to IEEE 754, equality check against NaN always returns `false`, even for `NaN == NaN`.\nTherefore, such a check is likely to be a mistake.\n\nA quick-fix replaces comparison with `isNaN()` check that uses a different comparison technique and handles `NaN` values correctly.\n\n**Example:**\n\n\n      fun check(value: Double): Boolean {\n          return Double.NaN == value\n      }\n\nAfter the fix is applied:\n\n\n      fun check(value: Double): Boolean {\n          return value.isNaN()\n      }\n"
        },
        {
          "shortName": "KotlinCatchMayIgnoreException",
          "displayName": "'catch' block may ignore exception",
          "enabled": false,
          "description": "Reports `catch` blocks that are empty or may ignore an exception.\n\nWhile occasionally intended, empty `catch` blocks may complicate debugging.\nAlso, ignoring a `catch` parameter might be wrong.\n\n\nThe inspection won't report any `catch` parameters named `ignore`, `ignored`, or `_`.\n\n\nYou can use a quick-fix to change the exception name to `_`.\n\n**Example:**\n\n\n      try {\n        throwingMethod()\n      } catch (ex: IOException) {\n\n      }\n\nAfter the quick-fix is applied:\n\n\n      try {\n        throwingMethod()\n      } catch (_: IOException) {\n\n      }\n\nUse the **Do not warn when 'catch' block contains a comment** option to ignore `catch` blocks with comments."
        },
        {
          "shortName": "SuspendFunctionOnCoroutineScope",
          "displayName": "Ambiguous coroutineContext due to CoroutineScope receiver of suspend function",
          "enabled": true,
          "description": "Reports calls and accesses of `CoroutineScope` extensions or members inside suspend functions with `CoroutineScope` receiver.\n\nWhen a function is `suspend` and has `CoroutineScope` receiver,\nit has ambiguous access to `CoroutineContext` via `kotlin.coroutines.coroutineContext` and via `CoroutineScope.coroutineContext`,\nand two these contexts are different in general.\n\n\nTo improve this situation, one can wrap suspicious call inside `coroutineScope { ... }` or\nget rid of `CoroutineScope` function receiver."
        },
        {
          "shortName": "ImplicitNullableNothingType",
          "displayName": "Implicit 'Nothing?' type",
          "enabled": true,
          "description": "Reports variables and functions with the implicit **Nothing?** type.\n\n**Example:**\n\n\n      fun foo() = null\n\nThe quick fix specifies the return type explicitly:\n\n\n      fun foo(): Nothing? = null\n"
        },
        {
          "shortName": "KDocUnresolvedReference",
          "displayName": "Unresolved reference in KDoc",
          "enabled": false,
          "description": "Reports unresolved references in KDoc comments.\n\n**Example:**\n\n\n      /**\n       * [unresolvedLink]\n       */\n      fun foo() {}\n\nTo fix the problem make the link valid."
        },
        {
          "shortName": "KotlinConstantConditions",
          "displayName": "Constant conditions",
          "enabled": false,
          "description": "Reports non-trivial conditions and values that are statically known to be always true, false, null or zero. While sometimes intended, often this is a sign of logical error in the program. Additionally, reports never reachable `when` branches and some expressions that are statically known to fail always.\n\nExamples:\n\n\n    fun process(x: Int?) {\n      val isNull = x == null\n      if (!isNull) {\n        if (x != null) {} // condition is always true\n        require(x!! < 0 && x > 10) // condition is always false\n      } else {\n        println(x!!) // !! operator will always fail\n      }\n    }\n    fun process(v: Any) {\n      when(v) {\n        is CharSequence -> println(v as Int) // cast will always fail\n        is String -> println(v) // branch is unreachable\n      }\n    }\n\nNew in 2021.3"
        },
        {
          "shortName": "ForEachParameterNotUsed",
          "displayName": "Iterated elements are not used in forEach",
          "enabled": true,
          "description": "Reports `forEach` loops that do not use iterable values.\n\n**Example:**\n\n\n      listOf(1, 2, 3).forEach { }\n\nThe quick fix introduces anonymous parameter in the `forEach` section:\n\n\n      listOf(1, 2, 3).forEach { _ -> }\n"
        },
        {
          "shortName": "LeakingThis",
          "displayName": "Leaking 'this' in constructor",
          "enabled": true,
          "description": "Reports unsafe operations with `this` during object construction including:\n\n* Accessing a non-final property during class initialization: from a constructor or property initialization\n* Calling a non-final function during class initialization\n* Using `this` as a function argument in a constructor of a non-final class\n\n\nIf other classes inherit from the given class,\nthey may not be fully initialized at the moment when an unsafe operation is carried out.\n\n**Example:**\n\n\n      abstract class Base {\n          val code = calculate()\n          abstract fun calculate(): Int\n      }\n\n      class Derived(private val x: Int) : Base() {\n          override fun calculate() = x\n      }\n\n      fun testIt() {\n          println(Derived(42).code) // Expected: 42, actual: 0\n      }\n"
        },
        {
          "shortName": "KotlinThrowableNotThrown",
          "displayName": "Throwable not thrown",
          "enabled": true,
          "description": "Reports instantiations of `Throwable` or its subclasses, when the created `Throwable` is never actually thrown.\n\nThe reported code indicates mistakes that are hard to catch in tests.\n\n\nAlso, this inspection reports method calls that return instances of `Throwable` or its subclasses,\nwhen the resulting `Throwable` instance is not thrown.\n\n**Example:**\n\n\n      fun check(condition: Boolean) {\n          if (!condition) /* throw is missing here */ IllegalArgumentException(\"condition is not met\");\n      }\n\n      fun createError() = RuntimeException()\n\n      fun foo() {\n          /* throw is missing here */ createError()\n      }\n"
        },
        {
          "shortName": "SelfAssignment",
          "displayName": "Redundant assignment",
          "enabled": true,
          "description": "Reports assignments of a variable to itself.\n\nThe quick-fix removes the redundant assignment.\n\n**Example:**\n\n\n      fun test() {\n          var bar = 1\n          bar = bar\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun test() {\n          var bar = 1\n      }\n"
        },
        {
          "shortName": "RecursiveEqualsCall",
          "displayName": "Recursive equals call",
          "enabled": true,
          "description": "Reports recursive `equals`(`==`) calls.\n\n\nIn Kotlin, `==` compares object values by calling `equals` method under the hood.\n`===`, on the other hand, compares objects by reference.\n\n\n`===` is commonly used in `equals` method implementation.\nBut `===` may be mistakenly mixed up with `==` leading to infinite recursion.\n\n**Example:**\n\n\n      class X {\n          override fun equals(other: Any?): Boolean {\n              if (this == other) return true\n              return false\n          }\n      }\n\nAfter the quick-fix is applied:\n\n\n      class X {\n          override fun equals(other: Any?): Boolean {\n              if (this === other) return true\n              return false\n          }\n      }\n"
        },
        {
          "shortName": "UnsafeCastFromDynamic",
          "displayName": "Implicit (unsafe) cast from dynamic type",
          "enabled": false,
          "description": "Reports expressions with a dynamic type in the specified inspection scope that are implicitly cast to another type."
        },
        {
          "shortName": "ControlFlowWithEmptyBody",
          "displayName": "Control flow with empty body",
          "enabled": true,
          "description": "Reports `if`, `while`, `do` or `for` statements with empty bodies.\n\nWhile occasionally intended, this construction is confusing and often the result of a typo.\n\nA quick-fix removes a statement.\n\n**Example:**\n\n\n      if (a > b) {}\n"
        },
        {
          "shortName": "ArrayInDataClass",
          "displayName": "Array property in data class",
          "enabled": true,
          "description": "Reports properties with an `Array` type in a `data` class without overridden `equals()` or `hashCode()`.\n\n\nArray parameters are compared by reference equality, which is likely an unexpected behavior.\nIt is strongly recommended to override `equals()` and `hashCode()` in such cases.\n\n**Example:**\n\n\n      data class Text(val lines: Array<String>)\n\nA quick-fix generates missing `equals()` and `hashCode()` implementations:\n\n\n      data class Text(val lines: Array<String>) {\n          override fun equals(other: Any?): Boolean {\n              if (this === other) return true\n              if (javaClass != other?.javaClass) return false\n\n              other as Text\n\n              if (!lines.contentEquals(other.lines)) return false\n\n              return true\n          }\n\n          override fun hashCode(): Int {\n              return lines.contentHashCode()\n          }\n      }\n"
        },
        {
          "shortName": "SuspiciousCollectionReassignment",
          "displayName": "Augmented assignment creates a new collection under the hood",
          "enabled": true,
          "description": "Reports augmented assignment (`+=`) expressions on read-only `Collection`.\n\nAugment assignment (`+=`) expression on read-only `Collection` doesn't modify the target collection,\nit creates a new one under the hood which can be misleading and lead to performance issues.\n\n**Change type to mutable** quick-fix can be used to amend the code automatically.\n\nExample:\n\n\n      fun test() {\n          var list = listOf(0)\n          list += 42 // new list is created, variable 'list' still contains only '0'\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun test() {\n          val list = mutableListOf(0)\n          list += 42\n      }\n"
        },
        {
          "shortName": "EmptyRange",
          "displayName": "Range with start greater than endInclusive is empty",
          "enabled": true,
          "description": "Reports ranges that are empty because the `start` value is greater than the `endInclusive` value.\n\n**Example:**\n\n\n      val range = 2..1\n\nThe quick-fix changes the `..` operator to `downTo`:\n\n\n      val range = 2 downTo 1\n"
        },
        {
          "shortName": "RecursivePropertyAccessor",
          "displayName": "Recursive property accessor",
          "enabled": true,
          "description": "Reports recursive property accessor calls which can end up with a `StackOverflowError`.\nSuch calls are usually confused with backing field access.\n\n**Example:**\n\n\n      var counter: Int = 0\n          set(value) {\n              counter = if (value < 0) 0 else value\n          }\n\nAfter the quick-fix is applied:\n\n\n      var counter: Int = 0\n          set(value) {\n              field = if (value < 0) 0 else value\n          }\n"
        },
        {
          "shortName": "DestructuringWrongName",
          "displayName": "Variable in destructuring declaration uses name of a wrong data class property",
          "enabled": true,
          "description": "Reports entries of destructuring declarations that match the name of a different property of the destructured data class.\n\n**Example:**\n\n\n      data class Foo(val a: String, val b: Int, val c: String)\n\n      fun bar(f: Foo) {\n          val (a, c) = f\n      }\n\nThe quick-fix changes variable's name to match the name of the corresponding class field:\n\n\n      data class Foo(val a: String, val b: Int, val c: String)\n\n      fun bar(f: Foo) {\n          val (a, b) = f\n      }\n"
        },
        {
          "shortName": "SuspiciousEqualsCombination",
          "displayName": "Suspicious combination of == and ===",
          "enabled": true,
          "description": "Reports `==` and `===` comparisons that are both used on the same variable within a single expression.\n\nDue to similarities `==` and `===` could be mixed without notice, and\nit takes a close look to check that `==` used instead of `===`\n\nExample:\n\n\n      if (type === FIELD || type == METHOD || type == ANNOTATION_METHOD || // Note that \"==\" is used incorrectly\n          type === LAMBDA_EXPRESSION) return\n"
        },
        {
          "shortName": "UnusedDataClassCopyResult",
          "displayName": "Unused result of data class copy",
          "enabled": true,
          "description": "Reports calls to data class `copy` function without using its result."
        },
        {
          "shortName": "DeferredResultUnused",
          "displayName": "'@Deferred' result is unused",
          "enabled": true,
          "description": "Reports function calls with the `Deferred` result type if the return value is not used.\n\nIf the `Deferred` return value is not used, the call site would not wait to complete this function.\n\n**Example:**\n\n\n      fun calcEverythingAsync() = CompletableDeferred(42)\n\n      fun usage() {\n          calcEverythingAsync()\n      }\n\nA quick-fix provides a variable with the `Deferred` initializer:\n\n\n      fun calcEverythingAsync() = CompletableDeferred(42)\n\n      fun usage() {\n          val answer = calcEverythingAsync()\n      }\n"
        },
        {
          "shortName": "SelfReferenceConstructorParameter",
          "displayName": "Constructor can never be complete",
          "enabled": true,
          "description": "Reports constructors with a non-null self-reference parameter.\n\nSuch constructors never instantiate a class.\n\nThe quick-fix converts the parameter type to nullable.\n\n**Example:**\n\n\n      class SelfRef(val ref: SelfRef)\n\nAfter the quick-fix is applied:\n\n\n      class SelfRef(val ref: SelfRef?)\n"
        },
        {
          "shortName": "MainFunctionReturnUnit",
          "displayName": "Entry point function should return Unit",
          "enabled": true,
          "description": "Reports entry point functions with an incorrect return type (should be `Unit`).\n\n**Example:**\n`fun main() = \"Hello world!\"`"
        },
        {
          "shortName": "SuspiciousCallableReferenceInLambda",
          "displayName": "Suspicious callable reference used as lambda result",
          "enabled": true,
          "description": "Reports lambda expressions with one callable reference.\n\nIt is a common error to replace a lambda with a callable reference without changing curly braces to parentheses.\n\n**Example:**\n\n      listOf(1,2,3).map { it::toString }\n\nAfter the quick-fix is applied:\n\n      listOf(1,2,3).map(Int::toString)\n"
        },
        {
          "shortName": "UnusedEquals",
          "displayName": "Unused equals expression",
          "enabled": true,
          "description": "Reports unused `equals`(`==`) expressions."
        },
        {
          "shortName": "UselessCallOnNotNull",
          "displayName": "Useless call on not-null type",
          "enabled": true,
          "description": "Reports calls on not-null receiver that make sense only for nullable receiver.\n\nSeveral functions from the standard library such as `orEmpty()` or `isNullOrEmpty`\nhave sense only when they are called on receivers of nullable types. Otherwise, they can be omitted or simplified as the result will be the same.\n\n**Remove redundant call** and **Change call to ...** quick-fixes can be used to amend the code automatically.\n\nExamples:\n\n\n      fun test(s: String) {\n          val x = s.orEmpty() // quick-fix simplifies to 's'\n          val y = s.isNullOrEmpty() // quick-fix simplifies to 's.isEmpty()'\n      }\n"
        },
        {
          "shortName": "UnusedLambdaExpressionBody",
          "displayName": "Unused return value of a function with lambda expression body",
          "enabled": true,
          "description": "Reports calls with an unused return value when the called function returns a lambda from an expression body.\n\n\nIf there is `=` between function header and body block,\ncode from the function will not be evaluated which can lead to incorrect behavior.\n\n**Remove = token from function declaration** can be used to amend the code automatically.\n\nExample:\n\n\n      fun printHello() = { println(\"Hello\") }\n\n      fun main() {\n          printHello() // This function doesn't print anything\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun printHello() { println(\"Hello\") }\n\n      fun main() {\n          printHello()\n      }\n"
        },
        {
          "shortName": "EqualsOrHashCode",
          "displayName": "'equals()' and 'hashCode()' not paired",
          "enabled": true,
          "description": "Reports classes that override `equals()` but do not override `hashCode()`, or vice versa. It also reports object declarations that override either `equals()` or `hashCode()`.\n\nThis can lead to undesired behavior when a class is added to a `Collection`\n\n**Example:**\n\n\n      class C1 {\n          override fun equals(other: Any?) = true\n      }\n\n      class C2 {\n          override fun hashCode() = 0\n      }\n\n      object O1 {\n          override fun equals(other: Any?) = true\n      }\n\n      object O2 {\n          override fun hashCode() = 0\n      }\n\nThe quick-fix overrides `equals()` or `hashCode()` for classes and deletes these methods for objects:\n\n\n       class C1 {\n           override fun equals(other: Any?) = true\n           override fun hashCode(): Int {\n               return javaClass.hashCode()\n           }\n       }\n\n       class C2 {\n           override fun hashCode() = 0\n           override fun equals(other: Any?): Boolean {\n               if (this === other) return true\n               if (javaClass != other?.javaClass) return false\n               return true\n           }\n       }\n\n       object O1 {\n       }\n\n       object O2 {\n       }\n"
        },
        {
          "shortName": "GroovyInArgumentCheck",
          "displayName": "Incompatible 'in' argument types",
          "enabled": false,
          "description": "Reports usages of membership operator `in` with items and containers of incompatible types.\n\n**Example:**\n\n\n    def list = [1, 2]\n    if (\"foo\" in list) {} // list of Integers can't contain String\n\n"
        },
        {
          "shortName": "GroovyAccessibility",
          "displayName": "Inaccessible element",
          "enabled": false,
          "description": "Reports references which exceed access rights.\n\nAccess to private members breaks encapsulation."
        },
        {
          "shortName": "GroovyNonShortCircuitBoolean",
          "displayName": "Non short-circuit boolean",
          "enabled": false,
          "description": "Reports the non-short-circuit forms of boolean operators 'and' and 'or' ( `&` and `|` ).\n\n\nThe non-short-circuit versions are occasionally useful, but\ntheir presence is often due to typos of the short-circuit forms ( `&&`\nand `||` ), and may lead to subtle bugs.\n\n**Example:**\n\n\n    if (a & b) {}\n\nAfter the quick-fix is applied:\n\n\n    if (a && b) {}\n"
        },
        {
          "shortName": "GroovyDivideByZero",
          "displayName": "Division by zero",
          "enabled": false,
          "description": "Reports divisions by zero or remainders by zero.\n\n**Example:**\n\n\n      def a = 42\n      a / 0 // warning\n      a % 0.0 // warning\n"
        },
        {
          "shortName": "GrSwitchExhaustivenessCheck",
          "displayName": "Exhaustiveness check for switch expressions",
          "enabled": false,
          "description": "Reports switch expressions that do not cover all possible outcomes of the matched expression.\n\n\nGroovy does not require that switch expression must be exhaustive. It acts as if an implicit `default -> null` branch is inserted.\nIt may cause unexpected nulls if a developer forgets to insert necessary `case` branches.\n\n**Example:**\n\n\n      enum A { X, Y }\n\n      def foo(A a) {\n        def x = switch (a) { // reports switch\n          case A.X -> ...\n        }\n      }\n"
        },
        {
          "shortName": "GroovyUntypedAccess",
          "displayName": "Untyped reference expression",
          "enabled": false,
          "description": "Reports reference expressions whose type can't be determined."
        },
        {
          "shortName": "GroovyResultOfObjectAllocationIgnored",
          "displayName": "Result of object allocation ignored",
          "enabled": false,
          "description": "Reports object allocation where the result of this operation is ignored.\n\n\nSuch allocation expressions are legal Groovy, but are usually either inadvertent, or\nevidence of a complicated object initialization strategy."
        },
        {
          "shortName": "GroovyDocCheck",
          "displayName": "Unresolved GroovyDoc reference",
          "enabled": false,
          "description": "Reports unresolved references inside GroovyDoc comments."
        },
        {
          "shortName": "GroovyLabeledStatement",
          "displayName": "Labeled statement inspection",
          "enabled": false,
          "description": "Reports labels already used in parent workflow.\n\n**Example:**\n\n\n    def list = [\"foo\"]\n    cycle:\n    for (element in list) {\n      cycle: // confusing label repeat\n      element.chars().forEach {\n      }\n    }\n\n"
        },
        {
          "shortName": "GroovyConstructorNamedArguments",
          "displayName": "Named arguments of constructor call",
          "enabled": false,
          "description": "Reports named arguments of a default class constructor call which don't correspond to properties of this class.\n\n**Example:**\n\n\n      class Person {\n          def name\n          def age\n      }\n\n      // 'firstName' property doesn't exist\n      new Person(firstName: \"John\")\n"
        },
        {
          "shortName": "GrUnresolvedAccess",
          "displayName": "Unresolved reference expression",
          "enabled": false,
          "description": "Reports reference expressions which cannot be resolved."
        },
        {
          "shortName": "SecondUnsafeCall",
          "displayName": "Second unsafe call",
          "enabled": false,
          "description": "Reports possible **NullPointerException** during chain methods or properties call.\n\n**Example:**\n\n\n      domain?.getZone().getName()\n\nAfter the quick-fix is applied:\n\n\n      domain?.getZone()?.getName()\n"
        },
        {
          "shortName": "GroovyInfiniteLoopStatement",
          "displayName": "Infinite loop statement",
          "enabled": false,
          "description": "Reports `for`, `while`, or `do` statements which can only exit by throwing an exception. While such statements may be correct, they usually happen by mistake.\n\n**Example:**\n\n\n    while(true) {\n      Thread.sleep(1000)\n    }\n\n"
        },
        {
          "shortName": "GrPermitsClause",
          "displayName": "Non-extending permitted subclasses",
          "enabled": false,
          "description": "Reports permitted classes that do not extend the sealed base class.\n\n\nGroovy does not require that all permitted classes should be available in compile-time and compiled along with base class. Compiler will not warn the user on dealing with non-extending permitted subclass, but it contradicts the nature of sealed classes.\n\n**Example:**\n\n\n      class A permits B {} // reports B\n      class B {}\n"
        },
        {
          "shortName": "GrEqualsBetweenInconvertibleTypes",
          "displayName": "'equals()' between objects of inconvertible types",
          "enabled": false,
          "description": "Reports calls to `equals()` where the target and argument are of incompatible types.\n\nWhile such a call might theoretically be useful, most likely it represents a bug.\n\n**Example:**\n\n\n        new HashSet<String>() == new TreeSet<Integer>())\n"
        },
        {
          "shortName": "GroovyInfiniteRecursion",
          "displayName": "Infinite recursion",
          "enabled": false,
          "description": "Reports methods which must either recurse infinitely or throw an exception. Methods reported by this inspection could not be finished correct.\n\n**Example:**\n\n\n    // this function always dive deeper\n    def fibonacci(int n) {\n      return fibonacci(n-1) + fibonacci(n-2)\n    }\n\n"
        },
        {
          "shortName": "GroovyRangeTypeCheck",
          "displayName": "Incorrect range arguments",
          "enabled": false,
          "description": "Reports types used in ranges that do not have a `next()` or `previous()` method or do not implement the `java.lang.Comparable` interface."
        },
        {
          "shortName": "BintrayPublishingPlugin",
          "displayName": "Bintray publishing plugin may stop working on May 1st, 2021",
          "enabled": false,
          "description": "Detects usages of Gradle plugin `com.jfrog.bintray`.\nThe plugin is used for publishing build results to Bintray.\nPublishing to\n[Bintray](https://www.jfrog.com/confluence/display/BT/Welcome+to+JFrog+Bintray) service is disabled."
        },
        {
          "shortName": "MultipleRepositoryUrls",
          "displayName": "Multiple repository urls",
          "enabled": false,
          "description": "Reports the usage of multiple URLs per repository (maven or ivy) block. The problem is that only one URL can be picked up for the repository, the other URLs will be ignored."
        },
        {
          "shortName": "JCenterRepository",
          "displayName": "Builds will no longer be able to resolve artifacts from JCenter after February 1st, 2022",
          "enabled": false,
          "description": "Detects usages of the JCenter repository to resolve dependencies. Builds will no longer be able to resolve artifacts from JCenter after February 1st, 2022."
        }
      ]
    },
    {
      "name": "Error handling",
      "inspections": [
        {
          "shortName": "UncheckedExceptionClass",
          "displayName": "Unchecked 'Exception' class",
          "enabled": false,
          "description": "Reports subclasses of `java.lang.RuntimeException`.\n\nSome coding standards require that all user-defined exception classes are checked.\n\n**Example:**\n\n\n      class EnigmaException extends RuntimeException {} // warning: Unchecked exception class 'EnigmaException'\n"
        },
        {
          "shortName": "TooBroadCatch",
          "displayName": "Overly broad 'catch' block",
          "enabled": false,
          "description": "Reports `catch` blocks with parameters that are more generic than the exception thrown by the corresponding `try` block.\n\n**Example:**\n\n\n      try  {\n        File file = new File(pathToFile);\n        return file.getAbsolutePath();\n      } catch (Exception ex) { // warning: 'catch' of 'Exception' is too broad, masking exceptions 'RuntimeException'\n        return defaultFilePath;\n      }\n\nAfter the quick-fix is applied:\n\n\n      try  {\n        File file = new File(pathToFile);\n        return file.getAbsolutePath();\n      } catch (RuntimeException ex) {\n        return defaultFilePath;\n      }\n\nConfigure the inspection:\n\n* Use the **Only warn on RuntimeException, Exception, Error or Throwable** option to have this inspection warn only on the most generic exceptions.\n* Use the **Ignore exceptions which hide others but are themselves thrown** option to ignore any exceptions that hide other exceptions but still may be thrown and thus are technically not overly broad."
        },
        {
          "shortName": "UnnecessaryInitCause",
          "displayName": "Unnecessary call to 'Throwable.initCause()'",
          "enabled": true,
          "description": "Reports calls to `Throwable.initCause()` where an exception constructor also takes a `Throwable cause` argument.\n\nIn this case, the `initCause()` call can be removed and its argument can be added to the call to the exception's constructor.\n\n**Example:**\n\n\n      try {\n          process();\n      }\n      catch (RuntimeException ex) {\n        RuntimeException wrapper = new RuntimeException(\"Error while processing\");\n        wrapper.initCause(ex); // Unnecessary call to 'Throwable.initCause()'\n        throw wrapper;\n      }\n\nA quick-fix is available to pass the cause argument to the constructor. After the quick-fix is applied:\n\n\n      try {\n          process();\n      }\n      catch (RuntimeException ex) {\n        RuntimeException wrapper = new RuntimeException(\"Error while processing\", ex);\n        throw wrapper;\n      }\n      \n"
        },
        {
          "shortName": "CheckedExceptionClass",
          "displayName": "Checked exception class",
          "enabled": false,
          "description": "Reports checked exception classes (that is, subclasses of `java.lang.Exception` that are not subclasses of `java.lang.RuntimeException`).\n\nSome coding standards suppress checked user-defined exception classes.\n\n**Example:**\n\n\n      class IllegalMoveException extends Exception {}\n"
        },
        {
          "shortName": "ExceptionFromCatchWhichDoesntWrap",
          "displayName": "'throw' inside 'catch' block which ignores the caught exception",
          "enabled": false,
          "description": "Reports exceptions that are thrown from inside `catch` blocks but do not \"wrap\" the caught exception.\n\nWhen an exception is thrown in response to an exception, wrapping the initial exception prevents losing valuable context information,\nsuch as stack frames and line numbers.\n\n**Example:**\n\n\n      ...\n      catch (IOException e) {\n        closeAllConnections();\n        throw new ConnectException(\"Connection problem.\"); // warning: 'throw' inside 'catch' block ignores the caught exception 'e'\n      }\n\nConfigure the inspection:\n\n* Use the **Ignore if result of exception method call is used** option to indicate whether the inspection should ignore exceptions whose argument is the result of a method call on the original exception, such as `getMessage()`.\n* Use the **Ignore if thrown exception cannot wrap an exception** option to ignore `throw` statements that throw exceptions without a constructor that accepts a `Throwable` cause."
        },
        {
          "shortName": "NestedTryStatement",
          "displayName": "Nested 'try' statement",
          "enabled": false,
          "description": "Reports nested `try` statements.\n\nNested `try` statements\nmay result in unclear code and should probably have their `catch` and `finally` sections\nmerged."
        },
        {
          "shortName": "NullThrown",
          "displayName": "'null' thrown",
          "enabled": false,
          "description": "Reports `null` literals that are used as the argument of a `throw` statement.\n\nSuch constructs produce a `java.lang.NullPointerException` that usually should not be thrown programmatically."
        },
        {
          "shortName": "BadExceptionThrown",
          "displayName": "Prohibited exception thrown",
          "enabled": false,
          "description": "Reports `throw` statements that throw an inappropriate exception. For example an exception can be inappropriate because it is overly generic, such as `java.lang.Exception` or `java.io.IOException`.\n\n**Example:**\n\n\n      void setup(Mode mode) {\n          if (mode == null)\n              throw new RuntimeException(\"Problem during setup\"); // warning: Prohibited exception 'RuntimeException' thrown\n          ...\n      }\n\nUse the **Prohibited exceptions** list to specify which exceptions should be reported."
        },
        {
          "shortName": "ExtendsThrowable",
          "displayName": "Class directly extends 'Throwable'",
          "enabled": false,
          "description": "Reports classes that directly extend `java.lang.Throwable`.\n\nExtending `java.lang.Throwable` directly is generally considered bad practice.\nIt is usually enough to extend `java.lang.RuntimeException`, `java.lang.Exception`, or - in special\ncases - `java.lang.Error`.\n\n**Example:**\n\n\n      class EnigmaThrowable extends Throwable {} // warning: Class 'EnigmaThrowable' directly extends 'java.lang.Throwable'\n"
        },
        {
          "shortName": "ThreadDeathRethrown",
          "displayName": "'ThreadDeath' not rethrown",
          "enabled": false,
          "description": "Reports `try` statements that catch `java.lang.ThreadDeath` and do not rethrow the exception.\n\n**Example:**\n\n\n      try {\n        executeInParallel(request);\n      } catch (ThreadDeath ex) { // warning: ThreadDeath 'ex' not rethrown\n        return false;\n      }\n"
        },
        {
          "shortName": "CaughtExceptionImmediatelyRethrown",
          "displayName": "Caught exception is immediately rethrown",
          "enabled": true,
          "description": "Reports `catch` blocks that immediately rethrow the caught exception without performing any action on it. Such `catch` blocks are unnecessary and have no error handling.\n\n**Example:**\n\n\n            try {\n                new FileInputStream(\"\");\n            } catch (FileNotFoundException e) {\n                throw e;\n            }\n"
        },
        {
          "shortName": "ThrowFromFinallyBlock",
          "displayName": "'throw' inside 'finally' block",
          "enabled": true,
          "description": "Reports `throw` statements inside `finally` blocks.\n\nWhile occasionally intended, such `throw` statements may conceal exceptions thrown from `try`-`catch` and thus\ntremendously complicate the debugging process."
        },
        {
          "shortName": "ContinueOrBreakFromFinallyBlock",
          "displayName": "'continue' or 'break' inside 'finally' block",
          "enabled": true,
          "description": "Reports `break` or `continue` statements inside of `finally` blocks.\n\nWhile occasionally intended, such statements are very confusing, may mask thrown exceptions, and complicate debugging.\n\n**Example:**\n\n\n        while (true) {\n            try {\n              throwingMethod();\n            } finally {\n                continue;\n            }\n        }\n"
        },
        {
          "shortName": "BadExceptionDeclared",
          "displayName": "Prohibited exception declared",
          "enabled": false,
          "description": "Reports methods that declare an inappropriate exception in their `throws` clause. For example an exception can be inappropriate because it is overly generic, such as `java.lang.Exception` or `java.lang.Throwable`.\n\n**Example:**\n\n\n      void describeModule(String module) throws Exception {} // warning: Prohibited exception 'Exception' declared\n\nConfigure the inspection:\n\n* Use the **Prohibited exceptions** list to specify which exceptions should be reported.\n* Use the **Ignore exceptions declared on methods overriding a library method** option to ignore exceptions declared by methods that override a library method."
        },
        {
          "shortName": "ReturnFromFinallyBlock",
          "displayName": "'return' inside 'finally' block",
          "enabled": true,
          "description": "Reports `return` statements inside of `finally` blocks.\n\nWhile occasionally intended, such `return` statements may mask thrown exceptions\nand complicate debugging.\n\n**Example:**\n\n\n      try {\n        foo();\n      } finally {\n        if (bar()) return;\n      }\n"
        },
        {
          "shortName": "EmptyTryBlock",
          "displayName": "Empty 'try' block",
          "enabled": true,
          "description": "Reports empty `try` blocks, including try-with-resources statements.\n\n`try` blocks with comments are considered empty.\n\n\nThis inspection doesn't report empty `try` blocks found in JSP files."
        },
        {
          "shortName": "NonFinalFieldOfException",
          "displayName": "Non-final field of 'Exception' class",
          "enabled": false,
          "description": "Reports fields in subclasses of `java.lang.Exception` that are not declared `final`.\n\nData on exception objects should not be modified\nbecause this may result in losing the error context for later debugging and logging.\n\n**Example:**\n\n\n      public class EditorException extends Exception {\n        private String message; // warning: Non-final field 'message' of exception class\n      }\n"
        },
        {
          "shortName": "TooBroadThrows",
          "displayName": "Overly broad 'throws' clause",
          "enabled": false,
          "description": "Reports `throws` clauses with exceptions that are more generic than the exceptions that the method actually throws.\n\n**Example:**\n\n\n      public void createFile() throws Exception { // warning: 'throws Exception' is too broad, masking exception 'IOException'\n        File file = new File(\"pathToFile\");\n        file.createNewFile();\n      }\n\nAfter the quick-fix is applied:\n\n\n      public void createFile() throws IOException {\n        File file = new File(\"pathToFile\");\n        file.createNewFile();\n      }\n\nConfigure the inspection:\n\n* Use the **Only warn on RuntimeException, Exception, Error or Throwable** option to have this inspection warn only on the most generic exceptions.\n* Use the **Ignore exceptions declared on methods overriding a library method** option to ignore overly broad `throws` clauses in methods that override a library method.\n* Use the **Ignore exceptions which hide others but are themselves thrown** option to ignore any exceptions that hide other exceptions but still may be thrown from the method body and thus are technically not overly broad."
        },
        {
          "shortName": "BadExceptionCaught",
          "displayName": "Prohibited 'Exception' caught",
          "enabled": false,
          "description": "Reports `catch` clauses that catch an inappropriate exception.\n\nSome exceptions, for example\n`java.lang.NullPointerException` or\n`java.lang.IllegalMonitorStateException`, represent programming errors\nand therefore almost certainly should not be caught in production code.\n\n**Example:**\n\n\n      try {\n        return component.getMousePosition(true) != null;\n      } catch (NullPointerException e) { // warning: Prohibited exception 'NullPointerException' caught\n        return false;\n      }\n\nUse the **Prohibited exceptions** list to specify which exceptions should be reported."
        },
        {
          "shortName": "InstanceofCatchParameter",
          "displayName": "'instanceof' on 'catch' parameter",
          "enabled": false,
          "description": "Reports cases in which an `instanceof` expression is used for testing the type of a parameter in a `catch` block.\n\nTesting the type of `catch` parameters is usually better done by having separate\n`catch` blocks instead of using `instanceof`.\n\n**Example:**\n\n\n      void foo(Runnable runnable) {\n        try {\n            runnable.run();\n        } catch (Throwable throwable) {\n            if (throwable instanceof NoClassDefFoundError) { // warning: 'instanceof' on 'catch' parameter 'throwable'\n                System.out.println(\"Class not found!\");\n            }\n        }\n      }\n"
        },
        {
          "shortName": "CatchMayIgnoreException",
          "displayName": "Catch block may ignore exception",
          "enabled": true,
          "description": "Reports `catch` blocks that are empty or may ignore an exception.\n\nWhile occasionally intended, empty `catch` blocks may complicate debugging.\nAlso, ignoring a `catch` parameter might be wrong.\nFinally, the static code analyzer reports if it detects that a `catch` block may silently ignore important VM\nexceptions like `NullPointerException`. Ignoring such an exception\n(without logging or rethrowing it) may hide a bug.\n\n\nThe inspection won't report any `catch` parameters named `ignore` or `ignored`.\nConversely, the inspection will warn you about any `catch` parameters named `ignore` or `ignored` that are actually in use.\nAdditionally, the inspection won't report `catch` parameters inside test sources named `expected` or `ok`.\n\n\nYou can use a quick-fix to change the exception name to `ignored`.\nFor empty **catch** blocks, an additional quick-fix to generate the **catch** body is suggested.\nYou can modify the \"Catch Statement Body\" template on the Code tab in\n[Settings \\| Editor \\| File and Code Templates](settings://fileTemplates).\n\n**Example:**\n\n\n      try {\n        throwingMethod();\n      } catch (IOException ex) {\n\n      }\n\nAfter the quick-fix is applied:\n\n\n      try {\n        System.out.println(System.in.read());\n      } catch (IOException ignored) {\n\n      }\n\nConfigure the inspection:\n\n* Use the **Do not warn when 'catch' block contains a comment** option to ignore `catch` blocks with comments.\n* Use the **Do not warn when 'catch' block is not empty** option to ignore `catch` blocks that contain statements or comments inside, while the variable itself is not used.\n* Use the **Do not warn when exception named 'ignore(d)' is not actually ignored** option to ignore variables named `ignored` if they are in use.\n\nNew in 2018.1"
        },
        {
          "shortName": "ThrowCaughtLocally",
          "displayName": "'throw' caught by containing 'try' statement",
          "enabled": false,
          "description": "Reports `throw` statements whose exceptions are always caught by containing `try` statements.\n\nUsing `throw`\nstatements as a \"goto\" to change the local flow of control is confusing and results in poor performance.\n\n**Example:**\n\n\n      try {\n        if (!Files.isDirectory(PROJECTS)) {\n            throw new IllegalStateException(\"Directory not found.\"); // warning: 'throw' caught by containing 'try' statement\n        }\n        ...\n      } catch (Exception e) {\n          LOG.error(\"run failed\");\n      }\n\nUse the **Ignore rethrown exceptions** option to ignore exceptions that are rethrown."
        },
        {
          "shortName": "FinallyBlockCannotCompleteNormally",
          "displayName": "'finally' block which can not complete normally",
          "enabled": true,
          "description": "Reports `return`, `throw`, `break`, `continue`, and `yield` statements that are used inside `finally` blocks. These cause the `finally` block to not complete normally but to complete abruptly. Any exceptions thrown from the `try` and `catch` blocks of the same `try`-`catch` statement will be suppressed.\n\n**Example:**\n\n\n      void x() {\n        try {\n          throw new RuntimeException();\n        } finally {\n          // if bar() returns true, the RuntimeException will be suppressed\n          if (bar()) return;\n        }\n      }\n"
        },
        {
          "shortName": "ThrowsRuntimeException",
          "displayName": "Unchecked exception declared in 'throws' clause",
          "enabled": false,
          "description": "Reports declaration of an unchecked exception (`java.lang.RuntimeException` or one of its subclasses) in the `throws` clause of a method.\n\nDeclarations of unchecked exceptions are not required and may be deleted or moved to a Javadoc `@throws` tag.\n\n**Example:**\n\n\n      public class InvalidDataException extends RuntimeException {}\n\n      class TextEditor {\n        void readSettings() throws InvalidDataException {} // warning: Unchecked exception 'InvalidDataException' declared in 'throws' clause\n      }\n"
        },
        {
          "shortName": "EmptyFinallyBlock",
          "displayName": "Empty 'finally' block",
          "enabled": true,
          "description": "Reports empty `finally` blocks.\n\nEmpty `finally` blocks usually indicate coding errors. They may also remain after code refactoring and can safely be removed.\n\nThis inspection doesn't report empty `finally` blocks found in JSP files.\n\n**Example:**\n\n\n      try {\n        Files.readString(Paths.get(\"in.txt\"));\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      } finally {\n\n      }\n\nAfter the quick-fix is applied:\n\n\n      try {\n        Files.readString(Paths.get(\"in.txt\"));\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n"
        },
        {
          "shortName": "ErrorRethrown",
          "displayName": "'Error' not rethrown",
          "enabled": false,
          "description": "Reports `try` statements that catch `java.lang.Error` or any of its subclasses and do not rethrow the error.\n\nStatements that catch `java.lang.ThreadDeath` are not\nreported.\n\n**Example:**\n\n\n      try {\n        executeTests(request);\n      }\n      catch (OutOfMemoryError ex) { // warning: Error 'ex' not rethrown\n        return false;\n      }\n"
        },
        {
          "shortName": "NewExceptionWithoutArguments",
          "displayName": "Exception constructor called without arguments",
          "enabled": false,
          "description": "Reports creation of a exception instance without any arguments specified.\n\nWhen an exception is constructed without any arguments, it contains no information about the problem that occurred, which makes\ndebugging needlessly hard.\n\n**Example:**\n\n\n      throw new IOException(); // warning: exception without arguments\n"
        },
        {
          "shortName": "GroovyContinueOrBreakFromFinallyBlock",
          "displayName": "'continue' or 'break' from 'finally' block",
          "enabled": false,
          "description": "Reports `break` and `continue` statements inside of `finally` blocks.\n\nWhile occasionally intended, such statements are very confusing, may mask thrown exceptions, and tremendously complicate debugging."
        },
        {
          "shortName": "GroovyThrowFromFinallyBlock",
          "displayName": "'throw' inside 'finally' block",
          "enabled": false,
          "description": "Reports `throw` statements inside of `finally` blocks.\n\n\nWhile occasionally intended, such `throw` statements may mask exceptions thrown and\ntremendously complicate debugging."
        },
        {
          "shortName": "GroovyUnusedCatchParameter",
          "displayName": "Unused 'catch' parameter",
          "enabled": false,
          "description": "Reports **catch** parameters that are unused in their\ncorresponding blocks. This inspection will not report any **catch** parameters\nnamed \"ignore\" or \"ignored\".\n\n**Example:**\n\n\n      try {\n          def arr = new int[3]\n          arr[5] = 5\n      } catch(Exception ex) {\n          println('Catching the exception')\n      }\n\nHere the parameter **ex** is never used in **catch** block.\n\nAfter the quick-fix is applied:\n\n\n      try {\n          def arr = new int[3]\n          arr[5] = 5\n      } catch(Exception ignored) {\n          println('Catching the exception')\n      }\n"
        },
        {
          "shortName": "GroovyReturnFromFinallyBlock",
          "displayName": "'return' inside 'finally' block",
          "enabled": false,
          "description": "Reports `return` statements inside of `finally` blocks.\n\n\nWhile occasionally intended, such `return` statements may mask exceptions thrown, and\ncomplicate debugging."
        },
        {
          "shortName": "GroovyEmptyTryBlock",
          "displayName": "Empty 'try' block",
          "enabled": false,
          "description": "Reports empty `try` blocks. Empty `try` blocks usually indicate coding errors.\n\n**Example:**\n\n\n    try {\n    }\n    finally {\n      close()\n    }\n\n"
        },
        {
          "shortName": "GroovyEmptyCatchBlock",
          "displayName": "Empty 'catch' block",
          "enabled": false,
          "description": "Reports empty `catch` blocks. While occasionally intended, empty `catch` blocks can make debugging extremely difficult.\n\n**Example:**\n\n\n    try {\n      throw new Exception()\n    }\n    catch (Exception e) {\n    }\n\nAfter the quick-fix is applied:\n\n\n    try {\n      throw new Exception()\n    }\n    catch (Exception ignored) {\n    }\n\n"
        },
        {
          "shortName": "GroovyEmptyFinallyBlock",
          "displayName": "Empty 'finally' block",
          "enabled": false,
          "description": "Reports empty `finally` blocks. Empty `finally` blocks usually indicate coding errors.\n\n**Example:**\n\n\n    try {\n      throw new Exception()\n    }\n    finally {\n    }\n\n"
        }
      ]
    },
    {
      "name": "Declaration redundancy",
      "inspections": [
        {
          "shortName": "UnusedReturnValue",
          "displayName": "Method can be made 'void'",
          "enabled": false,
          "description": "Reports methods whose return values are never used when called. The return type of such methods can be made `void`.\n\nMethods annotated with Error Prone's or AssertJ's `@CanIgnoreReturnValue` annotation will not be reported.\nThe quick-fix updates the method signature and removes `return` statements from inside the method.\n\n**Example:**\n\n\n      // reported if visibility setting is Protected or Public\n      protected String myToUpperCase(String s) {\n        return s.toUpperCase();\n      }\n\n      // simple setter, reporting depends on setting\n      public String setStr(String str) {\n        myStr = str;\n        return myStr;\n      }\n\n      void test() {\n        setStr(\"value\");          // return value is unused\n        myToUpperCase(\"result\");  // return value is unused\n      }\n\nAfter the quick-fix is applied to both methods:\n\n\n        protected void myToUpperCase(String s) {\n          // 'return' removed completely\n          // as 's.toUpperCase()' has no side effect\n        }\n\n        public void setStr(String str) {\n          myStr = str;\n          // 'return' removed\n        }\n      ...\n\n\n**NOTE:** Some methods might not be reported during in-editor highlighting due to performance reasons.\nTo see all results, run the inspection using **Code \\| Inspect Code** or **Code \\| Analyze Code \\| Run Inspection by Name**\\>\n\nUse the **Ignore simple setters** option to ignore unused return values from simple setter calls.\n\nUse the **Maximal reported method visibility** option to control the maximum visibility of methods to be reported."
        },
        {
          "shortName": "unused",
          "displayName": "Unused declaration",
          "enabled": false,
          "description": "Reports classes, methods, or fields in the specified inspection scope that are not used or unreachable from entry points.\n\nAn entry point can be the main method, tests, classes mentioned outside the specified scope, classes accessible from\n`module-info.java`, and so on. You can also configure custom entry points by using name patterns or annotations.\n\n**Example:**\n\n\n      public class Department {\n        private Organization myOrganization;\n      }\n\nIn this example, `Department` explicitly references `Organization` but if `Department` class itself is unused, then inspection will report both classes.\n\n\nThe inspection also reports parameters that are not used by their methods and all method implementations and overriders, as well as local\nvariables that are declared but not used.\n\n\n**Note:** Some unused members may not be reported during in-editor code highlighting. For performance reasons, a non-private member is\nchecked only when its name rarely occurs in the project.\nTo see all results, run the inspection by selecting **Code \\| Inspect Code** or **Code \\| Analyze Code \\| Run Inspection by Name** from the main menu.\n\nUse the visibility settings below to configure members to be reported. For example, configuring report `private` methods only means\nthat `public` methods of `private` inner class will be reported but `protected` methods of top level class\nwill be ignored.\n\n\nUse the **entry points** tab to configure entry points to be considered during the inspection run.\n\nYou can add entry points manually when inspection results are ready.\n\nIf your code uses unsupported frameworks, there are several options:\n\n* If the framework relies on annotations, use the **Annotations...** button to configure the framework's annotations.\n* If the framework doesn't rely on annotations, try to configure class name patterns that are expected by the framework.\n\nThis way the annotated code accessible by the framework internals will be treated as used."
        },
        {
          "shortName": "ProtectedMemberInFinalClass",
          "displayName": "'protected' member in 'final' class",
          "enabled": true,
          "description": "Reports `protected` members in `final`classes.\n\nSince `final` classes cannot be inherited, marking the method as `protected`\nmay be confusing. It is better to declare such members as `private` or package-visible instead.\n\n**Example:**\n\n    record Bar(int a, int b) {\n      protected int sum() { \n         return a + b;\n      }\n    }\n\nAfter the quick-fix is applied:\n\n    record Bar(int a, int b) {\n      int sum() { \n         return a + b;\n      }\n    }\n\nAs shown in the example, a class can be marked as `final` explicitly or implicitly."
        },
        {
          "shortName": "EmptyInitializer",
          "displayName": "Empty class initializer",
          "enabled": false,
          "description": "Reports empty class initializer blocks."
        },
        {
          "shortName": "UnusedLibrary",
          "displayName": "Unused library",
          "enabled": false,
          "description": "Reports libraries attached to the specified inspection scope that are not used directly in code."
        },
        {
          "shortName": "TrivialFunctionalExpressionUsage",
          "displayName": "Trivial usage of functional expression",
          "enabled": true,
          "description": "Reports functional interface methods calls that are directly invoked on the definition of the lambda, method reference, or anonymous class. Such method calls can be replaced with the body of the functional interface implementation.\n\n**Example:**\n\n\n      boolean contains(List<String> names, String name) {\n        return ((Predicate<String>)x -> {\n          return names.contains(x);\n        }).test(name);\n      }\n\nWhen the quick-fix is applied, the method call changes to:\n\n\n      boolean contains(List<String> names, String name) {\n        return names.contains(name);\n      }\n"
        },
        {
          "shortName": "RedundantLambdaParameterType",
          "displayName": "Redundant lambda parameter types",
          "enabled": true,
          "description": "Reports lambda formal parameter types that are redundant because they can be inferred from the context.\n\n**Example:**\n\n\n      Map<String, Integer> map = ...\n      map.forEach((String s, Integer i) -> log.info(s + \"=\" + i));\n\nThe quick-fix removes the parameter types from the lambda.\n\n\n      Map<String, Integer> map = ...\n      map.forEach((s, i) -> log.info(s + \"=\" + i));\n"
        },
        {
          "shortName": "AccessStaticViaInstance",
          "displayName": "Access static member via instance reference",
          "enabled": false,
          "description": "Reports references to `static` methods and fields via a class instance rather than the class itself.\n\nEven though referring to static members via instance variables is allowed by The Java Language Specification,\nthis makes the code confusing as the reader may think that the result of the method depends on the instance.\n\nThe quick-fix replaces the instance variable with the class name.\n\nExample:\n\n\n      String s1 = s.valueOf(0);\n\nAfter the quick-fix is applied:\n\n\n      String s = String.valueOf(0);\n"
        },
        {
          "shortName": "UnnecessaryModuleDependencyInspection",
          "displayName": "Unnecessary module dependency",
          "enabled": false,
          "description": "Reports dependencies on modules that are not used. The quick-fix safely removes such unused dependencies."
        },
        {
          "shortName": "CanBeFinal",
          "displayName": "Declaration can have 'final' modifier",
          "enabled": false,
          "description": "Reports all fields, methods, or classes found in the specified inspection scope that may have the `final` modifier added to their declarations.\n\nFinal classes can't be extended, final methods can't be overridden, and final fields can't be reassigned.\n\nUse the **Report classes** and **Report methods** options to define which declarations are to be reported."
        },
        {
          "shortName": "EmptyMethod",
          "displayName": "Empty method",
          "enabled": false,
          "description": "Reports empty methods that can be removed.\n\nMethods are considered empty if they are empty themselves and if they are overridden or\nimplemented by empty methods only. Note that methods containing only comments and the `super()` call with own parameters are\nalso considered empty.\n\nThe inspection ignores methods with special annotations, for example, the `javax.ejb.Init` and `javax.ejb.Remove` EJB annotations .\n\nThe quick-fix safely removes unnecessary methods.\n\nConfigure the inspection:\n\n* Use the **Comments and javadoc count as content** option to select whether methods with comments should be treated as non-empty.\n* Use the **Additional special annotations** option to configure additional annotations that should be ignored by this inspection."
        },
        {
          "shortName": "RedundantExplicitClose",
          "displayName": "Redundant 'close()'",
          "enabled": true,
          "description": "Reports unnecessary calls to `close()` at the end of a try-with-resources block and suggests removing them.\n\n**Example**:\n\n\n      try(MyAutoCloseable ac = new MyAutoCloseable()) {\n        foo();\n        ac.close();\n      }\n\nAfter the quick-fix is applied:\n\n\n      try(MyAutoCloseable ac = new MyAutoCloseable()) {\n        foo();\n      }\n\nNew in 2018.1"
        },
        {
          "shortName": "RedundantThrows",
          "displayName": "Redundant 'throws' clause",
          "enabled": false,
          "description": "Reports exceptions that are declared in a method's signature but never thrown by the method itself or its implementations and derivatives.\n\nThe inspection ignores methods related to the serialization, for example methods `readObject()` or `writeObject()`.\n\n**Example:**\n\n\n      void method() throws InterruptedException {\n        System.out.println();\n      }\n\nThe quick-fix removes unnecessary exceptions from the declaration and normalizes the redundant `try`-`catch` statements:\n\n\n      void method() {\n        System.out.println();\n      }\n\n\n**Note:** Some exceptions might not be reported during in-editor highlighting.\nFor performance reasons, a non-private method is checked only when its name rarely occurs in the project.\nTo see all results, run the inspection by selecting **Code \\| Inspect Code** or **Code \\| Analyze Code \\| Run Inspection by Name** from the main menu.\n\nUse the **Ignore exceptions thrown by entry points methods** option to ignore exceptions thrown by entry points methods.\nEntry points methods are configured the following inspection: **Editor \\| Inspections \\| Java \\| Declaration redundancy \\| Unused declaration**."
        },
        {
          "shortName": "DuplicateThrows",
          "displayName": "Duplicate throws",
          "enabled": true,
          "description": "Reports duplicate exceptions in a method `throws` list.\n\nExample:\n\n\n      void f() throws Exception, Exception {}\n\nAfter the quick-fix is applied:\n\n\n      void f() throws Exception {}\n\n\nUse the **Ignore exceptions subclassing others** option to ignore exceptions subclassing other exceptions."
        },
        {
          "shortName": "UnusedLabel",
          "displayName": "Unused label",
          "enabled": true,
          "description": "Reports labels that are not targets of any `break` or `continue` statements.\n\n**Example:**\n\n\n      label: for (int i = 0; i < 10; i++) {\n        if (i == 3) {\n          break;\n        }\n      }\n\nAfter the quick-fix is applied, the label is removed:\n\n\n      for (int i = 0; i < 10; i++) {\n        if (i == 3) {\n          break;\n        }\n      }\n"
        },
        {
          "shortName": "DefaultAnnotationParam",
          "displayName": "Default annotation parameter value",
          "enabled": true,
          "description": "Reports annotation parameters that are assigned to their `default` value.\n\nExample:\n\n\n      @interface Test {\n          Class<?> expected() default Throwable.class;\n      }\n\n      @Test(expected = Throwable.class)\n      void testSmth() {}\n\nAfter the quick-fix is applied:\n\n\n      @Test()\n      void testSmth() {}\n"
        },
        {
          "shortName": "RedundantImplements",
          "displayName": "Redundant interface declaration",
          "enabled": false,
          "description": "Reports classes declaring that they implement or extend an interface, when that interface is already declared as `implemented` by a superclass or extended by another interface of that class. Such declarations are unnecessary and may be safely removed."
        },
        {
          "shortName": "SameParameterValue",
          "displayName": "Method parameter value is always the same constant",
          "enabled": false,
          "description": "Reports method parameters that always have the same constant value.\n\nExample:\n\n\n      static void printPoint(int x, int y) { // x is always 0\n        System.out.println(x + \", \" + y);\n      }\n\n      public static void main(String[] args) {\n        printPoint(0, 1);\n        printPoint(0, 2);\n      }\n\nThe quick-fix inlines the constant value. This may simplify the method implementation.\n\n\nUse the **Ignore when inline parameter initializer would not succeed** option to suppress the inspections when:\n\n* the parameter is modified inside the method.\n* the parameter value that is being passed is a reference to an inaccessible field (only in Java).\n* the parameter is a vararg (only in Java).\n\n\nUse the **Maximal reported method visibility** option to control the maximum visibility of methods to be reported.\n\n\nUse the **Minimal reported method usage count** field to specify the minimal number of method usages with the same parameter value."
        },
        {
          "shortName": "SameReturnValue",
          "displayName": "Method returns the same value",
          "enabled": false,
          "description": "Reports methods and method hierarchies in which the return value always appears to be the same constant."
        },
        {
          "shortName": "RedundantRecordConstructor",
          "displayName": "Redundant record constructor",
          "enabled": true,
          "description": "Reports redundant constructors declared inside Java records.\n\n**Example 1:**\n\n\n      record Point(int x, int y) {\n        public Point {} // could be removed\n      }\n      \n      record Point(int x, int y) {\n        public Point(int x, int y) { // could be removed\n          this.x = x;\n          this.y = y;\n        }\n      }\n\nThe quick-fix removes the redundant constructors.\n\n**Example 2:**\n\n\n       // could be converted to compact constructor\n      record Range(int from, int to) {\n        public Range(int from, int to) {\n          if (from > to) throw new IllegalArgumentException();\n          this.from = from;\n          this.to = to;\n        }\n      }\n\nThe quick-fix converts this code into a compact constructor.\n\nThis inspection only reports if the language level of the project or module is 16 or higher.\n\nNew in 2020.1"
        },
        {
          "shortName": "WeakerAccess",
          "displayName": "Declaration access can be weaker",
          "enabled": false,
          "description": "Reports all fields, methods or classes, found in the specified inspection scope that may have their access modifier narrowed down.\n\nExample:\n\n\n      class Sample {\n        void foo() {\n            bar(\"foo\", \"foo\");\n        }\n        void bar(String x, String y) { } // can be private\n      }\n\nUse the inspection's options to define the rules for the modifier change suggestions."
        },
        {
          "shortName": "FinalMethodInFinalClass",
          "displayName": "'final' method in 'final' class",
          "enabled": false,
          "description": "Reports `final` methods in `final` classes.\n\nSince `final` classes cannot be inherited, marking a method as `final`\nmay be unnecessary and confusing.\n\n**Example:**\n\n    record Bar(int a, int b) {\n      public final int sum() { \n         return a + b;\n      }\n    }\n\nAfter the quick-fix is applied:\n\n    record Bar(int a, int b) {\n      public int sum() { \n         return a + b;\n      }\n    }\n\nAs shown in the example, a class can be marked as `final` explicitly or implicitly."
        },
        {
          "shortName": "Java9RedundantRequiresStatement",
          "displayName": "Redundant 'requires' directive in module-info",
          "enabled": false,
          "description": "Reports redundant `requires` directives in Java Platform Module System `module-info.java` files. A `requires` directive is redundant when a module `A` requires a module `B`, but the code in module `A` doesn't import any packages or classes from `B`. Furthermore, all modules have an implicitly declared dependence on the `java.base` module, therefore a `requires java.base;` directive is always redundant.\n\n\nThe quick-fix deletes the redundant `requires` directive.\nIf the deleted dependency re-exported modules that are actually used, the fix adds a `requires` directives for these modules.\n\nThis inspection only reports if the language level of the project or module is 9 or higher.\n\nNew in 2017.1"
        },
        {
          "shortName": "SillyAssignment",
          "displayName": "Variable is assigned to itself",
          "enabled": true,
          "description": "Reports assignments of a variable to itself.\n\n**Example:**\n\n\n      a = a;\n\nThe quick-fix removes the assigment."
        },
        {
          "shortName": "FunctionalExpressionCanBeFolded",
          "displayName": "Functional expression can be folded",
          "enabled": false,
          "description": "Reports method references or lambda expressions that point to a method of their own functional interface type and hence can be replaced with their qualifiers removing unnecessary object allocation.\n\nExample:\n\n\n      SwingUtilities.invokeLater(r::run);\n      SwingUtilities.invokeAndWait(() -> r.run());\n\nAfter the quick-fix is applied:\n\n\n      SwingUtilities.invokeLater(r);\n      SwingUtilities.invokeAndWait(r);\n\nThis inspection only reports only if the language level of the project or module is 8 or higher."
        },
        {
          "shortName": "GroovyUnusedDeclaration",
          "displayName": "Unused declaration",
          "enabled": false,
          "description": "Reports unused classes, methods and fields.\n\n**Example:**\n\n\n      public class Department {\n          private Organization myOrganization;\n      }\n\nHere `Department` explicitly references `Organization` but if `Department` class itself is unused,\nthen inspection would report both classes.\n\n\nThe inspection also reports parameters, which are not used by their methods and all method implementations/overriders, as well as local\nvariables, which are declared but not used.\n\nFor more information, see the same inspection in Java."
        }
      ]
    },
    {
      "name": "Migration",
      "inspections": [
        {
          "shortName": "NonExhaustiveWhenStatementMigration",
          "displayName": "Non-exhaustive 'when' statements will be prohibited since 1.7",
          "enabled": false,
          "description": "Reports a non-exhaustive `when` statements that will lead to compilation error since 1.7.\n\nMotivation types:\n\n* Problematic/meaningless usage patterns need to be discouraged/blocked (e.g. counterintuitive behaviors)\n  * Code is error-prone\n* Inconsistency in the design (things are done differently in different contexts)\n\nImpact types:\n\n* Compilation. Some code that used to compile won't compile any more\n  * There were cases when such code worked with no exceptions\n    * Some such code could compile without any warnings\n\n**More details:** [KT-47709: Make when statements with enum, sealed, and Boolean subjects exhaustive by default](https://youtrack.jetbrains.com/issue/KT-47709)\n\nThe quick-fix adds the missing `else -> {}` branch.\n\n**Example:**\n\n\n      sealed class Base {\n          class A : Base()\n          class B : Base()\n      }\n\n      fun test(base: Base) {\n          when (base) {\n              is Base.A -> \"\"\n          }\n      }\n\nAfter the quick-fix is applied:\n\n\n      sealed class Base {\n          class A : Base()\n          class B : Base()\n      }\n\n      fun test(base: Base) {\n          when (base) {\n              is Base.A -> \"\"\n              else -> {}\n          }\n      }\n\nThis inspection only reports if the Kotlin language level of the project or module is 1.6 or higher."
        },
        {
          "shortName": "ProhibitJvmOverloadsOnConstructorsOfAnnotationClassesMigration",
          "displayName": "'@JvmOverloads' annotation cannot be used on constructors of annotation classes since 1.4",
          "enabled": false,
          "description": "Reports `@JvmOverloads` on constructors of annotation classes because it's meaningless.\n\n\nThere is no footprint of `@JvmOverloads` in the generated bytecode and Kotlin metadata,\nso `@JvmOverloads` doesn't affect the generated bytecode and the code behavior.\n\n`@JvmOverloads` on constructors of annotation classes causes a compilation error since Kotlin 1.4.\n\n**Example:**\n\n\n      annotation class A @JvmOverloads constructor(val x: Int = 1)\n\nAfter the quick-fix is applied:\n\n\n      annotation class A constructor(val x: Int = 1)\n"
        },
        {
          "shortName": "KotlinDeprecation",
          "displayName": "Usage of redundant or deprecated syntax or deprecated symbols",
          "enabled": true,
          "description": "Reports obsolete language features and unnecessarily verbose code constructs during the code cleanup operation (**Code \\| Code Cleanup** ).\n\n\nA quick-fix automatically replaces usages of obsolete language features or unnecessarily verbose code constructs with compact and up-to-date syntax.\n\n\nIt also replaces deprecated symbols with their proposed substitutions."
        },
        {
          "shortName": "WarningOnMainUnusedParameterMigration",
          "displayName": "Unused 'args' on 'main' since 1.4",
          "enabled": false,
          "description": "Reports `main` function with an unused single parameter.\n\nSince Kotlin 1.4, it is possible to use the `main` function without parameter as the entry point to the Kotlin program.\nThe compiler reports a warning for the `main` function with an unused parameter."
        },
        {
          "shortName": "RedundantLabelMigration",
          "displayName": "Redundant label",
          "enabled": false,
          "description": "Reports redundant labels which cause compilation errors since Kotlin 1.4.\n\nSince Kotlin 1.0, one can mark any statement with a label:\n\n\n      fun foo() {\n        L1@ val x = L2@bar()\n      }\n\nHowever, these labels can be referenced only in a limited number of ways:\n\n* break / continue from a loop\n* non-local return from an inline lambda or inline anonymous function\nsssss\n\nSuch labels are prohibited since Kotlin 1.4.\n\nThis inspection only reports if the Kotlin language level of the project or module is 1.4 or higher."
        },
        {
          "shortName": "ObsoleteExperimentalCoroutines",
          "displayName": "Experimental coroutines usages are deprecated since 1.3",
          "enabled": true,
          "description": "Reports code that uses experimental coroutines.\n\nSuch usages are incompatible with Kotlin 1.3+ and should be updated."
        },
        {
          "shortName": "FromClosedRangeMigration",
          "displayName": "MIN_VALUE step in fromClosedRange() since 1.3",
          "enabled": false,
          "description": "Reports `IntProgression.fromClosedRange()` and `LongProgression.fromClosedRange()` with `MIN_VALUE` step.\n\n\nIt is prohibited to call `IntProgression.fromClosedRange()` and `LongProgression.fromClosedRange()` with\n`MIN_VALUE` step. All such calls should be checked during migration to Kotlin 1.3+.\n\n**Example:**\n\n\n      IntProgression.fromClosedRange(12, 143, Int.MIN_VALUE)\n\nTo fix the problem change the step of the progression."
        },
        {
          "shortName": "ProhibitUseSiteTargetAnnotationsOnSuperTypesMigration",
          "displayName": "Meaningless annotations targets on superclass",
          "enabled": false,
          "description": "Reports meaningless annotation targets on superclasses since Kotlin 1.4.\n\nAnnotation targets such as `@get:` are meaningless on superclasses and are prohibited.\n\n**Example:**\n\n\n      interface Foo\n\n      annotation class Ann\n\n      class E : @field:Ann @get:Ann @set:Ann @setparam:Ann Foo\n\nAfter the quick-fix is applied:\n\n\n      interface Foo\n\n      annotation class Ann\n\n      class E : Foo\n\nThis inspection only reports if the Kotlin language level of the project or module is 1.4 or higher."
        },
        {
          "shortName": "ProhibitTypeParametersForLocalVariablesMigration",
          "displayName": "Local variable with type parameters",
          "enabled": false,
          "description": "Reports local variables with type parameters.\n\nA type parameter for a local variable doesn't make sense because it can't be specialized.\n\n**Example:**\n\n\n      fun main() {\n          val <T> x = \"\"\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun main() {\n          val x = \"\"\n      }\n\nThis inspection only reports if the Kotlin language level of the project or module is 1.4 or higher."
        },
        {
          "shortName": "ObsoleteKotlinJsPackages",
          "displayName": "'kotlin.browser' and 'kotlin.dom' packages are deprecated since 1.4",
          "enabled": true,
          "description": "Reports usages of `kotlin.dom` and `kotlin.browser` packages.\n\nThese packages were moved to `kotlinx.dom` and `kotlinx.browser`\nrespectively in Kotlin 1.4+."
        },
        {
          "shortName": "RestrictReturnStatementTargetMigration",
          "displayName": "Target label does not denote a function since 1.4",
          "enabled": false,
          "description": "Reports labels that don't points to a functions.\n\nIt's forbidden to declare a target label that does not denote a function.\n\nThe quick-fix removes the label.\n\n**Example:**\n\n\n      fun testValLabelInReturn() {\n          L@ val fn = { return@L }\n          fn()\n      }\n\nAfter the quick-fix is applied:\n\n\n      fun testValLabelInReturn() {\n          L@ val fn = { return }\n          fn()\n      }\n\nThis inspection only reports if the language level of the project or module is 1.4 or higher."
        },
        {
          "shortName": "ProhibitRepeatedUseSiteTargetAnnotationsMigration",
          "displayName": "Repeated annotation which is not marked as '@Repeatable'",
          "enabled": false,
          "description": "Reports the repeated use of a non-`@Repeatable` annotation on property accessors.\n\n\nAs a result of using non-`@Repeatable` annotation multiple times, both annotation usages\nwill appear in the bytecode leading to an ambiguity in reflection calls.\n\n\nSince Kotlin 1.4 it's mandatory to either mark annotation as `@Repeatable` or not\nrepeat the annotation, otherwise it will lead to compilation error.\n\n**Example:**\n\n\n      annotation class Foo(val x: Int)\n\n      @get:Foo(10)\n      val a: String\n          @Foo(20) get() = \"foo\" // annotation repeated twice but not marked as @Repeatable\n\nThis inspection only reports if the Kotlin language level of the project or module is 1.4 or higher."
        }
      ]
    },
    {
      "name": "Pattern validation",
      "inspections": [
        {
          "shortName": "PatternNotApplicable",
          "displayName": "Pattern Annotation not applicable",
          "enabled": false,
          "description": "Reports when a `@Pattern` annotation is applied to an element with a type other than `String`.\n\n**Example:**\n\n\n      @Pattern(\"\\\\d\\\\d\") int i;\n"
        },
        {
          "shortName": "PatternOverriddenByNonAnnotatedMethod",
          "displayName": "Non-annotated Method overrides @Pattern Method",
          "enabled": false,
          "description": "Reports when a method without any `@Pattern` annotation overrides a `@Pattern` annotated method. This does not prevent error-highlighting inside the editor, however the overriding method will not be checked at runtime.\n\n\nA quick fix is provided to add a `@Pattern` annotation that matches the one from the superclass method. This ensures the\nruntime-check instrumentation works correctly.\n\n**Example:**\n\n\n      abstract class Parent {\n        abstract @Pattern(\"\\\\d\\\\d-\\\\d\\\\d\\\\d\") String getId();\n      }\n      class Child extends Parent {\n        @Override String getId() { // warning here\n          return \"12-345\";\n        }\n      }\n"
        },
        {
          "shortName": "PatternValidation",
          "displayName": "Validate annotated patterns",
          "enabled": false,
          "description": "Reports expressions passed as arguments for `@Pattern` parameters and returned from `@Pattern`-annotated methods that do not match the specified pattern.\n\n**Example:**\n\n\n      @Pattern(\"\\\\d\\\\d-\\\\d\\\\d\\\\d\") String getId() {\n        return \"1\";\n      }\n"
        }
      ]
    },
    {
      "name": "Serialization issues",
      "inspections": [
        {
          "shortName": "ComparatorNotSerializable",
          "displayName": "'Comparator' class not declared 'Serializable'",
          "enabled": false,
          "description": "Reports classes that implement `java.lang.Comparator`, but do not implement `java.io.Serializable`.\n\n\nIf a non-serializable comparator is used to construct an ordered collection such\nas a `java.util.TreeMap` or `java.util.TreeSet`, then the\ncollection will also be non-serializable. This can result in unexpected and\ndifficult-to-diagnose bugs.\n\n\nSince subclasses of `java.lang.Comparator` are often stateless,\nsimply marking them serializable is a small cost to avoid such issues.\n\n**Example:**\n\n\n      class Foo implements Comparator { // warning\n          @Override\n          public int compare(Object o1, Object o2) {\n              /* ... */\n          }\n      }\n\nAfter the quick-fix is applied:\n\n\n      class Foo implements Comparator, Serializable { // no warning here\n          @Override\n          public int compare(Object o1, Object o2) {\n              /* ... */\n          }\n      }\n"
        },
        {
          "shortName": "SerializableStoresNonSerializable",
          "displayName": "'Serializable' object implicitly stores non-'Serializable' object",
          "enabled": false,
          "description": "Reports any references to local non-`Serializable` variables outside `Serializable` lambdas, local and anonymous classes.\n\n\nWhen a local variable is referenced from an anonymous class, its value\nis stored in an implicit field of that class. The same happens\nfor local classes and lambdas. If the variable is of a\nnon-`Serializable` type, serialization will fail.\n\n**Example:**\n\n\n      interface A extends Serializable {\n          abstract void foo();\n      }\n      class B {}\n      class C {\n          void foo() {\n              B b = new B();\n              A a = new A() {\n                  @Override\n                  public void foo() {\n                      System.out.println(b); // warning\n                  }\n              };\n          }\n      }\n"
        },
        {
          "shortName": "ExternalizableWithoutPublicNoArgConstructor",
          "displayName": "'Externalizable' class without 'public' no-arg constructor",
          "enabled": true,
          "description": "Reports `Externalizable` classes without a public no-argument constructor.\n\nWhen an `Externalizable` object is reconstructed, an instance is created using the public\nno-arg constructor before the `readExternal` method called. If a public\nno-arg constructor is not available, a `java.io.InvalidClassException` will be\nthrown at runtime."
        },
        {
          "shortName": "MissingSerialAnnotation",
          "displayName": "'@Serial' annotation could be used",
          "enabled": true,
          "description": "Reports methods and fields in the `Serializable` and `Externalizable` classes that are suitable to be annotated with the `java.io.Serial` annotation. The quick-fix adds the annotation.\n\n**Example:**\n\n\n    class Main implements Serializable {\n      private static final long serialVersionUID = 7874493593505141603L;\n\n      private void writeObject(ObjectOutputStream out) throws IOException {\n      }\n    }\n\nAfter the quick-fix is applied:\n\n\n      class Main implements Serializable {\n        @Serial\n        private static final long serialVersionUID = 7874493593505141603L;\n\n        @Serial\n        private void writeObject(ObjectOutputStream out) throws IOException {\n        }\n    }\n\n**Example:**\n\n\n      class Main implements Externalizable {\n        protected Object readResolve() throws ObjectStreamException {\n          return \"SomeObject\";\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      class Main implements Externalizable {\n        @Serial\n        protected Object readResolve() throws ObjectStreamException {\n            return \"SomeObject\";\n        }\n      }\n\nFor more information about all possible cases, refer the documentation for `java.io.Serial`.\n\nThis inspection only reports if the language level of the project or module is 14 or higher.\n\nNew in 2020.3"
        },
        {
          "shortName": "SerialPersistentFieldsWithWrongSignature",
          "displayName": "'serialPersistentFields' field not declared 'private static final ObjectStreamField[]'",
          "enabled": false,
          "description": "Reports `Serializable` classes whose `serialPersistentFields` field is not declared as `private static final ObjectStreamField[]`.\n\n\nIf a `serialPersistentFields` field is not declared with those modifiers,\nthe serialization behavior will be as if the field was not declared at all.\n\n**Example:**\n\n\n      class List implements Serializable {\n        private List next;\n\n        ObjectStreamField[] serialPersistentFields = {new ObjectStreamField(\"next\", List.class)};\n\n      }\n"
        },
        {
          "shortName": "NonSerializableObjectBoundToHttpSession",
          "displayName": "Non-serializable object bound to 'HttpSession'",
          "enabled": false,
          "description": "Reports objects of classes not implementing `java.io.Serializable` used as arguments to `javax.servlet.http.HttpSession.setAttribute()` or `javax.servlet.http.HttpSession.putValue()`.\n\n\nSuch objects will not be serialized if the `HttpSession` is passivated or migrated,\nand may result in difficult-to-diagnose bugs.\n\n\nThis inspection assumes objects of the types `java.util.Collection` and\n`java.util.Map` to be `Serializable`,\nunless type parameters are non-`Serializable`.\n\n**Example:**\n\n\n      void foo(HttpSession session) {\n          session.setAttribute(\"foo\", new NonSerializable());\n      }\n      static class NonSerializable {}\n"
        },
        {
          "shortName": "ExternalizableWithSerializationMethods",
          "displayName": "Externalizable class with 'readObject()' or 'writeObject()'",
          "enabled": false,
          "description": "Reports `Externalizable` classes that define `readObject()` or `writeObject()` methods. These methods are not called for serialization of `Externalizable` objects.\n\n**Example:**\n\n\n      abstract class Crucial implements Externalizable {\n        int value;\n        private void readObject(ObjectInputStream in) {\n          value = in.readInt();\n        }\n      }\n"
        },
        {
          "shortName": "SerializableRecordContainsIgnoredMembers",
          "displayName": "'record' contains ignored members",
          "enabled": true,
          "description": "Reports serialization methods or fields defined in a `record` class. Serialization methods include `writeObject()`, `readObject()`, `readObjectNoData()`, `writeExternal()`, and `readExternal()` and the field `serialPersistentFields`. These members are not used for the serialization or deserialization of records and therefore unnecessary.\n\n**Examples:**\n\n\n      record R1() implements Serializable {\n        // The field is ignored during record serialization\n        @Serial\n        private static final ObjectStreamField[] serialPersistentFields = new ObjectStreamField[0];\n\n        // The method is ignored during record serialization\n        @Serial\n        private void writeObject(ObjectOutputStream out) throws IOException {\n        }\n      }\n\n\n      record R2() implements Externalizable {\n        // The method is ignored during record serialization\n        @Override\n        public void writeExternal(ObjectOutput out) throws IOException {\n        }\n\n        // The method is ignored during record serialization\n        @Override\n        public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n        }\n      }\n\nThis inspection only reports if the language level of the project or module is 14 or higher.\n\nNew in 2020.3"
        },
        {
          "shortName": "ReadObjectInitialization",
          "displayName": "Instance field may not be initialized by 'readObject()'",
          "enabled": false,
          "description": "Reports fields that are not guaranteed to be initialized after the object is deserialized by the `readObject()` method.\n\nThe inspection doesn't report transient fields.\n\n\nNote: This inspection uses a very conservative control flow algorithm, and may incorrectly report fields\nas uninitialized.\n\n**Example:**\n\n\n    class DataObject implements Serializable {\n      String s; // s is not initialized in readObject\n      int i;\n\n      private void readObject(ObjectInputStream stream) throws IOException {\n        i = stream.readInt();\n      }\n    }\n"
        },
        {
          "shortName": "NonSerializableFieldInSerializableClass",
          "displayName": "Non-serializable field in a 'Serializable' class",
          "enabled": true,
          "description": "Reports non-serializable fields in classes that implement `java.io.Serializable`. Such fields will result in runtime exceptions if the object is serialized.\n\n\nFields declared\n`transient` or `static`\nare not reported, nor are fields of classes that have a `writeObject` method defined.\n\n\nThis inspection assumes fields of the types\n`java.util.Collection` and\n`java.util.Map` to be\n`Serializable`, unless the types\nthey are declared in are non-`Serializable`.\n\n**Example:**\n\n\n      class NonSerializableClass {}\n\n      public class SerializableClass implements Serializable {\n          NonSerializableClass clazz; // warning: Non-serializable field 'clazz' in a Serializable class\n          static NonSerializableClass staticClazz; // no warnings\n      }\n      \n\nUse the following options to configure the inspection:\n\n* List classes whose inheritors should not be reported by this inspection. This is meant for classes that inherit `Serializable` from a superclass but are not intended for serialization.\n* List annotations that will make the inspection ignore the annotated fields.\n* Whether to ignore fields initialized with an anonymous class."
        },
        {
          "shortName": "TransientFieldNotInitialized",
          "displayName": "Transient field is not initialized on deserialization",
          "enabled": false,
          "description": "Reports `transient` fields that are initialized during normal object construction, but whose class does not have a `readObject` method.\n\n\nAs `transient` fields are not serialized they need\nto be initialized separately in a `readObject()` method\nduring deserialization.\n\n\nAny `transient` fields that\nare not initialized during normal object construction are considered to use the default\ninitialization and are not reported by this inspection.\n\n**Example:**\n\n\n      class Person implements Serializable {\n        transient String name = \"Default\"; //warning, can actually be a null after deserialization\n        transient String surname; //null is considered the default value and not reported\n      }\n"
        },
        {
          "shortName": "ReadObjectAndWriteObjectPrivate",
          "displayName": "'readObject()' or 'writeObject()' not declared 'private'",
          "enabled": false,
          "description": "Reports `Serializable` classes where the `readObject` or `writeObject` methods are not declared private. There is no reason these methods should ever have a higher visibility than `private`.\n\n\nA quick-fix is suggested to make the corresponding method `private`.\n\n**Example:**\n\n\n      public class Test implements Serializable {\n        public void readObject(ObjectInputStream stream) {\n          /* ... */\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      public class Test implements Serializable {\n        private void readObject(ObjectInputStream stream) {\n          /* ... */\n        }\n      }\n"
        },
        {
          "shortName": "SerializableWithUnconstructableAncestor",
          "displayName": "Serializable class with unconstructable ancestor",
          "enabled": false,
          "description": "Reports `Serializable` classes whose closest non-serializable ancestor doesn't have a no-argument constructor. Such classes cannot be deserialized and will fail with an `InvalidClassException`.\n\n**Example:**\n\n\n      class Ancestor {\n        private String name;\n        Ancestor(String name) {\n          this.name = name;\n        }\n      }\n\n      // warning on this class because the superclass is not\n      // serializable, and its constructor takes arguments\n      class Descendant extends Ancestor implements Serializable {\n        Descendant() {\n          super(\"Bob\");\n        }\n      }\n"
        },
        {
          "shortName": "SerialVersionUIDNotStaticFinal",
          "displayName": "'serialVersionUID' field not declared 'private static final long'",
          "enabled": false,
          "description": "Reports `Serializable` classes whose `serialVersionUID` field is not declared `private static final long`.\n\n**Example:**\n\n\n      class SampleClass implements Serializable {\n        private long serialVersionUID = 1; // field of a Serializable class is not declared 'private static final long'\n\n        public SampleClass() {\n            System.out.println(serialVersionUID);\n        }\n      }\n"
        },
        {
          "shortName": "SerializableInnerClassWithNonSerializableOuterClass",
          "displayName": "Serializable non-'static' inner class with non-Serializable outer class",
          "enabled": false,
          "description": "Reports non-static inner classes that implement `Serializable` and are declared inside a class that doesn't implement `Serializable`.\n\n\nSuch classes are unlikely to serialize correctly due to implicit references to the outer class.\n\n**Example:**\n\n\n      class A {\n        class Main implements Serializable {\n        }\n      }\n\nUse the following options to configure the inspection:\n\n* List classes whose inheritors should not be reported by this inspection. This is meant for classes that inherit `Serializable` from a superclass but are not intended for serialization.\n* Whether to ignore `Serializable` anonymous classes."
        },
        {
          "shortName": "SerializableHasSerializationMethods",
          "displayName": "Serializable class without 'readObject()' and 'writeObject()'",
          "enabled": false,
          "description": "Reports `Serializable` classes that do not implement `readObject()` and `writeObject()` methods.\n\n\nIf `readObject()` and `writeObject()` methods are not implemented,\nthe default serialization algorithms are used,\nwhich may be sub-optimal for performance and compatibility in many environments.\n\n\nUse the following options to configure the inspection:\n\n* List classes whose inheritors should not be reported by this inspection. This is meant for classes that inherit `Serializable` from a superclass but are not intended for serialization.\n* Whether to ignore `Serializable` classes without non-static fields.\n* Whether to ignore `Serializable` anonymous classes."
        },
        {
          "shortName": "NonSerializableWithSerialVersionUIDField",
          "displayName": "Non-serializable class with 'serialVersionUID'",
          "enabled": false,
          "description": "Reports non-`Serializable` classes that define a `serialVersionUID` field. A `serialVersionUID` field in that context normally indicates an error because the field will be ignored and the class will not be serialized.\n\n**Example:**\n\n\n      public class IWantToSerializeThis {\n        private static final long serialVersionUID = 2669293150219020249L;\n      }\n"
        },
        {
          "shortName": "SerializableInnerClassHasSerialVersionUIDField",
          "displayName": "Serializable non-static inner class without 'serialVersionUID'",
          "enabled": false,
          "description": "Reports non-static inner classes that implement `java.io.Serializable`, but do not define a `serialVersionUID` field.\n\n\nWithout a `serialVersionUID` field, any change to the class will make previously\nserialized versions unreadable. It is strongly recommended that `Serializable`\nnon-static inner classes have a `serialVersionUID` field, otherwise the default\nserialization algorithm may result in serialized versions being incompatible between\ncompilers due to differences in synthetic accessor methods.\n\n\nA quick-fix is suggested to add the missing `serialVersionUID` field.\n\n**Example:**\n\n\n      class Outer {\n          class Inner implements Serializable {}\n      }\n\nAfter the quick-fix is applied:\n\n\n      class Outer {\n          class Inner implements Serializable {\n              private static final long serialVersionUID = -7004458730436243902L;\n          }\n      }\n\nUse the following options to configure the inspection:\n\n* List classes whose inheritors should not be reported by this inspection. This is meant for classes that inherit `Serializable` from a superclass but are not intended for serialization.\n* Whether to ignore `Serializable` anonymous classes."
        },
        {
          "shortName": "TransientFieldInNonSerializableClass",
          "displayName": "Transient field in non-serializable class",
          "enabled": false,
          "description": "Reports `transient` fields in classes that do not implement `java.io.Serializable`.\n\n**Example:**\n\n\n      public class NonSerializableClass {\n        private transient String password;\n      }\n\nAfter the quick-fix is applied:\n\n\n      public class NonSerializableClass {\n        private String password;\n      }\n"
        },
        {
          "shortName": "SerialAnnotationUsedOnWrongMember",
          "displayName": "'@Serial' annotation used on wrong member",
          "enabled": true,
          "description": "Reports methods and fields in the `Serializable` and `Externalizable` classes that are not suitable to be annotated with the `java.io.Serial` annotation.\n\n**Examples:**\n\n\n    class Test implements Serializable {\n      @Serial // The annotated field is not a part of serialization mechanism because it's not final\n      private static long serialVersionUID = 7874493593505141603L;\n\n      @Serial // The annotated method is not a part of the serialization mechanism because it's not private\n      void writeObject(ObjectOutputStream out) throws IOException {\n      }\n    }\n\n\n    class Test implements Externalizable {\n      @Serial // The annotated method is not a part of the serialization mechanism as it's inside Externalizable class\n      private void writeObject(ObjectOutputStream out) throws IOException {\n      }\n    }\n\nFor information about all valid cases, refer the documentation for `java.io.Serial`.\n\nThis inspection only reports if the language level of the project or module is 14 or higher.\n\nNew in 2020.3"
        },
        {
          "shortName": "ReadResolveAndWriteReplaceProtected",
          "displayName": "'readResolve()' or 'writeReplace()' not declared 'protected'",
          "enabled": false,
          "description": "Reports classes that implement `java.io.Serializable` where the `readResolve()` or `writeReplace()` methods are not declared `protected`.\n\n\nDeclaring `readResolve()` and `writeReplace()` methods `private`\ncan force subclasses to silently ignore them, while declaring them\n`public` allows them to be invoked by untrusted code.\n\n\nIf the containing class is declared `final`, these methods can be declared `private`.\n\n**Example:**\n\n\n      class ClassWithSerialization implements Serializable {\n        public Object writeReplace() { // warning: 'writeReplace()' not declared protected\n            ...\n        }\n      }\n      \n"
        },
        {
          "shortName": "NonSerializableWithSerializationMethods",
          "displayName": "Non-serializable class with 'readObject()' or 'writeObject()'",
          "enabled": false,
          "description": "Reports non-`Serializable` classes that define `readObject()` or `writeObject()` methods. Such methods in that context normally indicate an error.\n\n**Example:**\n\n\n      public class SampleClass {\n        private void readObject(ObjectInputStream str) {}\n        private void writeObject(ObjectOutputStream str) {}\n      }\n"
        },
        {
          "shortName": "NonSerializableObjectPassedToObjectStream",
          "displayName": "Non-serializable object passed to 'ObjectOutputStream'",
          "enabled": false,
          "description": "Reports non-`Serializable` objects used as arguments to `java.io.ObjectOutputStream.write()`. Such calls will result in runtime exceptions.\n\n\nThis inspection assumes objects of the types `java.util.Collection` and\n`java.util.Map` to be `Serializable`, unless the types\nthey are declared in are non-`Serializable`.\n\n**Example:**\n\n\n      public class IWantToSerializeThis {\n        public static void main(String[] args) throws IOException {\n          try(var stream = new ObjectOutputStream(Files.newOutputStream(Paths.get(\"output\")))) {\n            // Warning -- will fail with NotSerializableException\n            stream.writeObject(new IWantToSerializeThis());\n          }\n        }\n      }\n"
        }
      ]
    },
    {
      "name": "Embedded",
      "inspections": [
        {
          "shortName": "ConnectionResource",
          "displayName": "Connection opened but not safely closed",
          "enabled": false,
          "description": "Reports Java ME `javax.microedition.io.Connection` resources that are not opened in front of a `try` block and closed in the corresponding `finally` block. Such resources may be inadvertently leaked if an exception is thrown before the resource is closed.\n\n**Example:**\n\n\n      void example() throws IOException {\n        Connection c = Connector.open(\"foo\");\n      }\n"
        },
        {
          "shortName": "OverlyLargePrimitiveArrayInitializer",
          "displayName": "Overly large initializer for array of primitive type",
          "enabled": false,
          "description": "Reports array initializer expressions for primitive arrays that contain too many elements. Such initializers may result in overly large class files because code must be generated to initialize each array element. In memory or bandwidth constrained environments, it may be more efficient to load large arrays of primitives from resource files.\n\n\nThis inspection is intended for Java ME and other highly resource constrained environments.\nApplying the results of this inspection without consideration might have negative effects on code clarity and design.\n\n\nUse the option to specify the maximum number of elements to allow in primitive array initializers."
        },
        {
          "shortName": "SingleCharacterStartsWith",
          "displayName": "Single character 'startsWith()' or 'endsWith()'",
          "enabled": false,
          "description": "Reports calls to `String.startsWith()` and `String.endsWith()` where single character string literals are passed as an argument.\n\n\nA quick-fix is suggested to replace such calls with more efficiently implemented `String.charAt()`.\n\n\nHowever, the performance gain of such change is minimal and the code becomes less readable because of the extra non-zero length check,\nso it is recommended to apply the quick-fix only inside tight loops.\n\n\nThis inspection is intended for Java ME and other highly resource constrained environments.\nApplying the results of this inspection without consideration might have negative effects on code clarity and design.\n\n**Example:**\n\n\n      boolean startsWithX(String s) {\n        return s.startsWith(\"x\");\n      }\n\nAfter the quick-fix is applied:\n\n\n      boolean startsWithX(String s) {\n        return !s.isEmpty() && s.charAt(0) == 'x';\n      }\n"
        },
        {
          "shortName": "AbstractClassWithOnlyOneDirectInheritor",
          "displayName": "Abstract class with a single direct inheritor",
          "enabled": false,
          "description": "Reports abstract classes that have precisely one direct inheritor. While such classes may offer admirable clarity of design, in memory-constrained or bandwidth-limited environments, they needlessly increase the total footprint of the application. Consider merging the abstract class with its inheritor.\n\n\nThis inspection is intended for Java ME and other highly resource constrained environments.\nApplying the results of this inspection without consideration might have negative effects on code clarity and design.\n\n**Example:**\n\n\n      abstract class Base {} // will be reported\n\n      class Inheritor extends Base {}\n"
        },
        {
          "shortName": "PrivateMemberAccessBetweenOuterAndInnerClass",
          "displayName": "Synthetic accessor call",
          "enabled": false,
          "description": "Reports references from a nested class to non-constant `private` members of an outer class. For such references, javac will generate package-private synthetic accessor methods, which may compromise the security because members appearing to be private will in fact be accessible from the entire package.\n\n\nA nested class and its outer class are compiled to separate\nclass files. The Java virtual machine normally prohibits access from a class to private fields and methods of\nanother class. To enable access from a nested class to private members of an outer class, javac creates a package-private\nsynthetic accessor method.\n\n\nBy making the `private` member package-private instead, the actual accessibility is made explicit.\nThis also saves a little bit of memory, which may improve performance in resource constrained environments.\n\n\nThis inspection only reports if the language level of the project or module is 10 or lower.\nUnder Java 11 and higher accessor methods are not generated anymore,\nbecause of nest-based access control ([JEP 181](https://openjdk.java.net/jeps/181)).\n\n**Example:**\n\n\n      class Outer {\n        private void x() {}\n\n        class Inner {\n          void y() {\n            x();\n          }\n        }\n      }\n\nAfter the quick fix is applied:\n\n\n      class Outer {\n        void x() {}\n\n        class Inner {\n          void y() {\n            x();\n          }\n        }\n      }\n"
        },
        {
          "shortName": "InterfaceWithOnlyOneDirectInheritor",
          "displayName": "Interface with a single direct inheritor",
          "enabled": false,
          "description": "Reports interfaces that have precisely one direct inheritor. While such interfaces may offer admirable clarity of design, in memory-constrained or bandwidth-limited environments, they needlessly increase the total footprint of the application. Consider merging the interface with its inheritor.\n\n\nThis inspection is intended for Java ME and other highly resource constrained environments.\nApplying the results of this inspection without consideration might have negative effects on code clarity and design."
        },
        {
          "shortName": "RecordStoreResource",
          "displayName": "'RecordStore' opened but not safely closed",
          "enabled": false,
          "description": "Reports Java ME `javax.microedition.rms.RecordStore` resources that are not opened in front of a `try` block and closed in the corresponding `finally` block.\n\nSuch resources may be inadvertently leaked if an exception is thrown before the resource is closed.\n\n\nThis inspection is intended for Java ME and other highly resource constrained environments.\nApplying the results of this inspection without consideration might have negative effects on code clarity and design.\n\n**Example:**\n\n\n      void foo1() throws RecordStoreException {\n          RecordStore rs = RecordStore.openRecordStore(\"bar\", true); // warning\n      }\n      void foo2() throws RecordStoreException {\n          RecordStore rs = RecordStore.openRecordStore(\"bar\", true); // no warning\n          try {\n              /* ... */\n          } finally {\n              rs.closeRecordStore();\n          }\n      }\n"
        },
        {
          "shortName": "MultiplyOrDivideByPowerOfTwo",
          "displayName": "Multiplication or division by power of two",
          "enabled": false,
          "description": "Reports multiplication of an integer value by a constant integer that can be represented as a power of two. Such expressions can be replaced with right or left shift operations for a possible performance improvement.\n\n\nNote that this inspection is not relevant for modern JVMs (e. g.,\nHotSpot or OpenJ9) because their JIT compilers will perform this optimization.\nIt might only be useful in some embedded systems where no JIT compilation is performed.\n\n**Example:**\n\n\n      int y = x * 4;\n\nA quick-fix is suggested to replace the multiplication or division operation with the shift operation:\n\n\n      int y = x << 2;\n\n\nUse the option to make the inspection also report division by a power of two.\nNote that replacing a power of two division with a shift does not work for negative numbers."
        },
        {
          "shortName": "MethodCallInLoopCondition",
          "displayName": "Method call in loop condition",
          "enabled": false,
          "description": "Reports method calls in the condition part of a loop statement. In highly resource constrained environments, such calls may have adverse performance implications.\n\n\nApplying the results of this inspection without consideration might have negative effects on code clarity and design.\nThis inspection is intended for Java ME and other highly resource constrained environments.\n\n**Example:**\n\n\n      String s = \"example\";\n      for (int i = 0; i < s.length(); i++) {\n        System.out.println(s.charAt(i));\n      }\n\nAfter the quick-fix is applied:\n\n\n      String s = \"example\";\n      int length = s.length();\n      for (int i = 0; i < length; i++) {\n        System.out.println(s.charAt(i));\n      }\n\n\nUse the option to ignore calls to common Java iteration methods like `Iterator.hasNext()`\nand known methods with side-effects like `Atomic*.compareAndSet`."
        },
        {
          "shortName": "ArrayLengthInLoopCondition",
          "displayName": "Array.length in loop condition",
          "enabled": false,
          "description": "Reports accesses to the `.length` property of an array in the condition part of a loop statement. In highly resource constrained environments, such calls may have adverse performance implications.\n\n\nThis inspection is intended for Java ME and other highly resource constrained environments.\nApplying the results of this inspection without consideration might have negative effects on code clarity and design.\n\n**Example:**\n\n\n      void foo(Object[] x) {\n        for (int i = 0; i < x.length; i++) { /**/ }\n      }\n"
        },
        {
          "shortName": "CheckForOutOfMemoryOnLargeArrayAllocation",
          "displayName": "Large array allocation with no OutOfMemoryError check",
          "enabled": false,
          "description": "Reports large array allocations which do not check for `java.lang.OutOfMemoryError`. In memory constrained environments, allocations of large data objects should probably be checked for memory depletion.\n\n\nThis inspection is intended for Java ME and other highly resource constrained environments.\nApplying the results of this inspection without consideration might have negative effects on code clarity and design.\n\n\nUse the option to specify the maximum number of elements to allow in unchecked array allocations."
        }
      ]
    },
    {
      "name": "GPath",
      "inspections": [
        {
          "shortName": "GroovyListSetCanBeKeyedAccess",
          "displayName": "Call to List.set can be keyed access",
          "enabled": false,
          "description": "Reports calls to `java.util.List.set()` methods. Such calls could be replaced by the shorter and clearer keyed access form.\n\n**Example:**\n\n\n    def list = [\"foo\"]\n    list.set(0, \"bar\") // list.set(0, \"bar\") could be replaced with list[0] = \"bar\"\n\nAfter the quick-fix is applied:\n\n\n    def list = [\"foo\"]\n    list[0] = \"bar\"\n\n"
        },
        {
          "shortName": "GroovyMapPutCanBeKeyedAccess",
          "displayName": "Call to Map.put can be keyed access",
          "enabled": false,
          "description": "Reports calls to `java.util.Map.put()` methods. Such calls could be replaced by the shorter and clearer keyed access form.\n\n**Example:**\n\n\n    def map = [\"foo\": \"bar\"]\n    map.put(\"foo\", \"baz\") // map.put(\"foo\", \"baz\") could be replaced with map[\"foo\"] = \"baz\"\n\nAfter the quick-fix is applied:\n\n\n    def map = [\"foo\": \"bar\"]\n    map[\"foo\"] = \"baz\"\n\n"
        },
        {
          "shortName": "GroovyMapGetCanBeKeyedAccess",
          "displayName": "Call to Map.get can be keyed access",
          "enabled": false,
          "description": "Reports calls to `java.util.Map.get()` methods. Such calls could be replaced by the shorter and clearer keyed access form.\n\n**Example:**\n\n\n    def map = [\"foo\": \"bar\"]\n    def str = map.get(\"foo\") // map.get(\"foo\") could be replaced with map[\"foo\"]\n\nAfter the quick-fix is applied:\n\n\n    def map = [\"foo\": \"bar\"]\n    def str = map[\"foo\"]\n\n"
        },
        {
          "shortName": "GroovyListGetCanBeKeyedAccess",
          "displayName": "Call to List.get can be keyed access",
          "enabled": false,
          "description": "Reports calls to `java.util.List.get()` methods. Such calls could be replaced by the shorter and clearer keyed access form.\n\n**Example:**\n\n\n    def list = [\"foo\"]\n    def str = list.get(0) // list.get(0) could be replaced with list[0]\n\nAfter the quick-fix is applied:\n\n\n    def list = [\"foo\"]\n    def str = list[0]\n\n"
        }
      ]
    },
    {
      "name": "Imports",
      "inspections": [
        {
          "shortName": "UNUSED_IMPORT",
          "displayName": "Unused import",
          "enabled": false,
          "description": "Reports redundant `import` statements.\n\nRegular `import` statements are unnecessary when not using imported classes and packages in the source file.\nThe same applies to imported `static` fields and methods that aren't used in the source file.\n\n**Example:**\n\n\n      import java.util.ArrayList;\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n\nAfter the quick fix is applied:\n\n\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n"
        },
        {
          "shortName": "SingleClassImport",
          "displayName": "Single class import",
          "enabled": false,
          "description": "Reports `import` statements that import single classes (as opposed to entire packages).\n\nSome coding standards prohibit such `import` statements.\n\n\nYou can configure IntelliJ IDEA to detect and fix such statements with its **Optimize Imports** command. Go to\n[Settings \\| Editor \\| Code Style \\| Java \\| Imports](settings://preferences.sourceCode.Java?Use%20single%20class%20import)\nand clear the **Use single class import** checkbox. Thus this inspection is mostly useful for\noffline reporting on code bases that you don't intend to change."
        },
        {
          "shortName": "OnDemandImport",
          "displayName": "'*' import",
          "enabled": false,
          "description": "Reports any `import` statements that cover entire packages ('\\* imports').\n\nSome coding standards prohibit such `import` statements.\n\n\nYou can configure IntelliJ IDEA to detect and fix such statements with its **Optimize Imports**\ncommand. Go to [Settings \\| Editor \\| Code Style \\| Java \\| Imports](settings://preferences.sourceCode.Java?Use%20single%20class%20import),\nmake sure that the **Use single class import** option is enabled, and specify values in the\n**Class count to use import with '\\*'** and **Names count to use static import with '\\*'** fields.\nThus this inspection is mostly useful for offline reporting on code bases that you don't\nintend to change."
        },
        {
          "shortName": "JavaLangImport",
          "displayName": "Unnecessary import from the 'java.lang' package",
          "enabled": false,
          "description": "Reports `import` statements that refer to the `java.lang` package.\n\n\n`java.lang` classes are always implicitly imported, so such import statements are\nredundant and confusing.\n\n\nSince IntelliJ IDEA can automatically detect and fix such statements with its **Optimize Imports** command, this inspection is mostly useful for offline reporting on code bases that you don't intend to change."
        },
        {
          "shortName": "SamePackageImport",
          "displayName": "Unnecessary import from the same package",
          "enabled": false,
          "description": "Reports `import` statements that refer to the same package as the containing file.\n\n\nSame-package files are always implicitly imported, so such `import`\nstatements are redundant and confusing.\n\n\nSince IntelliJ IDEA can automatically detect and fix such statements with its **Optimize Imports**\ncommand, this inspection is mostly useful for offline reporting on code bases that you\ndon't intend to change."
        },
        {
          "shortName": "StaticImport",
          "displayName": "Static import",
          "enabled": false,
          "description": "Reports `import static` statements.\n\nSuch `import` statements are not supported under Java 1.4 or earlier JVMs.\n\nConfigure the inspection:\n\n* Use the table below to specify the classes that will be ignored by the inspection when used in an `import static` statement.\n* Use the **Ignore single field static imports** checkbox to ignore single-field `import static` statements.\n* Use the **Ignore single method static imports** checkbox to ignore single-method `import static` statements."
        }
      ]
    },
    {
      "name": "Data flow",
      "inspections": [
        {
          "shortName": "BooleanVariableAlwaysNegated",
          "displayName": "Boolean variable is always inverted",
          "enabled": false,
          "description": "Reports boolean variables or fields which are always negated when their value is used.\n\nExample:\n\n\n          void m() {\n            boolean b = true; //boolean variable 'b' is always inverted\n            System.out.println(!b);\n          }\n"
        },
        {
          "shortName": "ConstantValueVariableUse",
          "displayName": "Use of variable whose value is known to be constant",
          "enabled": false,
          "description": "Reports any usages of variables which are known to be constant.\n\nThis is the case if the (read) use of the variable is surrounded by an\n`if`, `while`, or `for`\nstatement with an `==` condition which compares the variable with a constant.\nIn this case, the use of a variable which is known to be constant can be replaced with\nan actual constant.\n\nExample:\n\n\n        private static void foo(double number) {\n            if (number == 1.0) {\n                f(number);\n            }\n        }\n        private static void f(double number) {}\n\nAfter the quick-fix is applied:\n\n\n        private static void foo(double number) {\n            if (number == 1.0) {\n                f(1.0);\n            }\n        }\n        private static void f(double number) {}\n"
        },
        {
          "shortName": "ReuseOfLocalVariable",
          "displayName": "Reuse of local variable",
          "enabled": false,
          "description": "Reports local variables that are \"reused\" overwriting their values with new values unrelated to their original use.\n\nSuch a local variable reuse may be confusing,\nas the intended semantics of the local variable may vary with each use. It may also be\nprone to bugs if due to the code changes, the values that have been considered overwritten actually\nappear to be alive. It is a good practice to keep variable lifetimes as short as possible, and not\nto reuse local variables for the sake of brevity.\n\nExample:\n\n\n        void x() {\n            String s = \"one\";\n            System.out.println(\"s = \" + s);\n            s = \"two\"; //reuse of local variable 's'\n            System.out.println(\"s = \" + s);\n        }\n"
        },
        {
          "shortName": "BooleanMethodIsAlwaysInverted",
          "displayName": "Boolean method is always inverted",
          "enabled": false,
          "description": "Reports methods with a `boolean` return type that are used only in a negated context.\n\nThe quick-fix makes it possible to rename and invert the method.\nDue to performance reasons, some methods might not be highlighted in the editor.\n\nExample:\n\n\n      class C {\n        boolean alwaysTrue() {\n          return true;\n        }\n\n        void f() {\n          if (!alwaysTrue()) {\n            return;\n          }\n        }\n        boolean member = !alwaysTrue();\n      }\n\nAfter the quick-fix is applied:\n\n\n      class C {\n        boolean alwaysFalse() {\n          return false;\n        }\n\n        void f() {\n          if (alwaysFalse()) {\n            return;\n          }\n        }\n        boolean member = alwaysFalse();\n      }\n"
        },
        {
          "shortName": "TooBroadScope",
          "displayName": "Scope of variable is too broad",
          "enabled": false,
          "description": "Reports any variable declarations that can be moved to a smaller scope.\n\nThis inspection is especially\nuseful for *Pascal style* declarations at the beginning of a method. Additionally variables with too broad a\nscope are also often left behind after refactorings.\n\n**Example:**\n\n\n      StringBuilder sb = new StringBuilder();\n      System.out.println();\n      sb.append(1);\n\nAfter the quick-fix is applied:\n\n\n      System.out.println();\n      StringBuilder sb = new StringBuilder();\n      sb.append(1);\n\nConfigure the inspection:\n\n* Use the **Only report variables that can be moved into inner blocks** option to report only those variables that can be moved inside deeper code blocks. For example, when the option is enabled, the movement will not be suggested for the `sb` variable above. However, it will be suggested for the following code:\n\n\n        StringBuilder sb = new StringBuilder(a);\n        if (flag) {\n          sb.append(1);\n        }\n\n* Use the **Report variables with a new expression as initializer\n  (potentially unsafe)** option to report variables that are initialized with a new expression. This makes the inspection potentially unsafe when the constructor has non-local side effects. For example, when the option is enabled, the movement will be suggested for the `foo` variable:\n\n\n        class Foo {\n          static List<Foo> fooList = new ArrayList<>();\n          String bar;\n\n          Foo(String bar) {\n              this.bar = bar;\n              fooList.add(this);\n          }\n\n          public static void main(String[] args) {\n            // movement is possible even though is unsafe\n            Foo foo = new Foo(\"bar\");\n            System.out.println(fooList.size());\n            System.out.println(foo.bar);\n          }\n        }\n"
        },
        {
          "shortName": "LawOfDemeter",
          "displayName": "Method call violates Law of Demeter",
          "enabled": false,
          "description": "Reports [Law of Demeter](https://en.wikipedia.org/wiki/Law_of_Demeter) violations.\n\nThe Law of Demeter specifies a style guideline: never call a method on an object you got from another call.\nThe code that follows this guideline is easier to maintain, adapt, and refactor, has less coupling between methods, less duplication,\nand better information hiding. On the other hand, you might need to write many wrapper methods to meet this guideline."
        },
        {
          "shortName": "UnnecessaryLocalVariable",
          "displayName": "Redundant local variable",
          "enabled": false,
          "description": "Reports unnecessary local variables that add nothing to the comprehensibility of a method, including:\n\n* Local variables that are immediately returned.\n* Local variables that are immediately assigned to another variable and then not used.\n* Local variables that always have the same value as another local variable or parameter.\n\n**Example:**\n\n\n      boolean yes() {\n        boolean b = true;\n        return b;\n      }\n\nAfter the quick-fix is applied:\n\n\n      boolean yes() {\n        return true;\n      }\n      \nConfigure the inspection:\n\n* Use the **Ignore immediately returned or thrown variables** option to ignore immediately returned or thrown variables. Some coding styles suggest using such variables for clarity and ease of debugging.\n* Use the **Ignore variables which have an annotation** option to ignore annotated variables."
        },
        {
          "shortName": "NegativelyNamedBooleanVariable",
          "displayName": "Negatively named boolean variable",
          "enabled": false,
          "description": "Reports negatively named variables, for example: `disabled`, `hidden`, or `isNotChanged`.\n\nUsually, inverting the `boolean` value and removing the negation from the name makes the code easier to understand.\n\nExample:\n\n\n        boolean disabled = false;\n"
        },
        {
          "shortName": "GroovyVariableCanBeFinal",
          "displayName": "Variable can be final",
          "enabled": false,
          "description": "Reports parameters or local variables that may have a final modifier added.\n\n**Example:**\n\n\n      def list = [1,2,3]\n      return list\n\nAfter the quick-fix is applied:\n\n\n      final def list = [1,2,3]\n      return list\n\nFor more information, see the same inspection in Java."
        },
        {
          "shortName": "GroovyUnusedIncOrDec",
          "displayName": "Unused incrementing or decrementing",
          "enabled": false,
          "description": "Reports unused incrementing and decrementing expressions."
        },
        {
          "shortName": "GroovyVariableNotAssigned",
          "displayName": "Variable not assigned",
          "enabled": false,
          "description": "Reports variables that might not have been initialized."
        },
        {
          "shortName": "GroovyMissingReturnStatement",
          "displayName": "Missing return statement",
          "enabled": false,
          "description": "Reports missing `return` statements at the end of methods with a non-**void** return type. The end of method should be reachable by the method's execution flow.\n\n**Example:**\n\n\n    String foo(int a) {\n      if (a > 0) {\n        return \"more than zero\"\n      }\n    } // foo(-1) will return 'null'\n\n    int bar(int a) {\n      if (a > 0) {\n        return a\n      }\n    } // bar(-1) will fall with runtime exception\n\n"
        },
        {
          "shortName": "GroovyUnusedAssignment",
          "displayName": "Unused assignment",
          "enabled": false,
          "description": "Reports the cases where a variable is redundant as its value is never used after its assignment.\n\nIf the variable is unused, we recommend removing it to shorten the code and to avoid redundant allocations.\n\nThe following cases are reported:\n\n* the variable never gets read after assignment\n* the value is always overwritten with another assignment before the next variable read\n* the variable initializer is redundant (for one of the above two reasons)\n\nFor more info see the same inspection in Java."
        }
      ]
    },
    {
      "name": "Inheritance issues",
      "inspections": [
        {
          "shortName": "ExtendsAnnotation",
          "displayName": "Class extends annotation interface",
          "enabled": true,
          "description": "Reports classes declared as an implementation or extension of an annotation interface.\n\nWhile it is legal to extend an annotation interface, it is often done by accident,\nand the result can't be used as an annotation."
        },
        {
          "shortName": "RedundantMethodOverride",
          "displayName": "Method is identical to its super method",
          "enabled": false,
          "description": "Reports methods that are identical to their super methods. Such methods have the same signature as their super method and either have an identical body or only their body consists only of a call to the super method. These methods are redundant and can be removed.\n\n\nUse the checkbox below to run the inspection for the methods that override library methods.\nChecking library methods may slow down the inspection."
        },
        {
          "shortName": "ProblematicVarargsMethodOverride",
          "displayName": "Non-varargs method overrides varargs method",
          "enabled": false,
          "description": "Reports methods that override a variable arity (a.k.a. varargs) method but replace the variable arity parameter with an array parameter. Though this code is valid, it may be confusing and should be avoided."
        },
        {
          "shortName": "InterfaceNeverImplemented",
          "displayName": "Interface which has no concrete subclass",
          "enabled": false,
          "description": "Reports interfaces that have no concrete subclasses.\n\nConfigure the inspection:\n\n* Use the list below to add annotations. Interfaces declared with one of these annotations will be ignored by the inspection.\n* Use the checkbox below to ignore interfaces that only declare constant fields. Such interfaces may still be usable even without implementations."
        },
        {
          "shortName": "AbstractMethodOverridesConcreteMethod",
          "displayName": "Abstract method overrides concrete method",
          "enabled": false,
          "description": "Reports `abstract` methods that override concrete super methods.\n\nMethods overridden from `java.lang.Object` are not reported by this inspection."
        },
        {
          "shortName": "MissingOverrideAnnotation",
          "displayName": "Missing '@Override' annotation",
          "enabled": true,
          "description": "Reports methods overriding superclass methods but are not annotated with `@java.lang.Override`.\n\n\nAnnotating methods with `@java.lang.Override` improves code readability since it shows the intent.\nIn addition, the compiler emits an error when a signature of the overridden method doesn't match the superclass method.\n\n**Example:**\n\n\n        class X {\n          public String toString() {\n            return \"hello world\";\n          }\n        }\n      \nAfter the quick-fix is applied:\n\n\n        class X {\n          @Override\n          public String toString() {\n            return \"hello world\";\n          }\n        }\n      \nConfigure the inspection:\n\n* Use the **Ignore 'equals()', 'hashCode()' and 'toString()'** option to ignore these `java.lang.Object` methods: `equals()`, `hashCode()`, and `toString()`. The risk that these methods will disappear and your code won't be compiling anymore due to the `@Override` annotation is relatively small.\n* Use the **Ignore methods in anonymous classes** option to ignore methods in anonymous classes.\n* Disable the **Highlight method when its overriding methods do not all have the '@Override' annotation** option to only warn on the methods missing an `@Override` annotation, and not on overridden methods where one or more descendants are missing an `@Override` annotation.\n\nThis inspection only reports if the language level of the project or module is 5 or higher."
        },
        {
          "shortName": "ExtendsConcreteCollection",
          "displayName": "Class explicitly extends a 'Collection' class",
          "enabled": false,
          "description": "Reports classes that extend concrete subclasses of the `java.util.Collection` or `java.util.Map` classes.\n\n\nSubclassing concrete collection types is a common yet poor practice. It is considerably more brittle than delegating collection calls."
        },
        {
          "shortName": "TypeParameterExtendsFinalClass",
          "displayName": "Type parameter extends 'final' class",
          "enabled": false,
          "description": "Reports type parameters declared to extend a `final` class.\n\nSuggests replacing the type parameter with the type of the specified`final` class since\n`final` classes cannot be extended.\n\n**Example:**\n\n\n      void foo() {\n        List<? extends Integer> list; // Warning: the Integer class is a final class\n      }\n\nAfter the quick-fix is applied:\n\n\n      void foo() {\n        List<Integer> list;\n      }\n"
        },
        {
          "shortName": "RefusedBequest",
          "displayName": "Method does not call super method",
          "enabled": true,
          "description": "Reports methods that override a particular method without calling `super`.\n\nThis is also known as a *refused bequest*. Such methods\nmay represent a failure of abstraction and cause hard-to-trace bugs.\n\nThe inspection doesn't report default methods and methods overridden\nfrom `java.lang.Object`, except for `clone()`.\nThe `clone()` method is expected to call its `super`, which will automatically return an object of the correct type.\n\n**Examples:**\n\n*\n\n\n        class A {\n          @Override\n          public Object clone() { // reported, because it does not call 'super.clone()'\n            return new A();\n          }\n        }\n        \n*\n\n\n        interface I {\n          default void foo() {}\n        }\n\n        class A implements I {\n          // warning on method when 'Ignore 'default' super methods' and 'Ignore annotated' options are disabled\n          @Override\n          public void foo(){}\n        }\n          \nConfigure the inspection:\n\n* Use the **Only report when super method is annotated by** option to ignore `super` methods marked with the annotations from the provided list. You can manually add annotations to the list.\n* Use the **Ignore empty super methods** option to ignore `super` methods that are either empty or only throw an exception.\n* Use the **Ignore 'default' super methods** option to ignore `super` methods with the `default` keyword."
        },
        {
          "shortName": "ExtendsUtilityClass",
          "displayName": "Class extends utility class",
          "enabled": false,
          "description": "Reports classes that extend a utility class.\n\n\nA utility class is a non-empty class in which all fields and methods are static.\nExtending a utility class also allows for inadvertent object instantiation of the\nutility class, because the constructor cannot be made private in order to allow extension.\n\n\nConfigure the inspection:\n\n* Use the **Ignore if overriding class is a utility class** option to ignore any classes that override a utility class but are also utility classes themselves."
        },
        {
          "shortName": "ImplicitSubclassInspection",
          "displayName": "Final declaration can't be overridden at runtime",
          "enabled": true,
          "description": "Reports cases when your code prevents a class from being subclassed by some framework (for example, Spring or Hibernate) at runtime.\n\nTypical examples of necessary but impossible subclassing:\n\n* `final` classes marked with framework-specific annotations (for example, Spring `@Configuration`)\n* `final`, `static` or `private` methods marked with framework-specific annotations (for example, Spring `@Transactional`)\n* methods marked with framework-specific annotations inside `final` classes\n\nThe list of reported cases depends on the frameworks used."
        },
        {
          "shortName": "ParameterTypePreventsOverriding",
          "displayName": "Parameter type prevents overriding",
          "enabled": false,
          "description": "Reports parameter types of a subclass method that have the same name as the parameter type of the corresponding super method but belong to a different package. In these cases, the subclass method cannot override the super method.\n\n**Example:**\n\n\n    public class A {\n     public void method(Object o) {}\n    }\n\n    public class B extends A {\n     public void method(Object o) {} // warning on parameter type\n     class Object {}\n    }\n\nAfter the quick-fix is applied:\n\n\n    public class A {\n     public void method(Object o) {}\n    }\n\n    public class B extends A {\n     public void method(java.lang.Object o) {} // new parameter type\n     class Object {}\n    }\n"
        },
        {
          "shortName": "NonProtectedConstructorInAbstractClass",
          "displayName": "Public constructor in abstract class",
          "enabled": false,
          "description": "Reports `public` constructors of `abstract` classes.\n\n\nConstructors of `abstract` classes can only be called from the constructors of\ntheir subclasses, declaring them `public` may be confusing.\n\nThe quick-fix makes such constructors protected.\n\n**Example:**\n\n\n      public abstract class Foo {\n        public Foo () { // warning: has 'public' modifier\n            /* ... */\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      public abstract class Foo {\n        protected Foo () {\n            /* ... */\n        }\n      }\n\nConfigure the inspection:\n\nUse the option below to ignore non-public classes."
        },
        {
          "shortName": "FrequentlyUsedInheritorInspection",
          "displayName": "Class may extend a commonly used base class",
          "enabled": true,
          "description": "Reports classes or interfaces that can be replaced with an implementation or extension of a more specific commonly used class or interface.\n\nFor this inspection to work, a superclass needs to be in project source files and the project needs to use the IntelliJ IDEA build system.\n\n**Example:**\n\n\n      class MyInheritor implements A {} // B suggested on the A reference\n\n      interface A {}\n\n      abstract class B implements A {}\n\n      abstract class C1 extends B {}\n      abstract class C2 extends B {}\n      abstract class C3 extends B {}\n      abstract class C4 extends B {}\n      abstract class C5 extends B {}\n\nBy default, this inspection doesn't highlight issues in the editor but only provides a quick-fix.\n\nNew in 2017.2"
        },
        {
          "shortName": "AbstractClassExtendsConcreteClass",
          "displayName": "Abstract class extends concrete class",
          "enabled": false,
          "description": "Reports `abstract` classes that extend concrete classes."
        },
        {
          "shortName": "AbstractMethodOverridesAbstractMethod",
          "displayName": "Abstract method overrides abstract method",
          "enabled": false,
          "description": "Reports `abstract` methods that override `abstract` methods.\n\nSuch methods don't make sense because any concrete child class will have to implement the abstract method anyway.\n\n\nMethods whose return types, exception declarations, annotations, or modifiers differ from the overridden method are not reported by this inspection.\n\n\nConfigure the inspection:\n\n* Use the **Ignore methods with different Javadoc than their super methods** option to ignore any abstract methods whose JavaDoc comment differs from their super method."
        },
        {
          "shortName": "AbstractMethodWithMissingImplementations",
          "displayName": "Abstract method with missing implementations",
          "enabled": false,
          "description": "Reports `abstract` methods that are not implemented in every concrete subclass.\n\n\nThis results in a compile-time error on the subclasses;\nthe inspection reports the problem at the point of the abstract method, allowing faster detection of the problem."
        },
        {
          "shortName": "AbstractClassWithoutAbstractMethods",
          "displayName": "Abstract class without 'abstract' methods",
          "enabled": false,
          "description": "Reports `abstract` classes that have no `abstract` methods."
        },
        {
          "shortName": "AbstractClassNeverImplemented",
          "displayName": "Abstract class which has no concrete subclass",
          "enabled": true,
          "description": "Reports `abstract` classes that have no concrete subclasses."
        },
        {
          "shortName": "StaticInheritance",
          "displayName": "Static inheritance",
          "enabled": false,
          "description": "Reports interfaces that are implemented only to provide access to constants. This kind of inheritance is often confusing and may hide important dependency information."
        }
      ]
    },
    {
      "name": "Control flow issues",
      "inspections": [
        {
          "shortName": "NegatedEqualityExpression",
          "displayName": "Negated equality expression",
          "enabled": false,
          "description": "Reports equality expressions which are negated by a prefix expression.\n\nSuch expressions can be simplified using the `!=` operator.\n\nExample:\n\n\n      !(i == 1)\n\nAfter the quick-fix is applied:\n\n\n      i != 1\n"
        },
        {
          "shortName": "DoubleNegation",
          "displayName": "Double negation",
          "enabled": true,
          "description": "Reports double negations that can be simplified.\n\nExample:\n\n\n      if (!!functionCall()) {}\n\nAfter the quick-fix is applied:\n\n\n      if (functionCall()) {}\n\nExample:\n\n\n      if (!(a != b)) {}\n\nAfter the quick-fix is applied:\n\n\n      if (a == b) {}\n"
        },
        {
          "shortName": "AssertionCanBeIf",
          "displayName": "Assertion can be replaced with 'if' statement",
          "enabled": false,
          "description": "Reports `assert` statements and suggests replacing them with `if` statements that throw `java.lang.AssertionError`.\n\nExample:\n\n\n      assert param != null;\n\nAfter the quick-fix is applied:\n\n\n      if (param == null) throw new AssertionError();\n"
        },
        {
          "shortName": "BreakStatement",
          "displayName": "'break' statement",
          "enabled": false,
          "description": "Reports `break` statements that are used in places other than at the end of a `switch` statement branch.\n\n`break` statements complicate refactoring and can be confusing.\n\nExample:\n\n\n    void foo(List<String> strs) {\n      for (String str : strs) {\n        if (str.contains(\"stop\")) break;\n        handleStr(str);\n      }\n    }\n"
        },
        {
          "shortName": "InfiniteLoopStatement",
          "displayName": "Infinite loop statement",
          "enabled": true,
          "description": "Reports `for`, `while`, or `do` statements that can only exit by throwing an exception. While such statements may be correct, they often happen due to coding errors.\n\nExample:\n\n\n      for (;;) {\n      }\n\n\nUse the **Ignore when placed in Thread.run** option to ignore the\ninfinite loop statements inside `Thread.run`.\nIt may be useful for the daemon threads.\n\nExample:\n\n\n      new Thread(() -> {\n        while (true) {\n        }\n      }).start();\n"
        },
        {
          "shortName": "ConditionalCanBePushedInsideExpression",
          "displayName": "Conditional can be pushed inside branch expression",
          "enabled": false,
          "description": "Reports conditional expressions with `then` and else branches that are similar enough so that the expression can be moved inside. This action shortens the code.\n\nExample:\n\n\n      double g(int a, int b) {\n        return a == b ? Math.cos(0) : Math.cos(1);\n      }\n\nAfter the quick-fix is applied:\n\n\n      double g(int a, int b) {\n        return Math.cos(a == b ? 0 : 1);\n      }\n\nNew in 2017.2"
        },
        {
          "shortName": "ContinueStatementWithLabel",
          "displayName": "'continue' statement with label",
          "enabled": false,
          "description": "Reports `continue` statements with labels.\n\nLabeled `continue` statements complicate refactoring and can be confusing.\n\nExample:\n\n\n      void handle(List<String> strs) {\n        outer:\n        for (String s: strs) {\n          for (char ch : s.toCharArray()) {\n            if ('s' == ch) continue outer;\n            handleChar(ch);\n          }\n        }\n      }\n"
        },
        {
          "shortName": "SimplifiableBooleanExpression",
          "displayName": "Simplifiable boolean expression",
          "enabled": true,
          "description": "Reports boolean expressions that can be simplified.\n\nExample:\n\n\n      void f(boolean foo, boolean bar) {\n        boolean b = !(foo ^ bar);\n      }\n\nAfter the quick-fix is applied:\n\n\n      void f(boolean foo, boolean bar) {\n        boolean b = foo == bar;\n      }\n\nExample:\n\n\n      void f(boolean foo, boolean bar) {\n        boolean b = (foo && bar) || !foo;\n      }\n      \nAfter the quick-fix is applied:\n\n\n      void f(boolean foo, boolean bar) {\n        boolean b = !foo || bar;\n      }\n      \n"
        },
        {
          "shortName": "NegatedConditionalExpression",
          "displayName": "Negated conditional expression",
          "enabled": false,
          "description": "Reports conditional expressions which are negated with a prefix expression, as such constructions may be confusing.\n\nThere is a fix that propagates the outer negation to both branches.\n\nExample:\n\n\n      !(i == 1 ? a : b)\n\nAfter the quick-fix is applied:\n\n\n      i == 1 ? !a : !b\n"
        },
        {
          "shortName": "SwitchStatement",
          "displayName": "'switch' statement",
          "enabled": false,
          "description": "Reports `switch` statements.\n\n`switch` statements often (but not always) indicate a poor object-oriented design.\n\nExample:\n\n\n      switch (i) {\n        // code\n      }\n"
        },
        {
          "shortName": "ConditionalExpression",
          "displayName": "Conditional expression",
          "enabled": false,
          "description": "Reports usages of the ternary condition operator and suggests converting them to `if`/`else` statements.\n\nSome code standards prohibit the use of the condition operator.\n\nExample:\n\n\n      Object result = (condition) ? foo() : bar();\n\nAfter the quick-fix is applied:\n\n\n      Object result;\n      if (condition) {\n        comp = foo();\n      }\n      else {\n        comp = bar();\n      }\n\nConfigure the inspection:\n\nUse the **Ignore for simple assignments and returns** option to ignore simple assignments and returns and allow the following constructs:\n\n\n      String s = (foo == null) ? \"\" : foo.toString();\n\n\nUse the **Ignore places where an if statement is not possible** option to ignore conditional expressions in contexts in which automatic\nreplacement with an if statement is not possible (for example, when the conditional expression is used as an argument to a\n`super()` constructor call)."
        },
        {
          "shortName": "ConditionalExpressionWithIdenticalBranches",
          "displayName": "Conditional expression with identical branches",
          "enabled": true,
          "description": "Reports conditional expressions with identical `then` and `else` branches.\n\nSuch expressions almost certainly indicate bugs. The inspection provides a fix that collapses conditional expressions.\n\nExample:\n\n\n      int y = x == 10 ? 4 : 4;\n\nAfter the quick-fix is applied:\n\n\n      int y = 4;\n"
        },
        {
          "shortName": "DefaultNotLastCaseInSwitch",
          "displayName": "'default' not last case in 'switch'",
          "enabled": false,
          "description": "Reports `switch` statements or expressions in which the `default` case comes before another case.\n\nThis construct is unnecessarily confusing.\nThere is a quick-fix that moves the `default` case to the last position.\nThe fix is available only when a given branch has `break`/`yield` at the end.\n\nExample:\n\n\n      switch (n) {\n          default:\n              System.out.println();\n              break;\n          case 1:\n              break;\n      }\n\nAfter the quick-fix is applied:\n\n\n      switch (n) {\n        case 1:\n            break;\n        default:\n            System.out.println();\n            break;\n      }\n"
        },
        {
          "shortName": "SwitchStatementWithTooManyBranches",
          "displayName": "Maximum 'switch' branches",
          "enabled": false,
          "description": "Reports `switch` statements or expressions with too many `case` labels.\n\nSuch a long switch statement may be confusing and should probably be refactored.\nSometimes, it is not a problem (for example, a domain is very complicated and has enums with a lot of constants).\n\nExample:\n\n\n        switch (x) {\n            case 1 -> {}\n            case 2 -> {}\n            case 3 -> {}\n            case 4 -> {}\n            case 5 -> {}\n            case 6 -> {}\n            case 7 -> {}\n            case 8 -> {}\n            case 9 -> {}\n            case 10 -> {}\n            case 11,12,13 -> {}\n            default -> {}\n        }\n\nUse the **Maximum number of branches** field to specify the maximum number of `case` labels expected."
        },
        {
          "shortName": "LoopConditionNotUpdatedInsideLoop",
          "displayName": "Loop variable not updated inside loop",
          "enabled": true,
          "description": "Reports any variables and parameters that are used in a loop condition and are not updated inside the loop.\n\nSuch variables and parameters are usually used by mistake as they\nmay cause an infinite loop if they are executed.\n\nExample:\n\n\n      void loopDoesNotLoop(boolean b) {\n        while (b) {\n          System.out.println();\n          break;\n        }\n      }\n\nConfigure the inspection:\n\n\nUse the **Ignore possible non-local changes** option to disable this inspection\nif the condition can be updated indirectly (e.g. via the called method or concurrently from another thread)."
        },
        {
          "shortName": "ContinueStatement",
          "displayName": "'continue' statement",
          "enabled": false,
          "description": "Reports `continue` statements.\n\n`continue` statements complicate refactoring and can be confusing.\n\nExample:\n\n\n      void foo(List<String> strs) {\n        for (String str : strs) {\n          if (str.contains(\"skip\")) continue;\n          handleStr(str);\n        }\n      }\n"
        },
        {
          "shortName": "SwitchStatementDensity",
          "displayName": "'switch' statement with too low of a branch density",
          "enabled": false,
          "description": "Reports `switch` statements or expressions with a too low ratio of switch labels to executable statements.\n\nSuch `switch` statements\nmay be confusing and should probably be refactored.\n\nExample:\n\n\n        switch (i) { // one case and 5 executable statements -> 20% density\n            case 1:\n                System.out.println(\"1\");\n                System.out.println(\"2\");\n                System.out.println(\"3\");\n                System.out.println(\"4\");\n                System.out.println(\"5\");\n                break;\n        }\n\n\nUse the **Minimum density of branches** field to specify the allowed ratio of the switch labels to executable statements."
        },
        {
          "shortName": "BooleanExpressionMayBeConditional",
          "displayName": "Boolean expression could be replaced with conditional expression",
          "enabled": false,
          "description": "Reports any `boolean` expressions which can be formulated in a more compact and, arguably, clear way than by using a conditional expression.\n\nUse the quick-fix to replace the `boolean` expression by a conditional expression.\n\n**Example:**\n\n\n      a && b || !a && c;\n\nAfter the quick-fix is applied:\n\n\n      a ? b : c;\n"
        },
        {
          "shortName": "LoopWithImplicitTerminationCondition",
          "displayName": "Loop with implicit termination condition",
          "enabled": false,
          "description": "Reports any `while`, `do-while`, and `for` loops that have the `true` constant as their only condition. At the same time, such loops can be still terminated by a containing `if` statement which can break out of the loop.\n\nSuch an `if` statement must be the first or the only statement\nin a `while` or `for`\nloop and the last or the only statement in a `do-while` loop.\n\nRemoving the `if` statement and making its condition an explicit\nloop condition simplifies the loop."
        },
        {
          "shortName": "ExpressionMayBeFactorized",
          "displayName": "Expression can be factorized",
          "enabled": false,
          "description": "Reports expressions that can be factorized, i.e. reorganized to pull out a common factor. This reduces redundancy and could improve the readability of your code.\n\n**Example:**\n\n\n      a && b || a && c\n\nAfter the quick-fix is applied:\n\n\n      a && (b || c)\n\nNew in 2021.3"
        },
        {
          "shortName": "TrivialIf",
          "displayName": "Redundant 'if' statement",
          "enabled": false,
          "description": "Reports `if` statements that can be simplified to a single assignment, `return`, or `assert` statement.\n\nExample:\n\n\n      if (foo()) {\n        return true;\n      } else {\n        return false;\n      }\n\nAfter the quick-fix is applied:\n\n\n      return foo();\n\nConfigure the inspection:\n\nUse the **Ignore chained 'if' statements** option if want to hide a warning for chained `if` statements.\n\nFor example, in the following code the warning will be hidden, but the quick-fix will still be available:\n\n\n      if (condition1) return true;\n      if (condition2) return false;\n      return true;\n\nUse the **Ignore 'assert' statements** option if want to hide a warning for `if` statements\ncontaining only `assert` statement in their bodies.\n\nFor example, in the following code the warning will be hidden:\n\n\n      if (isTrue()) assert false;\n"
        },
        {
          "shortName": "PointlessBooleanExpression",
          "displayName": "Pointless statement or boolean expression",
          "enabled": true,
          "description": "Reports unnecessary or overly complicated boolean expressions.\n\nSuch expressions include `&&`-ing with `true`,\n`||`-ing with `false`,\nequality comparison with a boolean literal, or negation of a boolean literal. Such expressions can be simplified.\n\nExample:\n\n\n      boolean a = !(x && false);\n      boolean b = false || x;\n      boolean c = x != true;\n\nAfter the quick-fix is applied:\n\n\n      boolean a = true;\n      boolean b = x;\n      boolean c = !x;\n\n\nConfigure the inspection:\nUse the **Ignore named constants in determining pointless expressions** option to ignore named constants when determining if an expression is pointless."
        },
        {
          "shortName": "NestedSwitchStatement",
          "displayName": "Nested 'switch' statement",
          "enabled": false,
          "description": "Reports nested `switch` statements or expressions.\n\nNested `switch` statements\nmay result in extremely confusing code. These statements may be extracted to a separate method.\n\nExample:\n\n\n      int res = switch (i) {\n                case 0 -> 0;\n                default -> switch (i) {\n                    case 100 -> 0;\n                    default -> i;\n                };\n            };\n"
        },
        {
          "shortName": "PointlessNullCheck",
          "displayName": "Unnecessary 'null' check before method call",
          "enabled": false,
          "description": "Reports null checks followed by a method call that will definitely return `false` when `null` is passed (e.g. `Class.isInstance`).\n\nSuch a check seems excessive as the method call will always return `false` in this case.\n\nExample:\n\n\n      if (x != null && myClass.isInstance(x)) { ... }\n\nAfter the quick-fix is applied:\n\n\n      if (myClass.isInstance(x)) { ... }\n"
        },
        {
          "shortName": "NegatedConditional",
          "displayName": "Conditional expression with negated condition",
          "enabled": false,
          "description": "Reports conditional expressions whose conditions are negated.\n\nFlipping the order of the conditional expression branches usually increases the clarity of such statements.\n\n\nUse the **Ignore '!= null' comparisons** and **Ignore '!= 0' comparisons** options to ignore comparisons of the form\n`obj != null` or `num != 0`.\nSince `obj != null` effectively means \"obj exists\",\nthe meaning of the whole expression does not involve any negation\nand is therefore easy to understand.\n\n\nThe same reasoning applies to `num != 0` expressions, especially when using bit masks.\n\n\nThese forms have the added benefit of mentioning the interesting case first.\nIn most cases, the value for the `== null` branch is `null` itself,\nlike in the following examples:\n\n\n        static String getName(Person p) {\n            return p != null ? p.getName() : null;\n        }\n\n        static String getExecutableString(int fileMode) {\n            return (fileMode & 0b001001001) != 0 ? \"executable\" : \"non-executable\";\n        }\n"
        },
        {
          "shortName": "DuplicateCondition",
          "displayName": "Duplicate condition",
          "enabled": true,
          "description": "Reports duplicate conditions in `&&` and `||` expressions and branches of `if` statements. While sometimes duplicate conditions are intended, in most cases they the result of an oversight.\n\nExample:\n\n\n      boolean result = digit1 != digit2 || digit1 != digit2;\n\n\nTo ignore conditions that may produce side effects, use the **Ignore conditions with side effects** option.\nDisabling this option may lead to false-positives, for example, when the same method returns different values on subsequent invocations.\n\nExample:\n\n\n      if (iterator.next() != null || iterator.next() != null) {\n        System.out.println(\"Got it\");\n      }\n\nDue to possible side effects of `iterator.next()` (on the example), the warning will only be\ntriggered if the **Ignore conditions with side effects** option is disabled."
        },
        {
          "shortName": "ConditionalBreakInInfiniteLoop",
          "displayName": "Conditional break inside infinite loop",
          "enabled": false,
          "description": "Reports conditional breaks at the beginning or at the end of a loop and suggests using a loop condition instead to shorten the code.\n\nExample:\n\n\n      while (true) {\n        if (i  == 23) break;\n        i++;\n      }\n\nAfter the quick fix is applied:\n\n\n      while (i != 23) {\n        i++;\n      }\n"
        },
        {
          "shortName": "IfStatementWithIdenticalBranches",
          "displayName": "'if' statement with identical branches",
          "enabled": true,
          "description": "Reports `if` statements in which common parts can be extracted from the branches.\n\nThese common parts are independent from the condition and make `if` statements harder to understand.\n\nExample:\n\n\n      if (x > 12) {\n        doSomethingBefore();\n        doSomethingDifferent1();\n        doSomethingAfter();\n      } else {\n        doSomethingBefore();\n        doSomethingDifferent2();\n        doSomethingAfter();\n      }\n\nAfter the quick-fix is applied:\n\n\n      doSomethingBefore();\n      if (x > 12) {\n        doSomethingDifferent1();\n      } else {\n        doSomethingDifferent2();\n      }\n      doSomethingAfter();\n\nUpdated in 2018.1"
        },
        {
          "shortName": "IdempotentLoopBody",
          "displayName": "Idempotent loop body",
          "enabled": true,
          "description": "Reports loops whose second and all subsequent iterations do not produce any additional side effects other than the one produced by the first iteration, which can indicate a programming error.\n\nSuch loops may iterate only zero, one, or infinite number of times.\nIf the infinite number of times case is unreachable, such a loop can be replaced with an `if` statement.\nOtherwise, there's a possibility that the program can get stuck.\n\nExample:\n\n\n        public void foo(String baseName, String names) {\n            int suffix = 1;\n            String name = baseName;\n            while (names.contains(name)) {\n                // error: suffix is not updated making loop body idempotent\n                name = baseName + suffix;\n            }\n        }\n\nNew in 2018.1"
        },
        {
          "shortName": "FallthruInSwitchStatement",
          "displayName": "Fallthrough in 'switch' statement",
          "enabled": false,
          "description": "Reports 'fall-through' in a `switch` statement.\n\nFall-through occurs when a series of executable statements after a `case` label is not guaranteed\nto transfer control before the next `case` label. For example, this can happen if the branch is missing a `break` statement.\nIn that case, control falls through to the statements after\nthat `switch` label, even though the `switch` expression is not equal to\nthe value of the fallen-through label. While occasionally intended, this construction is confusing and is often the result of a typo.\n\n\nThis inspection ignores any fall-through commented with a text matching the regex pattern `(?i)falls?\\s*thro?u`.\n\nThere is a fix that adds a `break` to the branch that can fall through to the next branch.\n\nExample:\n\n\n        switch(x) {\n          case (4):\n              if (condition) {\n                  System.out.println(\"3\");\n                  // no break here\n              } else {\n                  break;\n              }\n          case (6):\n              System.out.println(\"4\");\n        }\n\nAfter the quick-fix is applied:\n\n\n        switch(x) {\n            case (4):\n                if (condition) {\n                    System.out.println(\"3\");\n                } else {\n                    break;\n                }\n                break;\n            case (6):\n                System.out.println(\"4\");\n        }\n"
        },
        {
          "shortName": "ConstantConditionalExpression",
          "displayName": "Constant conditional expression",
          "enabled": false,
          "description": "Reports conditional expressions in which the condition is either a `true` or `false` constant. These expressions sometimes occur as a result of automatic refactorings and may be simplified.\n\nExample:\n\n\n      return true ? \"Yes\" : \"No\";\n\nAfter quick-fix is applied:\n\n\n      return \"Yes\";\n"
        },
        {
          "shortName": "NestedConditionalExpression",
          "displayName": "Nested conditional expression",
          "enabled": false,
          "description": "Reports nested conditional expressions as they may result in extremely confusing code.\n\nExample:\n\n\n      int y = a == 10 ? b == 20 ? 10 : a : b;\n"
        },
        {
          "shortName": "OverlyComplexBooleanExpression",
          "displayName": "Overly complex boolean expression",
          "enabled": false,
          "description": "Reports boolean expressions with too many terms. Such expressions may be confusing and bug-prone.\n\nExample:\n\n\n      cond(x1) && cond(x2) ^ cond(x3) && cond(x4);\n\nConfigure the inspection:\n\n* Use the **Maximum number of terms** field to specify the maximum number of terms allowed in a boolean expression.\n* Use the **Ignore pure conjunctions and disjunctions** option to ignore boolean expressions which use only a single boolean operator repeatedly."
        },
        {
          "shortName": "SwitchStatementsWithoutDefault",
          "displayName": "'switch' statement without 'default' branch",
          "enabled": true,
          "description": "Reports `switch` statements that do not contain `default` labels.\n\nAdding the `default` label guarantees that all possible scenarios are covered, and it becomes\neasier to make assumptions about the current state of the program.\n\n\nNote that by default, the inspection does not report `switch` statements if all cases for enums or `sealed` classes are covered.\nUse the **Ignore exhaustive switch statements** option if you want to change this behavior."
        },
        {
          "shortName": "LabeledStatement",
          "displayName": "Labeled statement",
          "enabled": false,
          "description": "Reports labeled statements that can complicate refactorings and control flow of the method.\n\nExample:\n\n\n      label:\n      while (true) {\n          // code\n      }\n"
        },
        {
          "shortName": "LoopStatementsThatDontLoop",
          "displayName": "Loop statement that does not loop",
          "enabled": true,
          "description": "Reports any instance of `for`, `while`, and `do` statements whose bodies will be executed once at most. Normally, this is an indication of a bug.\n\n\nUse the **Ignore enhanced for loops** option to ignore the foreach loops.\nThey are sometimes used to perform an action only on the first item of an iterable in a compact way.\n\nExample:\n\n\n      for (String s : stringIterable) {\n        doSomethingOnFirstString(s);\n        break;\n      }\n"
        },
        {
          "shortName": "ForLoopReplaceableByWhile",
          "displayName": "'for' loop may be replaced by 'while' loop",
          "enabled": false,
          "description": "Reports `for` loops that contain neither initialization nor update components, and suggests converting them to `while` loops. This makes the code easier to read.\n\nExample:\n\n\n      for(; exitCondition(); ) {\n        process();\n      }\n\nAfter the quick-fix is applied:\n\n\n      while(exitCondition()) {\n        process();\n      }\n\nThe quick-fix is also available for other `for` loops, so you can replace any `for` loop with a\n`while` loop.\n\nUse the **Ignore 'infinite' for loops without conditions** option if you want to ignore `for`\nloops with trivial or non-existent conditions."
        },
        {
          "shortName": "ConfusingElse",
          "displayName": "Redundant 'else'",
          "enabled": false,
          "description": "Reports redundant `else` keywords in `if`---`else` statements and statement chains.\n\n\nThe `else` keyword is redundant when it cannot be reached because the code in previous branches ends with the\n`return`, `throw`, `break`, or `continue` statement. In this case,\nthe statements from the `else` branch can be placed after the `if` statement, and the\n`else` keyword can be removed.\n\nExample:\n\n\n      if (name == null) {\n          throw new IllegalArgumentException();\n      } else {\n          System.out.println(name);\n      }\n\nAfter the quick-fix is applied:\n\n\n      if (name == null) {\n          throw new IllegalArgumentException();\n      }\n      System.out.println(name);\n\nDisable the **Report when there are no more statements after the 'if' statement** option to ignore the cases in which the `if`---`else` statement is the last statement in a code block."
        },
        {
          "shortName": "IfCanBeAssertion",
          "displayName": "Statement can be replaced with 'assert' or 'Objects.requireNonNull'",
          "enabled": true,
          "description": "Reports `if` statements that throw only `java.lang.Throwable` from a `then` branch and do not have an `else` branch. Such statements can be converted to more compact `assert` statements.\n\n\nThe inspection also reports Guava's `Preconditions.checkNotNull()`.\nThey can be replaced with a `Objects.requireNonNull()` call for which a library may not be needed.\n\nExample:\n\n\n      if (x == 2) throw new RuntimeException(\"fail\");\n      if (y == null) throw new AssertionError();\n      Preconditions.checkNotNull(z, \"z\");\n\nAfter the quick-fix is applied:\n\n\n      assert x != 2 : \"fail\";\n      Objects.requireNonNull(y);\n      Objects.requireNonNull(z, \"z\");\n\nBy default, this inspection provides a quick-fix in the editor without code highlighting."
        },
        {
          "shortName": "BreakStatementWithLabel",
          "displayName": "'break' statement with label",
          "enabled": false,
          "description": "Reports `break` statements with labels.\n\nLabeled `break` statements complicate refactoring and can be confusing.\n\nExample:\n\n\n      void handle(List<String> strs) {\n        outer:\n        for (String s: strs) {\n          for (char ch : s.toCharArray()) {\n            if ('s' == ch) break outer;\n            handleChar(ch);\n          }\n        }\n      }\n"
        },
        {
          "shortName": "PointlessIndexOfComparison",
          "displayName": "Pointless 'indexOf()' comparison",
          "enabled": false,
          "description": "Reports unnecessary comparisons with `.indexOf()` expressions. An example of such an expression is comparing the result of `.indexOf()` with numbers smaller than -1."
        },
        {
          "shortName": "SwitchStatementWithConfusingDeclaration",
          "displayName": "Local variable used and declared in different 'switch' branches",
          "enabled": true,
          "description": "Reports local variables declared in one branch of a `switch` statement and used in another branch. Such declarations can be extremely confusing.\n\nExample:\n\n\n        switch(i) {\n          case 2:\n              int x = 0;\n              break;\n          case 3:\n              x = 3;\n              System.out.println(x);\n              break;\n        }\n"
        },
        {
          "shortName": "ForLoopWithMissingComponent",
          "displayName": "'for' loop with missing components",
          "enabled": false,
          "description": "Reports `for` loops that lack initialization, condition, or update clauses. Some coding styles prohibit such loops.\n\nExample:\n\n\n      for (int i = 0;;i++) {\n        // body\n      }\n\n\nUse the **Ignore collection iterations** option to ignore loops which use an iterator.\nThis is a standard way to iterate over a collection in which the `for` loop does not have an update clause."
        },
        {
          "shortName": "EnumSwitchStatementWhichMissesCases",
          "displayName": "Enum 'switch' statement that misses case",
          "enabled": true,
          "description": "Reports `switch` statements over enumerated types that are not exhaustive.\n\n**Example:**\n\n\n      enum AlphaBetaGamma {\n        A, B, C;\n\n        void x(AlphaBetaGamma e) {\n          switch (e) {\n\n          }\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      enum AlphaBetaGamma {\n        A, B, C;\n\n        void x(AlphaBetaGamma e) {\n          switch (e) {\n            case A -> {}\n            case B -> {}\n            case C -> {}\n          }\n        }\n      }\n\n\nUse the **Ignore switch statements with a default branch** option to ignore `switch`\nstatements that have a `default` branch."
        },
        {
          "shortName": "SimplifiableConditionalExpression",
          "displayName": "Simplifiable conditional expression",
          "enabled": true,
          "description": "Reports conditional expressions and suggests simplifying them.\n\nExamples:\n\n    condition ? true : foo  condition || foo\n\n    condition ? false : foo  !condition && foo\n\n    condition ? foo : !foo  condition == foo\n\n    condition ? true : false  condition\n\n    a == b ? b : a  a\n\n    result != null ? result : null  result\n"
        },
        {
          "shortName": "IfStatementWithTooManyBranches",
          "displayName": "'if' statement with too many branches",
          "enabled": false,
          "description": "Reports `if` statements with too many branches.\n\nSuch statements may be confusing and are often a sign of inadequate levels of design\nabstraction.\n\n\nUse the **Maximum number of branches** field to specify the maximum number of branches an `if` statement is allowed to have."
        },
        {
          "shortName": "SwitchStatementWithTooFewBranches",
          "displayName": "Minimum 'switch' branches",
          "enabled": false,
          "description": "Reports `switch` statements and expressions with too few `case` labels, and suggests rewriting them as `if` and `else if` statements.\n\nExample (minimum branches == 3):\n\n\n      switch (expression) {\n        case \"foo\" -> foo();\n        case \"bar\" -> bar();\n      }\n\nAfter the quick-fix is applied:\n\n\n      if (\"foo\".equals(expression)) {\n        foo();\n      } else if (\"bar\".equals(expression)) {\n        bar();\n      }\n\nConfigure the inspection:\n\nUse the **Minimum number of branches** field to specify the minimum expected number of `case` labels.\n\nUse the **Do not report pattern switch statements** option to avoid reporting switch statements and expressions that\nhave pattern branches. E.g.:\n\n\n      String result = switch(obj) {\n        case String str -> str.trim();\n        default -> \"none\";\n      };\n\nIt might be preferred to keep the switch even with a single pattern branch, rather than using the `instanceof` statement."
        },
        {
          "shortName": "NegatedIfElse",
          "displayName": "'if' statement with negated condition",
          "enabled": false,
          "description": "Reports `if` statements that contain `else` branches and whose conditions are negated.\n\nFlipping the order of the `if` and `else`\nbranches usually increases the clarity of such statements.\n\nThere is a fix that inverts the current `if` statement.\n\nExample:\n\n\n        void m(Object o1, Object o2) {\n            if (o1 != o2) {\n                System.out.println(1);\n            }\n            else {\n                System.out.println(2);\n            }\n        }\n\nAfter applying the quick-fix:\n\n\n        void m(Object o1, Object o2) {\n            if (o1 == o2) {\n                System.out.println(2);\n            } else {\n                System.out.println(1);\n            }\n        }\n\nUse the **Ignore '!= null' comparisons** option to ignore comparisons of the `!= null` form.\n\nUse the **Ignore '!= 0' comparisons** option to ignore comparisons of the `!= 0` form."
        },
        {
          "shortName": "GroovyTrivialIf",
          "displayName": "Redundant 'if' statement",
          "enabled": false,
          "description": "Reports `if` statements which can be simplified to single assignment or `return` statements.\n\n**Example:**\n\n\n      if (foo())\n        return true;\n      else\n        return false;\n\nAfter the quick-fix is applied:\n\n\n      return foo();\n"
        },
        {
          "shortName": "GroovyFallthrough",
          "displayName": "Fallthrough in 'switch' statement",
          "enabled": false,
          "description": "Reports *fallthrough* in switch statements. While occasionally useful, fallthrough is often unintended, and may lead to surprising bugs.\n\n**Example:**\n\n\n    switch(n) {\n      case 1:\n        print 1\n      case 2: // \"case 1\" fallthrough to \"case 2\". Statements from \"case 2\" will be executed immediately after \"case 1\".\n        print 2\n        break\n      default:\n        print \"Default\"\n    }\n\n"
        },
        {
          "shortName": "GroovyIfStatementWithIdenticalBranches",
          "displayName": "If statement with identical branches",
          "enabled": false,
          "description": "Reports `if` statements with identical \"then\" and `else` branches. Such statements are almost certainly programmer error.\n\n**Example:**\n\n\n    if (condition) {\n      print \"foo\"\n    } else {\n      print \"foo\"\n    }\n\nAfter the quick-fix is applied:\n\n\n    print \"foo\"\n\n"
        },
        {
          "shortName": "GroovyTrivialConditional",
          "displayName": "Redundant conditional expression",
          "enabled": false,
          "description": "Reports ternary conditional operators of the form `x ? true : false` or similar, which can be trivially simplified.\n\n**Example:**\n\n\n      foo() ? true : false\n\nAfter the quick-fix is applied:\n\n\n    foo()\n"
        },
        {
          "shortName": "GrFinalVariableAccess",
          "displayName": "Final variable access",
          "enabled": false,
          "description": "Reports uninitialized final fields, invalid assignments to final variables, and parameters and fields."
        },
        {
          "shortName": "GroovyBreak",
          "displayName": "'break' statement",
          "enabled": false,
          "description": "Reports `break` statements outside of `switch` statements."
        },
        {
          "shortName": "GroovyConstantConditional",
          "displayName": "Constant conditional expression",
          "enabled": false,
          "description": "Reports conditional expressions with boolean constant as a condition.\n\n**Example:**\n\n\n      true ? result1 : result2\n      false ? result1 : result2\n"
        },
        {
          "shortName": "GroovyContinue",
          "displayName": "'continue' statement",
          "enabled": false,
          "description": "Reports `continue` statements."
        },
        {
          "shortName": "GroovySwitchStatementWithNoDefault",
          "displayName": "Switch statement with no default case",
          "enabled": false,
          "description": "Reports `switch` statements that do not contain `default` labels.\n\n\nSome coding practices may insist on adding this label to all `switch` statements."
        },
        {
          "shortName": "GroovyUnnecessaryReturn",
          "displayName": "Unnecessary 'return' statement",
          "enabled": false,
          "description": "Reports `return` statements at the end of constructors and methods returning\n`void`. These are unnecessary and may be safely removed.\n\n**Example:**\n\n\n      void foo (String s){\n          print(s)\n          return\n      }\n\nAfter the quick-fix is applied:\n\n\n      void foo (String s){\n          print(s)\n      }\n\nFor more information, see the same inspection in Java."
        },
        {
          "shortName": "GroovyConditionalWithIdenticalBranches",
          "displayName": "Ternary expression with identical branches",
          "enabled": false,
          "description": "Reports ternary expressions with identical \"then\" and \"else\" branches. Such expressions are almost certainly a programmer error.\n\nThe quick-fix replaces the expression with its \"then\" branch.\n\n**Example:**\n\n\n      condition ? a.foo() : a.foo()\n\nAfter the quick-fix is applied:\n\n\n      a.foo()\n"
        },
        {
          "shortName": "GroovyConditionalCanBeElvis",
          "displayName": "Ternary expression can be replaced with elvis expression",
          "enabled": false,
          "description": "Reports ternary expressions which can be replaced by an elvis expression.\n\n**Example:**\n\n\n      def notNull(o, defaultValue) {\n          o != null ? o : defaultValue\n      }\n\nAfter the quick-fix is applied:\n\n\n      def notNull(o, defaultValue) {\n          o ?: defaultValue\n      }\n"
        },
        {
          "shortName": "GroovyConstantIfStatement",
          "displayName": "Constant if statement",
          "enabled": false,
          "description": "Reports `if` statements with boolean constant as a condition.\n\n**Example:**\n\n\n      if (true) {\n          // ...\n      }\n      if (false) {\n          // ...\n      }\n"
        },
        {
          "shortName": "GroovyIfStatementWithTooManyBranches",
          "displayName": "If statement with too many branches",
          "enabled": false,
          "description": "Reports `if` statements with too many branches. Such statements may be confusing, and are often the sign of inadequate levels of design abstraction.\n\n**Example:**\n\n\n    if (a) {\n      print \"foo\"\n    } else if (b) {\n      print \"bar\"\n    } else if (c) {\n      print \"baz\"\n    } else if (d) {\n      print \"Too many branches\"\n    }\n\n\nUse the **Maximum number of branches** field to specify the maximum number of branches expected."
        },
        {
          "shortName": "GroovyConditionalCanBeConditionalCall",
          "displayName": "Ternary expression can be replaced with safe call",
          "enabled": false,
          "description": "Reports ternary expressions which can be replaced by a safe call.\n\n**Example:**\n\n\n      def charArray(String s) {\n          s == null ? null : s.toCharArray()\n      }\n\nAfter the quick-fix is applied:\n\n\n      def charArray(String s) {\n          s?.toCharArray()\n      }\n"
        },
        {
          "shortName": "GroovyUnnecessaryContinue",
          "displayName": "Unnecessary 'continue' statement",
          "enabled": false,
          "description": "Reports `continue` statements if they are last reachable statements in the loop.\nThese `continue` statements are unnecessary and can be safely removed.\n\n**Example:**\n\n\n      for(int i in array) {\n          println(i)\n          continue\n      }\n\nAfter the quick-fix is applied:\n\n\n      for(int i in array) {\n          println(i)\n      }\n\nFor more information, see the same inspection in Java."
        },
        {
          "shortName": "GroovyLoopStatementThatDoesntLoop",
          "displayName": "Loop statement that doesn't loop",
          "enabled": false,
          "description": "Reports `for` or `while` statements whose bodies are guaranteed to execute at most once. While such statements could be written intentionally, they are usually a symptom of error.\n\n**Example:**\n\n\n      for (int i in 0..<10) {\n        return\n      }\n\n"
        },
        {
          "shortName": "GroovyReturnFromClosureCanBeImplicit",
          "displayName": "'return' statement can be implicit",
          "enabled": false,
          "description": "Reports return statements at the end of closures which can be made implicit.\n\n\nGroovy closures implicitly return the value of the last statement in them.\n\n**Example:**\n\n\n      def foo = {\n        return 1\n      }\n\nAfter the quick-fix is applied:\n\n\n      def foo = {\n        1\n      }\n"
        }
      ]
    },
    {
      "name": "Numeric issues",
      "inspections": [
        {
          "shortName": "RemoveLiteralUnderscores",
          "displayName": "Underscores in numeric literal",
          "enabled": false,
          "description": "Reports numeric literals with underscores and suggests removing them with a quick-fix. This may be useful if you need to lower the language level.\n\nThe quick-fix removes underscores from numeric literals. For example `1_000_000` will be converted to `1000000`.\n\nThis inspection only reports if the language level of the project or module is 7 or higher.\n\nNew in 2020.2"
        },
        {
          "shortName": "BadOddness",
          "displayName": "Suspicious oddness check",
          "enabled": false,
          "description": "Reports odd-even checks of the following form: `x % 2 == 1`. Such checks fail when used with negative odd values. Consider using `x % 2 != 0` or `(x & 1) == 1` instead."
        },
        {
          "shortName": "ComparisonOfShortAndChar",
          "displayName": "Comparison of 'short' and 'char' values",
          "enabled": true,
          "description": "Reports equality comparisons between `short` and `char` values.\n\nSuch comparisons may cause subtle bugs because while both values are 2-byte long, `short` values are\nsigned, and `char` values are unsigned.\n\n**Example:**\n\n\n    if (Character.MAX_VALUE == shortValue()) {} //never can be true\n"
        },
        {
          "shortName": "InsertLiteralUnderscores",
          "displayName": "Unreadable numeric literal",
          "enabled": true,
          "description": "Reports long numeric literals without underscores and suggests adding them. Underscores make such literals easier to read.\n\nExample:\n\n\n      1000000\n\nAfter the quick-fix is applied:\n\n\n      1_000_000\n\nThis inspection only reports if the language level of the project of module is 7 or higher.\n\nNew in 2020.2"
        },
        {
          "shortName": "DivideByZero",
          "displayName": "Division by zero",
          "enabled": true,
          "description": "Reports division by zero or remainder by zero. Such expressions will produce an `Infinity`, `-Infinity` or `NaN` result for doubles or floats, and will throw an `ArithmeticException` for integers.\n\nWhen the expression has a `NaN` result, the fix suggests replacing the division expression with the `NaN` constant."
        },
        {
          "shortName": "ComparisonToNaN",
          "displayName": "Comparison to 'Double.NaN' or 'Float.NaN'",
          "enabled": true,
          "description": "Reports any comparisons to `Double.NaN` or `Float.NaN`. Such comparisons are never meaningful, as NaN is not equal to anything, including itself. Use the `Double.isNaN()` or `Float.isNaN()` methods instead.\n\n**Example:**\n\n\n      if (x == Double.NaN) {...}\n\nAfter the quick-fix is applied:\n\n\n      if (Double.isNaN(x)) {...}\n"
        },
        {
          "shortName": "ConfusingFloatingPointLiteral",
          "displayName": "Confusing floating point literal",
          "enabled": false,
          "description": "Reports any floating point numbers that don't have a decimal point, numbers before the decimal point, or numbers after the decimal point.\n\nSuch literals may be confusing, and violate several coding standards.\n\n**Example:**\n\n    double d = .03;\n\nAfter the quick-fix is applied:\n\n    double d = 0.03;\n\n\nUse the **Ignore floating point literals in scientific notation** option to ignore floating point numbers in scientific notation."
        },
        {
          "shortName": "UnaryPlus",
          "displayName": "Unary plus",
          "enabled": true,
          "description": "Reports usages of the `+` unary operator. The unary plus is usually a null operation, and its presence might represent a coding error. For example, in a combination with the increment operator (like in `+++`) or with the equal operator (like in `=+`).\n\n**Example:**\n\n\n      void unaryPlus(int i) {\n        int x = + +i;\n      }\n\nThe following quick fixes are suggested:\n\n* Remove `+` operators before the `i` variable:\n\n\n        void unaryPlus(int i) {\n          int x = i;\n        }\n\n* Replace `+` operators with the prefix increment operator:\n\n\n        void unaryPlus(int i) {\n          int x = ++i;\n        }\n\n\nUse the checkbox below to report unary pluses that are used together with a binary or another unary expression.\nIt means the inspection will not report situations when a unary plus expression is used in array\ninitializer expressions or as a method argument."
        },
        {
          "shortName": "OctalAndDecimalIntegersMixed",
          "displayName": "Octal and decimal integers in same array",
          "enabled": false,
          "description": "Reports mixed octal and decimal integer literals in a single array initializer. This situation might happen when you copy a list of numbers into an array initializer. Some numbers in the array might be zero-padded and the compiler will interpret them as octal.\n\n**Example:**\n\n    int[] elapsed = {1, 13, 052};\n\nAfter the quick-fix that removes a leading zero is applied:\n\n    int[] elapsed = {1, 13, 52};\n\nIf it is an octal number (for example, after a variable inline), then you can use another quick-fix that converts octal to decimal:\n`int[] elapsed = {1, 13, 42};`"
        },
        {
          "shortName": "UnnecessaryUnaryMinus",
          "displayName": "Unnecessary unary minus",
          "enabled": true,
          "description": "Reports unnecessary unary minuses. Such expressions might be hard to understand and might contain errors.\n\n**For example:**\n\n    void unaryMinus(int i) {\n        int x = - -i;\n      }\n\nThe following quick fixes are suggested here:\n\n* Remove `-` operators before the `i` variable:\n\n      void unaryMinus(int i) {\n          int x = i;\n        }\n\n* Replace `-` operators with the prefix decrement operator:\n\n      void unaryMinus(int i) {\n          int x = --i;\n        }\n\n**Another example:**\n\n    void unaryMinus(int i) {\n        i += - 8;\n      }\n\nAfter the quick-fix is applied:\n\n    void unaryMinus(int i) {\n        i -= 8;\n      }\n"
        },
        {
          "shortName": "CachedNumberConstructorCall",
          "displayName": "Number constructor call with primitive argument",
          "enabled": true,
          "description": "Reports instantiations of new `Long`, `Integer`, `Short`, or `Byte` objects that have a primitive `long`, `integer`, `short`, or `byte` argument.\n\nIt is recommended that you use the static method `valueOf()`\nintroduced in Java 5. By default, this method caches objects for values between -128 and\n127 inclusive.\n\n**Example:**\n\n\n      Integer i = new Integer(1);\n      Long l = new Long(1L);\n\nAfter the quick-fix is applied, the code changes to:\n\n\n      Integer i = Integer.valueOf(1);\n      Long l = Long.valueOf(1L);\n\nThis inspection only reports if the language level of the project or module is 5 or higher\n\n\nUse the **Ignore new number expressions with a String argument** option to ignore calls to number constructors with a `String` argument.\n\n\nUse the **Report only when constructor is @Deprecated** option to only report calls to deprecated constructors.\n`Long`, `Integer`, `Short` and `Byte` constructors are deprecated since JDK 9."
        },
        {
          "shortName": "PointlessArithmeticExpression",
          "displayName": "Pointless arithmetic expression",
          "enabled": true,
          "description": "Reports pointless arithmetic expressions. Such expressions include adding or subtracting zero, multiplying by zero or one, and division by one.\n\nSuch expressions may be the result of automated refactorings and they are unlikely to be what the developer intended to do.\n\nThe quick-fix simplifies such expressions.\n\n**Example:**\n\n\n      void f(int a) {\n        int x = a - a;\n        int y = a + 0;\n        int res = x / x;\n      }\n\nAfter the quick-fix is applied:\n\n\n      void f(int a) {\n        int x = 0;\n        int y = a;\n        int res = 1;\n      }\n\n\nNote that in rare cases, the suggested replacement might not be completely equivalent to the original code\nfor all possible inputs. For example, the inspection suggests replacing `x / x` with `1`.\nHowever, if `x` is zero, the original code throws `ArithmeticException` or results in `NaN`.\nAlso, if `x` is `NaN`, then the result is also `NaN`. It's very unlikely that such behavior is intended."
        },
        {
          "shortName": "CharUsedInArithmeticContext",
          "displayName": "'char' expression used in arithmetic context",
          "enabled": false,
          "description": "Reports expressions of the `char` type used in addition or subtraction expressions.\n\nSuch code is not necessarily an issue but may result in bugs (for example,\nif a string is expected).\n\n**Example:** `int a = 'a' + 42;`\n\nAfter the quick-fix is applied: `int a = (int) 'a' + 42;`\n\nFor the `String` context:\n\n    int i1 = 1;\n    int i2 = 2;\n    System.out.println(i2 + '-' + i1 + \" = \" + (i2 - i1));\n\nAfter the quick-fix is applied:\n`System.out.println(i2 + \"-\" + i1 + \" = \" + (i2 - i1));`"
        },
        {
          "shortName": "UnpredictableBigDecimalConstructorCall",
          "displayName": "Unpredictable 'BigDecimal' constructor call",
          "enabled": true,
          "description": "Reports calls to `BigDecimal` constructors that accept a `double` value. These constructors produce `BigDecimal` that is exactly equal to the supplied `double` value. However, because doubles are encoded in the IEEE 754 64-bit double-precision binary floating-point format, the exact value can be unexpected.\n\nFor example, `new BigDecimal(0.1)` yields a `BigDecimal` object. Its value is\n`0.1000000000000000055511151231257827021181583404541015625`\nwhich is the nearest number to 0.1 representable as a double.\nTo get `BigDecimal` that stores the same value as written in the source code,\nuse either `new BigDecimal(\"0.1\")` or `BigDecimal.valueOf(0.1)`.\n\n**Example:**\n\n\n      class Constructor {\n        void foo() {\n          new BigDecimal(0.1);\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      class Constructor {\n        void foo() {\n          new BigDecimal(\"0.1\");\n        }\n      }\n"
        },
        {
          "shortName": "IntegerDivisionInFloatingPointContext",
          "displayName": "Integer division in floating point context",
          "enabled": true,
          "description": "Reports integer divisions where the result is used as a floating-point number. Such division is often an error and may have unexpected results due to the truncation that happens in integer division.\n\n**Example:**\n\n\n      float x = 3.0F + 3/5;\n"
        },
        {
          "shortName": "ImplicitNumericConversion",
          "displayName": "Implicit numeric conversion",
          "enabled": false,
          "description": "Reports implicit conversion between numeric types.\n\nImplicit numeric conversion is not a problem in itself but, if unexpected, may cause difficulties when tracing bugs.\n\n**Example:**\n\n\n      double m(int i) {\n        return i * 10;\n      }\n\nAfter the quick-fix is applied:\n\n\n      double m(int i) {\n        return (double) (i * 10);\n      }\n\nConfigure the inspection:\n\n* Use the **Ignore widening conversions** option to ignore implicit conversion that cannot result in data loss (for example, `int`-\\>`long`).\n* Use the **Ignore conversions from and to 'char'** option to ignore conversion from and to `char`. The inspection will still report conversion from and to floating-point numbers.\n* Use the **Ignore conversion from constants and literals** to make the inspection ignore conversion from literals and compile-time constants."
        },
        {
          "shortName": "BigDecimalEquals",
          "displayName": "'equals()' called on 'BigDecimal'",
          "enabled": false,
          "description": "Reports `.equals()` being called to compare two `java.math.BigDecimal` numbers.\n\nThis is normally a mistake, as two `java.math.BigDecimal` numbers are only equal if\nthey are equal in both value and scale.\n\n**Example:**\n\n    if (new BigDecimal(\"2.0\").equals(new BigDecimal(\"2.00\"))) {}\n\nAfter the quick-fix is applied:\n\n    if (new BigDecimal(\"2.0\").compareTo(new BigDecimal(\"2.00\")) == 0) {}\n"
        },
        {
          "shortName": "OctalLiteral",
          "displayName": "Octal integer",
          "enabled": true,
          "description": "Reports octal integer literals. Some coding standards prohibit the use of octal literals, as they may be easily confused with decimal literals.\n\nExample:\n\n\n      int i = 015;\n      int j = 0_777;\n\nThis inspection has two different quick-fixes.\nAfter the **Convert octal literal to decimal literal** quick-fix is applied, the code changes to:\n\n\n      int i = 13;\n      int j = 511;\n\nAfter the **Remove leading zero to make decimal** quick-fix is applied, the code changes to:\n\n\n      int i = 15;\n      int j = 777;\n"
        },
        {
          "shortName": "ConstantMathCall",
          "displayName": "Constant call to 'Math'",
          "enabled": false,
          "description": "Reports calls to `java.lang.Math` or `java.lang.StrictMath` methods that can be determined as simple compile-time constants.\n\n**Example:**\n\n    double v = Math.sin(0.0);\n\nAfter the quick-fix is applied:\n\n    double v = 0.0;\n"
        },
        {
          "shortName": "NumericOverflow",
          "displayName": "Numeric overflow",
          "enabled": true,
          "description": "Reports expressions that overflow during computation. Usually, this happens by accident and indicates a bug. For example, a wrong type is used or a shift should be done in an opposite direction .\n\n**Examples:**\n\n\n      float a = 1.0f/0.0f;\n      long b = 30 * 24 * 60 * 60 * 1000;\n      long c = 1000L << 62;\n"
        },
        {
          "shortName": "NonReproducibleMathCall",
          "displayName": "Non-reproducible call to 'Math'",
          "enabled": false,
          "description": "Reports calls to `java.lang.Math` methods, which results are not guaranteed to be reproduced precisely.\n\nIn environments where reproducibility of results is required, `java.lang.StrictMath`\nshould be used instead."
        },
        {
          "shortName": "FloatingPointEquality",
          "displayName": "Floating point equality comparison",
          "enabled": false,
          "description": "Reports floating-point values that are being compared using the `==` or `!=` operator.\n\nFloating-point values are inherently inaccurate, and comparing them for exact equality is seldom the desired semantics.\n\nThis inspection ignores comparisons with zero and infinity literals.\n\n**Example:**\n\n\n      void m(double d1, double d2) {\n        if (d1 == d2) {}\n      }\n"
        },
        {
          "shortName": "SuspiciousLiteralUnderscore",
          "displayName": "Suspicious underscore in number literal",
          "enabled": false,
          "description": "Reports decimal number literals that use the underscore numeric separator with groups where the number of digits is not three. Such literals may contain a typo.\n\nThis inspection will not warn on literals containing two consecutive underscores.\nIt is also allowed to omit underscores in the fractional part of `double` and `float` literals.\n\n**Example:** `int oneMillion = 1_000_0000;`"
        },
        {
          "shortName": "LongLiteralsEndingWithLowercaseL",
          "displayName": "'long' literal ending with 'l' instead of 'L'",
          "enabled": true,
          "description": "Reports `long` literals ending with lowercase 'l'. These literals may be confusing, as lowercase 'l' looks very similar to '1'.\n\nThe quick-fix for this inspection replaces lowercase 'l' with uppercase 'L'."
        },
        {
          "shortName": "BigDecimalMethodWithoutRoundingCalled",
          "displayName": "Call to 'BigDecimal' method without a rounding mode argument",
          "enabled": true,
          "description": "Reports calls to `divide()` or `setScale()` without a rounding mode argument.\n\nSuch calls can lead to an `ArithmeticException` when the exact value cannot be represented in the result\n(for example, because it has a non-terminating decimal expansion).\n\nSpecifying a rounding mode prevents the `ArithmeticException`.\n\n**Example:**\n\n\n      BigDecimal.valueOf(1).divide(BigDecimal.valueOf(3));\n"
        },
        {
          "shortName": "OverlyComplexArithmeticExpression",
          "displayName": "Overly complex arithmetic expression",
          "enabled": false,
          "description": "Reports arithmetic expressions with the excessive number of terms. Such expressions might be hard to understand and might contain errors.\n\nParameters, field references, and other primary expressions are counted as a term.\n\n**Example:**\n\n    int calc(int a, int b) {\n            return a + a + a + b + b + b + b; // The line contains 7 terms and will be reported.\n        }\n\nUse the field below to specify a number of terms allowed in arithmetic expressions."
        }
      ]
    },
    {
      "name": "Initialization",
      "inspections": [
        {
          "shortName": "DoubleBraceInitialization",
          "displayName": "Double brace initialization",
          "enabled": true,
          "description": "Reports [Double Brace Initialization](https://www.c2.com/cgi/wiki?DoubleBraceInitialization).\n\nDouble brace initialization may cause memory leaks when used in a non-static context because it creates an anonymous class\nthat will reference the surrounding object.\n\nCompared to regular initialization, double brace initialization provides worse performance since it requires loading an\nadditional class.\n\nIt may also cause failure of `equals()` comparisons if the `equals()` method doesn't accept subclasses as\nparameters.\n\nIn addition, before Java 9, double brace initialization couldn't be combined with the diamond operator since it was incompatible\nwith anonymous classes.\n\n**Example:**\n\n\n      List<Integer> list = new ArrayList<>() {{\n        add(1);\n        add(2);\n      }};\n\nAfter the quick-fix is applied:\n\n\n      List<Integer> list = new ArrayList<>();\n      list.add(1);\n      list.add(2);\n"
        },
        {
          "shortName": "NonFinalStaticVariableUsedInClassInitialization",
          "displayName": "Non-final static field is used during class initialization",
          "enabled": false,
          "description": "Reports the use of non-`final` `static` variables during class initialization.\n\nIn such cases, the code semantics may become dependent on the class creation order. Additionally, such cases may lead to the use of\nvariables before their initialization, and generally cause difficult and confusing bugs.\n\n**Example:**\n\n\n      class Foo {\n        public static int bar = 0;\n\n        static {\n          System.out.println(bar);\n        }\n      }\n"
        },
        {
          "shortName": "NonThreadSafeLazyInitialization",
          "displayName": "Unsafe lazy initialization of 'static' field",
          "enabled": false,
          "description": "Reports `static` variables that are lazily initialized in a non-thread-safe manner.\n\nLazy initialization of `static` variables should be done with an appropriate synchronization construct\nto prevent different threads from performing conflicting initialization.\n\nWhen applicable, a quick-fix, which introduces the\n[lazy initialization holder class idiom](https://en.wikipedia.org/wiki/Initialization_on_demand_holder_idiom), is suggested.\nThis idiom makes use of the fact that the JVM guarantees that a class will not be initialized until it is used.\n\n**Example:**\n\n\n      class X {\n        private static List<String> list;\n\n        public List<String> getList() {\n          if (list == null) {\n            list = List.of(\"one\", \"two\", \"tree\");\n          }\n          return list;\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      class X {\n        private static final class ListHolder {\n          static final List<String> list = List.of(\"one\", \"two\", \"tree\");\n        }\n\n        public List<String> getList() {\n          return ListHolder.list;\n        }\n      }\n"
        },
        {
          "shortName": "StaticVariableInitialization",
          "displayName": "Static field may not be initialized",
          "enabled": false,
          "description": "Reports `static` variables that may be uninitialized upon class initialization.\n\n**Example:**\n\n\n      class Foo {\n        public static int bar;\n\n        static { }\n      }\n\nNote that this inspection uses a very conservative dataflow algorithm and may incorrectly report `static` variables as uninitialized. Variables\nreported as initialized will always be initialized.\n\nUse the **Ignore primitive fields** option to ignore uninitialized primitive fields."
        },
        {
          "shortName": "OverridableMethodCallDuringObjectConstruction",
          "displayName": "Overridable method called during object construction",
          "enabled": false,
          "description": "Reports calls to overridable methods of the current class during object construction.\n\nA method is called during object construction if it is inside a:\n\n* Constructor\n* Non-static instance initializer\n* Non-static field initializer\n* `clone()` method\n* `readObject()` method\n* `readObjectNoData()` method\n* Methods are overridable if they are not declared as `final`, `static`, or `private`. Package-local methods are considered safe, even though they are overridable. Such calls may result in subtle bugs, as object initialization may happen before the method call.\n* **Example:**\n\n\n      class Parent {\n        void someMethod() { }\n      }\n\n      class Child extends Parent {\n        Child() {\n          someMethod();\n        }\n      }\n\n* This inspection shares the functionality with the following inspections:\n  * Abstract method called during object construction\n  * Overridden method called during object construction\n* Only one inspection should be enabled at once to prevent warning duplication."
        },
        {
          "shortName": "InstanceVariableUninitializedUse",
          "displayName": "Instance field used before initialization",
          "enabled": false,
          "description": "Reports instance variables that are read before initialization.\n\nThe inspection ignores equality checks with `null`.\n\n**Example:**\n\n\n      class Foo {\n        int bar;\n\n        Foo() {\n          System.out.println(bar);\n        }\n      }\n\nNote that this inspection uses a very conservative dataflow algorithm and may incorrectly report instance variables as uninitialized. Variables\nreported as initialized will always be initialized.\n\nUse the **Ignore if annotated by** option to specify special annotations. The inspection will ignore fields\nannotated with one of these annotations.\n\nUse the **Ignore primitive fields** option to ignore uninitialized primitive fields."
        },
        {
          "shortName": "AbstractMethodCallInConstructor",
          "displayName": "Abstract method called during object construction",
          "enabled": false,
          "description": "Reports calls to `abstract` methods of the current class during object construction.\n\nA method is called during object construction if it is inside a:\n\n* Constructor\n* Non-static instance initializer\n* Non-static field initializer\n* `clone()` method\n* `readObject()` method\n* `readObjectNoData()` method\n\nSuch calls may result in subtle bugs, as object initialization may happen before the method call.\n\n**Example:**\n\n\n      abstract class Parent {\n        abstract void abstractMethod();\n      }\n\n      class Child extends Parent {\n        Child() {\n          abstractMethod();\n        }\n      }\n\nThis inspection shares the functionality with the following inspections:\n\n* Overridable method called during object construction\n* Overridden method called during object construction\n\nOnly one inspection should be enabled at once to prevent warning duplication."
        },
        {
          "shortName": "StaticVariableUninitializedUse",
          "displayName": "Static field used before initialization",
          "enabled": false,
          "description": "Reports `static` variables that are read before initialization.\n\nThe inspection ignores equality checks with `null`.\n\n**Example:**\n\n\n      class Foo {\n        public static int bar;\n\n        public static void main(String[] args) {\n          System.out.println(bar);\n        }\n      }\n\nNote that this inspection uses a very conservative dataflow algorithm and may incorrectly report `static` variables as uninitialized. Variables\nreported as initialized will always be initialized.\n\nUse the **Ignore primitive fields** option to ignore uninitialized primitive fields."
        },
        {
          "shortName": "OverriddenMethodCallDuringObjectConstruction",
          "displayName": "Overridden method called during object construction",
          "enabled": false,
          "description": "Reports any calls to overridden methods of the current class during object construction. This happens if an object construction is inside:\n\n* A constructor\n* A non-static instance initializer\n* A non-static field initializer\n* `clone()`\n* `readObject()`\n* `readObjectNoData()`\n\nSuch calls may result in subtle bugs, as the object is not guaranteed to be initialized before the method call occurs.\n\nExample:\n\n\n      abstract class Parent {\n        void someMethod() { }\n      }\n\n      class Child extends Parent {\n        Child() {\n          someMethod();\n        }\n\n        @Override\n        void someMethod() { }\n      }\n\nThis inspection shares its functionality with:\n\n* The **Abstract method called during object construction** inspection\n* The **Overridable method called during object construction** inspection\n\nOnly one inspection should be enabled at the same time to prevent duplicate warnings."
        },
        {
          "shortName": "InstanceVariableInitialization",
          "displayName": "Instance field may not be initialized",
          "enabled": false,
          "description": "Reports instance variables that may be uninitialized upon object initialization.\n\n**Example:**\n\n\n      class Foo {\n        public int bar;\n\n        static { }\n      }\n\nNote that this inspection uses a very conservative dataflow algorithm and may incorrectly report instance variables as uninitialized. Variables\nreported as initialized will always be initialized.\n\nUse the **Ignore primitive fields** option to ignore uninitialized primitive fields."
        },
        {
          "shortName": "ThisEscapedInConstructor",
          "displayName": "'this' reference escaped in object construction",
          "enabled": false,
          "description": "Reports possible escapes of `this` during the object initialization. The escapes occur when `this` is used as a method argument or an object of assignment in a constructor or initializer. Such escapes may result in subtle bugs, as the object is now available in the context where it is not guaranteed to be initialized.\n\n**Example:**\n\n\n      class Foo {\n        {\n          System.out.println(this);\n        }\n      }\n"
        }
      ]
    },
    {
      "name": "HTML",
      "inspections": [
        {
          "shortName": "HtmlUnknownBooleanAttribute",
          "displayName": "Incorrect boolean attribute",
          "enabled": false,
          "description": "Reports an HTML non-boolean attribute without a value. Suggests configuring attributes that should not be reported."
        },
        {
          "shortName": "HtmlUnknownTarget",
          "displayName": "Unresolved file in a link",
          "enabled": false,
          "description": "Reports an unresolved file in a link."
        },
        {
          "shortName": "HtmlUnknownAttribute",
          "displayName": "Unknown attribute",
          "enabled": false,
          "description": "Reports an unknown HTML attribute. Suggests configuring attributes that should not be reported."
        },
        {
          "shortName": "HtmlExtraClosingTag",
          "displayName": "Redundant closing tag",
          "enabled": false,
          "description": "Reports redundant closing tags on empty elements, for example, `img` or `br`.\n\n**Example:**\n\n\n      <html>\n        <body>\n          <br></br>\n        </body>\n      </html>\n\nAfter the quick-fix is applied:\n\n\n      <html>\n        <body>\n          <br>\n        </body>\n      </html>\n"
        },
        {
          "shortName": "HtmlUnknownTag",
          "displayName": "Unknown tag",
          "enabled": false,
          "description": "Reports an unknown HTML tag. Suggests configuring tags that should not be reported."
        },
        {
          "shortName": "RequiredAttributes",
          "displayName": "Missing required attribute",
          "enabled": false,
          "description": "Reports a missing mandatory attribute in an XML/HTML tag. Suggests configuring attributes that should not be reported."
        },
        {
          "shortName": "CheckValidXmlInScriptTagBody",
          "displayName": "Malformed content of 'script' tag",
          "enabled": false,
          "description": "Reports contents of `script` tags that are invalid XML.  \n\n**Example:**\n\n\n      <script type=\"text/javascript\">\n        console.log('<');\n      </script>\n\nAfter the quick-fix is applied:\n\n\n      <script type=\"text/javascript\">\n        console.log('&lt;');\n      </script>\n"
        },
        {
          "shortName": "HtmlMissingClosingTag",
          "displayName": "Missing closing tag",
          "enabled": false,
          "description": "Reports an HTML element without a closing tag. Some coding styles require that HTML elements have closing tags even where this is optional.\n\n**Example:**\n\n\n      <html>\n        <body>\n          <p>Behold!\n        </body>\n      </html>\n\nAfter the quick-fix is applied:\n\n\n      <html>\n        <body>\n          <p>Behold!</p>\n        </body>\n      </html>\n"
        },
        {
          "shortName": "HtmlUnknownAnchorTarget",
          "displayName": "Unresolved fragment in a link",
          "enabled": false,
          "description": "Reports an unresolved last part of an URL after the `#` sign."
        },
        {
          "shortName": "CheckEmptyScriptTag",
          "displayName": "Empty tag",
          "enabled": false,
          "description": "Reports empty tags that do not work in some browsers.\n\n**Example:**\n\n\n      <html>\n        <script/>\n      </html>\n\nAfter the quick-fix is applied:\n\n\n      <html>\n        <script></script>\n      </html>\n"
        }
      ]
    },
    {
      "name": "Security",
      "inspections": [
        {
          "shortName": "CloneableClassInSecureContext",
          "displayName": "Cloneable class in secure context",
          "enabled": false,
          "description": "Reports classes which may be cloned.\n\n\nA class\nmay be cloned if it supports the `Cloneable` interface,\nand its `clone()` method is not defined to immediately\nthrow an error. Cloneable classes may be dangerous in code intended for secure use.\n\n**Example:**\n`class SecureBean implements Cloneable {}`\n\nAfter the quick-fix is applied:\n`class SecureBean {}`\n\n\nWhen the class extends an existing cloneable class or implements a cloneable interface,\nthen after the quick-fix is applied, the code may look like:\n\n    class SecureBean extends ParentBean {\n        @Override\n        protected SecureBean clone() throws CloneNotSupportedException {\n            throw new CloneNotSupportedException();\n        }\n    }\n"
        },
        {
          "shortName": "JDBCExecuteWithNonConstantString",
          "displayName": "Call to 'Statement.execute()' with non-constant string",
          "enabled": false,
          "description": "Reports calls to `java.sql.Statement.execute()` or any of its variants which take a dynamically-constructed string as the query to execute.\n\nConstructed SQL statements are a common source of security breaches.\nBy default, this inspection ignores compile-time constants.\n\n**Example:**\n\n\n      ResultSet execute(Statement statement, String name) throws SQLException {\n        return statement.executeQuery(\"select * from \" + name); // reports warning\n      }\n\n\nUse the inspection options to consider any `static` `final` fields as constant.\nBe careful, because strings like the following will be ignored when the option is enabled:\n\n\n      private static final String SQL = \"SELECT * FROM user WHERE name='\" + getUserInput() + \"'\";\n"
        },
        {
          "shortName": "SerializableDeserializableClassInSecureContext",
          "displayName": "Serializable class in secure context",
          "enabled": false,
          "description": "Reports classes that may be serialized or deserialized.\n\n\nA class may be serialized if it supports the `Serializable` interface,\nand its `readObject()` and `writeObject()` methods are not defined to always\nthrow an exception. Serializable classes may be dangerous in code intended for secure use.\n\n**Example:**\n\n\n      class DeserializableClass implements Serializable { // the class doesn't contain 'writeObject()' method throwing an exception\n        private int sensitive = 736326;\n\n        private void readObject(ObjectInputStream in) {\n            throw new Error();\n        }\n    }\n\nAfter the quick-fix is applied:\n\n\n      class DeserializableClass implements Serializable {\n        private int sensitive = 736326;\n\n        private void readObject(ObjectInputStream in) {\n            throw new Error();\n        }\n\n        private void writeObject(java.io.ObjectOutputStream out) throws java.io.IOException {\n            throw new java.io.NotSerializableException(\"DeserializableClass\");\n        }\n      }\n\n\nUse the following options to configure the inspection:\n\n* List classes whose inheritors should not be reported by this inspection. This is meant for classes that inherit `Serializable` from a superclass but are not intended for serialization. Note that it still may be more secure to add `readObject()` and `writeObject()` methods which always throw an exception, instead of ignoring those classes.\n* Whether to ignore serializable anonymous classes."
        },
        {
          "shortName": "NonFinalClone",
          "displayName": "Non-final 'clone()' in secure context",
          "enabled": false,
          "description": "Reports `clone()` methods without the `final` modifier.\n\n\nSince `clone()` can be used to instantiate objects without using a constructor, allowing the `clone()`\nmethod to be overridden may result in corrupted objects, and even in security exploits. This may be prevented by making the\n`clone()` method or the enclosing class itself `final`.\n\n**Example:**\n\n\n      class Main implements Cloneable {\n        @Override\n        protected Object clone() throws CloneNotSupportedException {\n          return super.clone();\n        }\n      }\n"
        },
        {
          "shortName": "PublicStaticCollectionField",
          "displayName": "'public static' collection field",
          "enabled": false,
          "description": "Reports modifiable `public` `static` Collection fields.\n\nEven though they are often used to store collections of constant values, these fields nonetheless represent a security\nhazard, as their contents may be modified even if the field is declared as `final`.\n\n**Example:**\n\n\n      public static final List<String> EVENTS = new ArrayList<>();\n      \n\nUse the table in the **Options** section to specify methods returning unmodifiable collections.\n`public` `static` collection fields initialized with these methods will not be reported."
        },
        {
          "shortName": "JDBCPrepareStatementWithNonConstantString",
          "displayName": "Call to 'Connection.prepare*()' with non-constant string",
          "enabled": false,
          "description": "Reports calls to `java.sql.Connection.prepareStatement()`, `java.sql.Connection.prepareCall()`, or any of their variants which take a dynamically-constructed string as the statement to prepare.\n\n\nConstructed SQL statements are a common source of\nsecurity breaches. By default, this inspection ignores compile-time constants.\n\n**Example:**\n\n\n      String bar() { return \"bar\"; }\n\n      Connection connection = DriverManager.getConnection(\"\", \"\", \"\");\n      connection.(\"SELECT * FROM user WHERE name='\" + bar() + \"'\");\n\nUse the inspection settings to consider any `static` `final` fields as constants. Be careful, because strings like the following will be ignored when the option is enabled:\n\n\n      static final String SQL = \"SELECT * FROM user WHERE name='\" + getUserInput() + \"'\";\n"
        },
        {
          "shortName": "SystemProperties",
          "displayName": "Access of system properties",
          "enabled": false,
          "description": "Reports code that accesses system properties using one of the following methods:\n\n* `System.getProperties()`, `System.setProperty()`, `System.setProperties()`, `System.clearProperties()`\n* `Integer.getInteger()`\n* `Boolean.getBoolean()`\n\n\nWhile accessing the system properties is not a security risk in itself, it is often found in malicious code.\nCode that accesses system properties should be closely examined in any security audit."
        },
        {
          "shortName": "UnsecureRandomNumberGeneration",
          "displayName": "Insecure random number generation",
          "enabled": false,
          "description": "Reports any uses of `java.lang.Random` or `java.lang.Math.random()`.\n\n\nIn secure environments,\n`java.secure.SecureRandom` is a better choice, since is offers cryptographically secure\nrandom number generation.\n\n**Example:**\n\n\n      long token = new Random().nextLong();\n"
        },
        {
          "shortName": "CustomSecurityManager",
          "displayName": "Custom 'SecurityManager'",
          "enabled": false,
          "description": "Reports user-defined subclasses of `java.lang.SecurityManager`.\n\n\nWhile not necessarily representing a security hole, such classes should be thoroughly\nand professionally inspected for possible security issues.\n\n**Example:**\n\n\n      class CustomSecurityManager extends SecurityManager {\n      }\n"
        },
        {
          "shortName": "ClassLoaderInstantiation",
          "displayName": "'ClassLoader' instantiation",
          "enabled": false,
          "description": "Reports instantiations of the `java.lang.ClassLoader` class.\n\nWhile often benign, any instantiations of `ClassLoader` should be closely examined in any security audit.\n\n**Example:**\n\n        Class<?> loadExtraClass(String name) throws Exception {\n          try(URLClassLoader loader =\n              new URLClassLoader(new URL[]{new URL(\"extraClasses/\")})) {\n            return loader.loadClass(name);\n          }\n        }\n      \n"
        },
        {
          "shortName": "DesignForExtension",
          "displayName": "Design for extension",
          "enabled": false,
          "description": "Reports methods which are not `static`, `private`, `final` or `abstract`, and whose bodies are not empty.\n\n\nCoding in a style that avoids such methods protects the contracts of classes from being broken by their subclasses. The\nbenefit of this style is that subclasses cannot corrupt the state of the superclass by forgetting to call the super method. The cost is\nthat\nsubclasses are limited in their flexibility, in particular they cannot prevent execution of code in the superclass. Use the quick-fix to\nadd\nthe missing modifiers.\n\n**Example:**\n\n\n      class Foo {\n        public boolean equals(Object o) { return true; }\n      }\n\nAfter the quick-fix is applied:\n\n\n      class Foo {\n        public final boolean equals(Object o) { return true; }\n      }\n\nThis inspection is intended for code that is going to be used in secure environments, and is probably not appropriate for less restrictive environments."
        },
        {
          "shortName": "LoadLibraryWithNonConstantString",
          "displayName": "Call to 'System.loadLibrary()' with non-constant string",
          "enabled": false,
          "description": "Reports calls to `java.lang.System.loadLibrary()`, `java.lang.System.load()`, `java.lang.Runtime.loadLibrary()` and `java.lang.Runtime.load()` which take a dynamically-constructed string as the name of the library.\n\n\nConstructed library name strings are a common source of security breaches.\nBy default, this inspection ignores compile-time constants.\n\n**Example:**\n\n\n      void test(int i) {\n        System.loadLibrary(\"foo\" + i);\n      }\n\n\nUse the inspection settings to consider any `static final` fields as constant.\nBe careful, because strings like the following will be ignored when the option is enabled:\n\n\n      private static final String LIBRARY = getUserInput();\n"
        },
        {
          "shortName": "RuntimeExecWithNonConstantString",
          "displayName": "Call to 'Runtime.exec()' with non-constant string",
          "enabled": false,
          "description": "Reports calls to `java.lang.Runtime.exec()` which take a dynamically-constructed string as the command to execute.\n\n\nConstructed execution strings are a common source of security breaches.\nBy default, this inspection ignores compile-time constants.\n\n**Example:**\n\n\n      String i = getUserInput();\n      Runtime runtime = Runtime.getRuntime();\n      runtime.exec(\"foo\" + i); // reports warning\n\n\nUse the inspection settings to consider any `static` `final` fields as constant.\nBe careful, because strings like the following will be ignored when the option is enabled:\n\n\n      static final String COMMAND = \"ping \" + getDomainFromUserInput() + \"'\";\n"
        },
        {
          "shortName": "SystemSetSecurityManager",
          "displayName": "Call to 'System.setSecurityManager()'",
          "enabled": false,
          "description": "Reports calls to `System.setSecurityManager()`.\n\nWhile often benign, any call to `System.setSecurityManager()` should be closely examined in any security audit."
        },
        {
          "shortName": "PublicStaticArrayField",
          "displayName": "'public static' array field",
          "enabled": false,
          "description": "Reports `public` `static` array fields.\n\n\nSuch fields are often used to store arrays of constant values. Still, they represent a security\nhazard, as their contents may be modified, even if the field is declared `final`.\n\n**Example:**\n\n\n      public static String[] allowedPasswords = {\"foo\", \"bar\"};\n"
        },
        {
          "shortName": "CustomClassloader",
          "displayName": "Custom 'ClassLoader' is declared",
          "enabled": false,
          "description": "Reports user-defined subclasses of `java.lang.ClassLoader`.\n\n\nWhile not necessarily representing a security hole, such classes should be thoroughly\ninspected for possible security issues."
        }
      ]
    },
    {
      "name": "Properties files",
      "inspections": [
        {
          "shortName": "UnusedMessageFormatParameter",
          "displayName": "Missing message format parameter",
          "enabled": false,
          "description": "Reports properties values that look like `java.text.MessageFormat` format strings but do not use some the parameters of the `{xx}` kind.\n\nExample:\n\n\n    # parameter {0} is not used\n    error.message=Something happened in line {1}\n      \n"
        },
        {
          "shortName": "InconsistentResourceBundle",
          "displayName": "Inconsistent resource bundle",
          "enabled": false,
          "description": "Reports problems in the properties files contained in the resource bundle.\n\n* **Report missing translation**\n\noption controls search for an untranslated properties.   \nIt reports properties contained in parent properties file that are missing in inherited (unless it's a language dialect).   \nE.g. having this resource bundle:   \n**messages.properties** : **abc=xxx**   \n**messages_fr.properties** : empty   \nProperty **abc** will be reported as untranslated.\n\n* **Report inconsistent properties**\n\noption controls invalid resource bundle structure inspection.   \nIt reports properties contained in inherited properties file that are missing in parent (or in sibling if there is no parent).   \nE.g. having this resource bundle:   \n**messages.properties** : empty   \n**messages_fr.properties** : **abc=xxx**   \nProperty **abc** translation here is not available for any language except French, and, thus, will be reported as missing in the (default) properties file **messages.properties** .\n\n* **Report properties overridden with the same value**\n\noption checks for properties which are copy-pasted into several properties files verbatim.   \nE.g. in this resource bundle:   \n**messages.properties** : **abc=xxx**   \n**messages_fr.properties** : **abc=xxx**   \nProperty **abc** will be reported as unnecessarily inherited in the file **messages_fr.properties** .   \n\n* **Report properties overridden with different placeholders**\n\noption checks for properties which are overridden for placeholder consistency.   \nE.g. in this resource bundle:   \n**messages.properties** :   \n**qwe={0}xxx{1}**   \n**abc={0}yyy{1}**   \n**messages_fr.properties** :   \n**qwe={0}xxx{0}xxx{1}**   \n**abc={0}yyy**   \nProperty **abc** will be reported as property contains message format placeholders with value not corresponding to **messages.properties** .   \n\n* **Report properties overridden with different values endings**\n\noption checks for properties which are overridden for ending consistency.   \nE.g. in this resource bundle:   \n**messages.properties** :   \n**abc=xxxzzz**   \n**messages_fr.properties** :   \n**abc=xxx;**   \nProperty **abc** will be reported as property contains special signs ( **'!'** , **'?'** , **'.'** , **':'** or **';'** ) at the end of value but value in **messages.properties** doesn't.   "
        },
        {
          "shortName": "SuspiciousLocalesLanguages",
          "displayName": "Suspicious resource bundle locale languages",
          "enabled": false,
          "description": "Reports locales with language codes that are not supported by Java."
        },
        {
          "shortName": "UseEllipsisInPropertyInspection",
          "displayName": "Three dot characters instead of the ellipsis",
          "enabled": false,
          "description": "Reports three \"dot\" characters which are used instead of the ellipsis character for UTF-8 properties files."
        },
        {
          "shortName": "AlphaUnsortedPropertiesFile",
          "displayName": "Properties file or resource bundle is alphabetically unsorted",
          "enabled": false,
          "description": "Reports alphabetically unsorted resource bundles or .properties files."
        },
        {
          "shortName": "TrailingSpacesInProperty",
          "displayName": "Trailing spaces in property",
          "enabled": false,
          "description": "Reports all properties whose keys or values end with a whitespace.   "
        },
        {
          "shortName": "UnusedProperty",
          "displayName": "Unused property",
          "enabled": false,
          "description": "Reports all properties that are not referenced from the outside of the .properties file."
        },
        {
          "shortName": "WrongPropertyKeyValueDelimiter",
          "displayName": "Property key/value delimiter doesn't match code style settings",
          "enabled": false,
          "description": "Reports properties in which key or value delimiters do not match code style settings."
        },
        {
          "shortName": "DuplicatePropertyInspection",
          "displayName": "Duplicate property",
          "enabled": false,
          "description": "Reports duplicate property keys with different values, duplicate keys, or duplicate property values.\n\nExample:\n\n\n    property1=value;\n    property2=value;\n\nThe **Options** list allows selecting the area in which the inspection should search for duplicates."
        },
        {
          "shortName": "UnresolvedPropertyKey",
          "displayName": "Invalid property key",
          "enabled": true,
          "description": "Reports invalid arguments that are passed to methods with parameters annotated as `@PropertyKey`.\n\nThese arguments should be valid property keys in corresponding properties files.\nAlso, the inspection verifies that the `resourceBundle`\nargument of the `@PropertyKey` annotation is an existing resource bundle.\n\n\nUse the quick-fix to create a new property or to select an existing one.\n\nExample:\n\n\n      @PropertyKey(resourceBundle = \"myBundle\") String value = \"invalid.key\";\n"
        }
      ]
    },
    {
      "name": "EditorConfig",
      "inspections": [
        {
          "shortName": "EditorConfigRootDeclarationUniqueness",
          "displayName": "Extra top-level declaration",
          "enabled": false,
          "description": "Reports multiple top-level declarations. There can be only one optional \"root=true\" top-level declaration in the EditorConfig file. Using multiple top-level declarations is not allowed."
        },
        {
          "shortName": "EditorConfigNumerousWildcards",
          "displayName": "Too many wildcards",
          "enabled": false,
          "description": "Reports sections that contain too many wildcards. Using a lot of wildcards may lead to performance issues."
        },
        {
          "shortName": "EditorConfigKeyCorrectness",
          "displayName": "Unknown property",
          "enabled": false,
          "description": "Reports properties that are not supported by the IDE. Note: some \"ij\" domain properties may require specific language plugins."
        },
        {
          "shortName": "EditorConfigEncoding",
          "displayName": "File encoding doesn't match EditorConfig charset",
          "enabled": false,
          "description": "Checks that current file encoding matches the encoding defined in \"charset\" property of .editorconfig file."
        },
        {
          "shortName": "EditorConfigRootDeclarationCorrectness",
          "displayName": "Unexpected top-level declaration",
          "enabled": false,
          "description": "Reports unexpected top-level declarations. Top-level declarations other than \"root=true\" are not allowed in the EditorConfig file."
        },
        {
          "shortName": "EditorConfigPatternRedundancy",
          "displayName": "Duplicate or redundant pattern",
          "enabled": false,
          "description": "Reports file patterns that are redundant as there already are other patterns that define the same scope of files or even a broader one. For example, in `[{*.java,*}]` the first `*.java` pattern defines a narrower scope compared to `*`. That is why it is redundant and can be removed."
        },
        {
          "shortName": "EditorConfigDeprecatedDescriptor",
          "displayName": "Deprecated property",
          "enabled": false,
          "description": "Reports EditorConfig properties that are no longer supported."
        },
        {
          "shortName": "EditorConfigShadowedOption",
          "displayName": "Overridden property",
          "enabled": false,
          "description": "Reports properties that are already defined in other sections.\n\nFor example:\n\n\n    [*.java]\n    indent_size=4\n    [{*.java,*.js}]\n    indent_size=2\n\nThe second section includes all `*.java` files too but it also redefines indent_size. As a result the value 2 will be used for files matching `*.java`."
        },
        {
          "shortName": "EditorConfigEmptyHeader",
          "displayName": "Empty header",
          "enabled": false,
          "description": "Reports sections with an empty header. Section header must contain file path globs in the format similar to one supported by `gitignore`."
        },
        {
          "shortName": "EditorConfigValueUniqueness",
          "displayName": "Non-unique list value",
          "enabled": false,
          "description": "Reports duplicates in lists of values."
        },
        {
          "shortName": "EditorConfigMissingRequiredDeclaration",
          "displayName": "Required declarations are missing",
          "enabled": false,
          "description": "Reports properties that miss the required declarations. Refer to the documentation for more information."
        },
        {
          "shortName": "EditorConfigSpaceInHeader",
          "displayName": "Space in file pattern",
          "enabled": false,
          "description": "Reports space characters in wildcard patterns that affect pattern matching. If these characters are not intentional, they should be removed."
        },
        {
          "shortName": "EditorConfigOptionRedundancy",
          "displayName": "Redundant property",
          "enabled": false,
          "description": "Reports properties that are redundant when another applicable section already contains the same property and value.\n\n\nFor example:\n\n\n    [*]\n    indent_size=4\n    [*.java]\n    indent_size=4\n\nare both applicable to `*.java` files and define the same `indent_size` value."
        },
        {
          "shortName": "EditorConfigUnexpectedComma",
          "displayName": "Unexpected comma",
          "enabled": false,
          "description": "Reports commas that cannot be used in the current context. Commas are allowed only as separators for values in lists."
        },
        {
          "shortName": "EditorConfigCharClassRedundancy",
          "displayName": "Unnecessary character class",
          "enabled": false,
          "description": "Reports character classes that consist of a single character. Such classes can be simplified to a character, for example `[a]``a`."
        },
        {
          "shortName": "EditorConfigPartialOverride",
          "displayName": "Overlapping sections",
          "enabled": false,
          "description": "Reports subsets of files specified in the current section that overlap with other subsets in other sections. For example: `[{foo,bar}]` and `[{foo,bas}]` both contain \"foo\"."
        },
        {
          "shortName": "EditorConfigEmptySection",
          "displayName": "Empty section",
          "enabled": false,
          "description": "Reports sections that do not contain any EditorConfig properties."
        },
        {
          "shortName": "EditorConfigShadowingOption",
          "displayName": "Overriding property",
          "enabled": false,
          "description": "Reports properties that override the same properties defined earlier in the file.\n\nFor example:\n\n\n    [*.java]\n    indent_size=4\n    [{*.java,*.js}]\n    indent_size=2\n\nThe second section includes the same files as `[*.java]` but also sets indent_size to value 2. Thus the first declaration `indent_size=4`will be ignored."
        },
        {
          "shortName": "EditorConfigListAcceptability",
          "displayName": "Unexpected value list",
          "enabled": false,
          "description": "Reports lists of values that are used in properties in which lists are not supported. In this case, only a single value can be specified."
        },
        {
          "shortName": "EditorConfigPatternEnumerationRedundancy",
          "displayName": "Unnecessary braces",
          "enabled": false,
          "description": "Reports pattern lists that are either empty `{}` or contain just one pattern, for example `{foo}`. The braces are needed only if there are two and more, for example: `{foo,bar}`"
        },
        {
          "shortName": "EditorConfigReferenceCorrectness",
          "displayName": "Invalid reference",
          "enabled": false,
          "description": "Reports identifiers that are either unknown or have a wrong type."
        },
        {
          "shortName": "EditorConfigPairAcceptability",
          "displayName": "Unexpected key-value pair",
          "enabled": false,
          "description": "Reports key-value pairs that are not allowed in the current context."
        },
        {
          "shortName": "EditorConfigNoMatchingFiles",
          "displayName": "No matching files",
          "enabled": false,
          "description": "Reports sections with wildcard patterns that do not match any files under the directory in which the `.editorconfig` file is located."
        },
        {
          "shortName": "EditorConfigWildcardRedundancy",
          "displayName": "Redundant wildcard",
          "enabled": false,
          "description": "Reports wildcards that become redundant when the \"\\*\\*\" wildcard is used in the same section.\n\n\nThe \"\\*\\*\" wildcard defines a broader set of files than any other wildcard.\nThat is why, any other wildcard used in the same section has no affect and can be removed."
        },
        {
          "shortName": "EditorConfigHeaderUniqueness",
          "displayName": "EditorConfig section is not unique",
          "enabled": false,
          "description": "Reports sections that define the same file pattern as other sections."
        },
        {
          "shortName": "EditorConfigValueCorrectness",
          "displayName": "Invalid property value",
          "enabled": false,
          "description": "Reports property values that do not meet value restrictions. For example, some properties may be only \"true\" or \"false\", others contain only integer numbers etc. If a value has a limited set of variants, use code completion to see all of them."
        },
        {
          "shortName": "EditorConfigCharClassLetterRedundancy",
          "displayName": "Duplicate character class letter",
          "enabled": false,
          "description": "Reports wildcard patterns in the EditorConfig section that contain a duplicate character in the character class, for example `[aa]`."
        },
        {
          "shortName": "EditorConfigUnusedDeclaration",
          "displayName": "Unused declaration",
          "enabled": false,
          "description": "Reports unused declarations. Such declarations can be removed."
        }
      ]
    },
    {
      "name": "Java language level migration aids",
      "inspections": [
        {
          "shortName": "UseCompareMethod",
          "displayName": "'compare()' method can be used to compare numbers",
          "enabled": false,
          "description": "Reports cases where the static `Integer.compare()` method or similar methods can be used instead of more verbose or less efficient constructs.\n\nIf `x` and `y` are already boxed integers, then `x.compareTo(y)` is suggested.\n\n**Example:**\n\n\n      public int compare(int x, int y) {\n        return x > y ? 1 : x < y ? -1 : 0;\n      }\n\nAfter the quick-fix is applied:\n\n\n      public int compare(int x, int y) {\n        return Integer.compare(x, y);\n      }\n\n\nNote that `Double.compare` and `Float.compare` slightly change the code semantics. In particular,\nthey make `-0.0` and `0.0` distinguishable (`Double.compare(-0.0, 0.0)` yields -1).\nAlso, they consistently process `NaN` value. In most of the cases, this semantics change actually improves the\ncode. Use the checkbox to disable this inspection for floating point numbers if semantics change is unacceptable\nin your case.\n\nNew in 2017.2"
        },
        {
          "shortName": "EnumerationCanBeIteration",
          "displayName": "Enumeration can be iteration",
          "enabled": false,
          "description": "Reports calls to `Enumeration` methods that are used on collections and may be replaced with equivalent `Iterator` constructs.\n\n**Example:**\n\n    Enumeration<String> keys = map.keys();\n      while (keys.hasMoreElements()) {\n        String name = keys.nextElement();\n      }\n\nAfter the quick-fix is applied:\n\n    Iterator<String> iterator = map.keySet().iterator();\n      while (iterator.hasNext()) {\n        String name = iterator.next();\n      }\n"
        },
        {
          "shortName": "IfCanBeSwitch",
          "displayName": "'if' can be replaced with 'switch'",
          "enabled": false,
          "description": "Reports `if` statements that can be replaced with `switch` statements.\n\nThe replacement result is usually shorter and clearer.\n\n**Example:**\n\n\n      void test(String str) {\n        if (str.equals(\"1\")) {\n          System.out.println(1);\n        } else if (str.equals(\"2\")) {\n          System.out.println(2);\n        } else if (str.equals(\"3\")) {\n          System.out.println(3);\n        } else {\n          System.out.println(4);\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      void test(String str) {\n        switch (str) {\n          case \"1\" -> System.out.println(1);\n          case \"2\" -> System.out.println(2);\n          case \"3\" -> System.out.println(3);\n          default -> System.out.println(4);\n        }\n      }\n      \nThis inspection only reports if the language level of the project or module is 7 or higher.\n\nUse the **Minimum number of 'if' condition branches** field to specify the minimum number of `if` condition branches\nfor an `if` statement to have to be reported. Note that the terminal `else` branch (without `if`) is not counted.\n\n\nUse the **Suggest switch on numbers** option to enable the suggestion of `switch` statements on\nprimitive and boxed numbers and characters.\n\n\nUse the **Suggest switch on enums** option to enable the suggestion of `switch` statements on\n`enum` constants.\n\n\nUse the **Only suggest on null-safe expressions** option to suggest `switch` statements that can't introduce a `NullPointerException` only."
        }
      ]
    },
    {
      "name": "Java 15",
      "inspections": [
        {
          "shortName": "InconsistentTextBlockIndent",
          "displayName": "Inconsistent whitespace indentation in text block",
          "enabled": false,
          "description": "Reports text blocks that are indented using both spaces and tabs.\n\nSuch cases produce unexpected results since spaces and tabs are treated equally during text block processing.\n\nIn the following example, spaces and tabs are visualized as `` and `` respectively, and a tab is equal to 4 spaces in the editor.\n\n**Example:**\n\n\n    String colors = \"\"\"\n    red\n          green\n    blue\"\"\";\n\nAfter printing such string, the result will be:\n\n\n    red\n    green\n    blue\n\nAfter the compiler removes 2 spaces or tabs from the beginning of each line, the lines end up with extra whitespaces at the beginning.\n\nThis inspection only reports if the configured language level is 15 or higher.\n\nNew in 2021.1"
        },
        {
          "shortName": "TextBlockMigration",
          "displayName": "Text block can be used",
          "enabled": false,
          "description": "Reports `String` literals and suggests replacing them with text blocks.\n\nRequirements:\n\n* `\\n` occurs two or more times.\n* Text blocks are not concatenated.\n\n\nUse the **Apply to single string literals** option to suggest the fix for single literals containing line breaks.\n\n\n**Example:**\n\n\n      String html = \"<html>\\n\" +\n                    \"    <body>\\n\" +\n                    \"        <p>Hello, world</p>\\n\" +\n                    \"    </body>\\n\" +\n                    \"</html>\\n\";\n\nAfter the quick-fix is applied:\n\n\n      String html = \"\"\"\n                    <html>\n                        <body>\n                            <p>Hello, world</p>\n                        </body>\n                    </html>\n                    \"\"\";\n\nThis inspection only reports if the language level of the project or module is 15 or higher.\n\nNew in 2019.3"
        },
        {
          "shortName": "PatternVariableCanBeUsed",
          "displayName": "Pattern variable can be used",
          "enabled": false,
          "description": "Reports local variable declarations that can be replaced with pattern variables, which are usually more compact.\n\n**Example:**\n\n\n      if (obj instanceof String) {\n        String str = (String) obj;\n        System.out.println(str);\n      }\n\nCan be replaced with:\n\n\n      if (obj instanceof String str) {\n        System.out.println(str);\n      }\n\nThis inspection only reports if the language level of the project or module is 16 or higher\n\nNew in 2020.1"
        },
        {
          "shortName": "TrailingWhitespacesInTextBlock",
          "displayName": "Trailing whitespaces in text block",
          "enabled": false,
          "description": "Reports text blocks with trailing whitespaces.\n\nTrailing whitespaces are considered incidental and stripped away by the Java compiler.\n\nThis inspection only reports if the language level of the project or module is 15 or higher.\n\nNew in 2021.1"
        },
        {
          "shortName": "TextBlockBackwardMigration",
          "displayName": "Text block can be replaced with regular string literal",
          "enabled": false,
          "description": "Reports text blocks that can be replaced with regular string literals.\n\nOccurrences of such text blocks may appear as results of migrating the code back to a Java version earlier than Java 15.\n\n**Example:**\n\n\n      Object obj = engine.eval(\"\"\"\n                               function hello() {\n                                 print('\"Hello, world\"');\n                               }\n\n                               hello();\n                               \"\"\");\n\nAfter the quick fix is applied:\n\n\n      Object obj = engine.eval(\"function hello() {\\n\" +\n                               \"  print('\\\"Hello, world\\\"');\\n\" +\n                               \"}\\n\" +\n                               \"\\n\" +\n                               \"hello();\\n\");\n\nThis inspection only reports if the language level of the project or module is 15 or higher.\n\nNew in 2019.3"
        },
        {
          "shortName": "ClassCanBeRecord",
          "displayName": "Class can be a record",
          "enabled": false,
          "description": "Suggests replacing classes with records.\n\nThe inspection can be useful if you need to focus on modeling immutable data rather than extensible behavior.\nAutomatic implementation of data-driven methods, such as equals and accessors, helps to get rid of boilerplate.\n\n\nNote that not every class can be a record. Here are some of the restrictions:\n\n* A class must contain no inheritors and must be a top-level class.\n* All the non-static fields in class must be final.\n* Class must contain no instance initializers, generic constructors, nor native methods.\n\nTo get a full list of the restrictions, refer to the\n[Oracle documentation](https://docs.oracle.com/javase/specs/jls/se15/preview/specs/records-jls.html).\n\nExample:\n\n\n      class Point {\n        private final double x;\n        private final double y;\n\n        Point(double x, double y) {\n          this.x = x;\n          this.y = y;\n        }\n\n        double getX() {\n          return x;\n        }\n\n        double getY() {\n          return y;\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      record Point(int x, int y) {\n      }\n\nEnable the **Suggest renaming get/is-accessors** option to allow renaming `getX()`/`isX()` accessors to `x()` automatically.\n\n\nUse the **When conversion makes a member more accessible** options to specify if the conversion may violate class encapsulation:\n\n* Choose **Do not suggest conversion** option to never violate class encapsulation\n* Choose **Show affected members in conflicts view** option to apply conversion with notification about encapsulation violation issues\n* Choose **Convert silently** option to apply conversion silently whether encapsulation violation issues exist or not\n\nUse the **Suppress conversion if class is annotated by** list to exclude classes from conversion when annotated by annotations matching the specified patterns.\n\nThis inspection only reports if the language level of the project or module is 16 or higher.\n\nNew in 2020.3"
        }
      ]
    },
    {
      "name": "JavaBeans issues",
      "inspections": [
        {
          "shortName": "SuspiciousGetterSetter",
          "displayName": "Suspicious getter/setter",
          "enabled": false,
          "description": "Reports getter or setter methods that access a field that is not expected by its name. For example, when `getY()` returns the `x` field. Usually, it might be a copy-paste error.\n\n**Example:**\n\n    class Point {\n        private int x;\n        private int y;\n\n        public void setX(int x) { // Warning: setter 'setX()' assigns field 'y'\n          this.y = x;\n        }\n\n        public int getY() { // Warning: getter 'getY()' returns field 'x'\n          return x;\n        }\n      }\n\n\nUse the checkbox below to report situations when a field in the class has a name that matches a name of a getter or a setter."
        },
        {
          "shortName": "PropertyValueSetToItself",
          "displayName": "Property value set to itself",
          "enabled": false,
          "description": "Reports calls of setter methods with the same object getter as a value. Usually, this code does nothing and probably was not intended.\n\n**For example:**\n\n    bean.setPayerId(bean.getPayerId());\n"
        },
        {
          "shortName": "ClassWithoutConstructor",
          "displayName": "Class without constructor",
          "enabled": false,
          "description": "Reports classes without constructors.\n\nSome coding standards prohibit such classes."
        },
        {
          "shortName": "FieldHasSetterButNoGetter",
          "displayName": "Field has setter but no getter",
          "enabled": false,
          "description": "Reports fields that have setter methods but no getter methods.\n\n\nIn certain bean containers, when used within the Java beans specification, such fields might be difficult\nto work with."
        },
        {
          "shortName": "ClassWithoutNoArgConstructor",
          "displayName": "Class without no-arg constructor",
          "enabled": false,
          "description": "Reports classes without a constructor that takes no arguments. No-argument constructors are necessary in some contexts. For example, if a class needs to be created using reflection.\n\n\nUse the checkbox below to ignore classes without explicit constructors.\nThe compiler provides a default no-argument constructor to such classes."
        }
      ]
    },
    {
      "name": "Assignment issues",
      "inspections": [
        {
          "shortName": "AssignmentToNull",
          "displayName": "'null' assignment",
          "enabled": false,
          "description": "Reports variables that are assigned to `null` outside a declaration.\n\nThe main purpose of `null` in Java is to denote uninitialized\nreference variables. In rare cases, assigning a variable explicitly to `null`\nis useful to aid garbage collection. However, using `null` to denote a missing, not specified, or invalid value or a not\nfound element is considered bad practice and may make your code more prone to `NullPointerExceptions`.\nInstead, consider defining a sentinel object with the intended semantics\nor use library types like `Optional` to denote the absence of a value.\n\n**Example:**\n\n\n      Integer convert(String s) {\n        Integer value;\n        try {\n          value = Integer.parseInt(s);\n        } catch (NumberFormatException e) {\n          // Warning: null is used to denote an 'invalid value'\n          value = null;\n        }\n        return value;\n      }\n\n\nUse the **Ignore assignments to fields** option to ignore assignments to fields."
        },
        {
          "shortName": "AssignmentToForLoopParameter",
          "displayName": "Assignment to 'for' loop parameter",
          "enabled": true,
          "description": "Reports assignment to, or modification of a `for` loop parameter inside the body of the loop.\n\nAlthough occasionally intended, this construct may be confusing and is often the result of a typo or a wrong variable being used.\n\nThe quick-fix adds a declaration of a new variable.\n\n**Example:**\n\n\n      for (String s : list) {\n        // Warning: s is changed inside the loop\n        s = s.trim();\n        System.out.println(\"String: \" + s);\n      }\n\nAfter the quick-fix is applied:\n\n\n      for (String s : list) {\n        String trimmed = s.trim();\n        System.out.println(\"String: \" + trimmed);\n      }\n\nAssignments in basic `for` loops without an update statement are not reported.\nIn such cases the assignment is probably intended and can't be easily moved to the update part of the `for` loop.\n\n**Example:**\n\n\n      for (int i = 0; i < list.size(); ) {\n        if (element.equals(list.get(i))) {\n          list.remove(i);\n        } else {\n          // modification of for loop parameter is not reported\n          // as there's no update statement\n          i++;\n        }\n      }\n\nUse the **Check enhanced 'for' loop parameters** option to specify whether modifications of enhanced `for` loop parameters\nshould be also reported."
        },
        {
          "shortName": "NestedAssignment",
          "displayName": "Nested assignment",
          "enabled": false,
          "description": "Reports assignment expressions that are nested inside other expressions.\n\nSuch expressions may be confusing and violate the general design principle, which states that any construct should do precisely one thing.\n\n**Example:**\n\n\n      String userName;\n      // Warning: result of assignment to 'userName' is used\n      String message = \"Hello \" + (userName = \"Alice\") + \"!\"\n      System.out.println(message);\n      System.out.println(\"Goodbye \" + userName);\n"
        },
        {
          "shortName": "IncrementDecrementUsedAsExpression",
          "displayName": "Result of '++' or '--' used",
          "enabled": false,
          "description": "Reports increment or decrement expressions that are nested inside other expressions. Such expressions may be confusing and violate the general design principle, which states that any construct should do precisely one thing.\n\nThe quick-fix extracts the increment or decrement operation to a separate expression statement.\n\n**Example:**\n\n\n      int i = 10;\n      while (i-- > 0) {\n        System.out.println(i);\n      }\n\nAfter the quick-fix is applied:\n\n\n      int i = 10;\n      while (i > 0) {\n        i--;\n        System.out.println(i);\n      }\n      i--;\n"
        },
        {
          "shortName": "ReplaceAssignmentWithOperatorAssignment",
          "displayName": "Assignment can be replaced with operator assignment",
          "enabled": false,
          "description": "Reports assignment operations which can be replaced by operator-assignment.\n\nCode using operator assignment is shorter and may be clearer.\n\n**Example:**\n\n      x = x + 3;\n      x = x / 3;\n\nAfter the quick fix is applied:\n\n      x += 3;\n      x /= 3;\n\n\nUse the **Ignore conditional operators** option to ignore `&&`\nand `||`. Replacing conditional operators with operator\nassignment would change the evaluation from lazy to eager, which may change the semantics of the expression.\n\n\nUse the **Ignore obscure operators** option to ignore `^` and `%`, which are less known."
        },
        {
          "shortName": "AssignmentToStaticFieldFromInstanceMethod",
          "displayName": "Assignment to static field from instance context",
          "enabled": false,
          "description": "Reports assignment to, or modification of `static` fields from within an instance method.\n\nAlthough legal, such assignments are tricky to do\nsafely and are often a result of marking fields `static` inadvertently.\n\n**Example:**\n\n\n      class Counter {\n        private static int count = 0;\n\n        void increment() {\n          // Warning: updating a static field\n          // from an instance method\n          count++;\n        }\n      }\n"
        },
        {
          "shortName": "AssignmentToCatchBlockParameter",
          "displayName": "Assignment to 'catch' block parameter",
          "enabled": true,
          "description": "Reports assignments to, `catch` block parameters.\n\nChanging a `catch` block parameter is very confusing and should be discouraged.\n\nThe quick-fix adds a declaration of a new variable.\n\n**Example:**\n\n\n      void processFile(String fileName) throws Exception {\n        try {\n          doProcessFile(fileName);\n        } catch(Exception ex) {\n          if (ex instanceof UncheckedIOException) {\n            // Warning: catch block parameter reassigned\n            ex = ((UncheckedIOException) ex).getCause();\n          }\n          throw ex;\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      void processFile(String fileName) throws Exception {\n        try {\n          doProcessFile(fileName);\n        } catch(Exception ex) {\n          Exception unwrapped = ex;\n          if (unwrapped instanceof UncheckedIOException) {\n            unwrapped = ((UncheckedIOException)\n              unwrapped).getCause();\n          }\n          throw unwrapped;\n        }\n      }\n"
        },
        {
          "shortName": "AssignmentToSuperclassField",
          "displayName": "Constructor assigns value to field defined in superclass",
          "enabled": false,
          "description": "Reports assignment to, or modification of fields that are declared in a superclass from within a subclass constructor.\n\nIt is considered preferable to initialize the fields of a superclass in its own constructor and\ndelegate to that constructor in a subclass. This will also allow declaring a field `final`\nif it isn't changed after the construction.\n\n**Example:**\n\n\n      class Super {\n        int x;\n      }\n      class Sub extends Super {\n        Sub(int _x) {\n          // Warning: x is declared in a superclass\n          x = _x;\n        }\n      }\n\nTo avoid the problem, declare a superclass constructor:\n\n\n      class Super {\n        final int x;\n\n        Super(int _x) {\n          x = _x;\n        }\n      }\n      class Sub extends Super {\n        Sub(int _x) {\n          super(_x);\n        }\n      }\n"
        },
        {
          "shortName": "AssignmentUsedAsCondition",
          "displayName": "Assignment used as condition",
          "enabled": true,
          "description": "Reports assignments that are used as a condition of an `if`, `while`, `for`, or `do` statement, or a conditional expression.\n\nAlthough occasionally intended, this usage is confusing and may indicate a typo, for example, `=` instead of `==`.\n\nThe quick-fix replaces `=` with `==`.\n\n**Example:**\n\n\n      void update(String str, boolean empty) {\n        // Warning: 'empty' is reassigned,\n        // not compared to str.isEmpty()\n        if (empty = str.isEmpty()) {\n          ...\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      void update(String str, boolean empty) {\n        if (empty == str.isEmpty()) {\n          ...\n        }\n      }\n"
        },
        {
          "shortName": "AssignmentToMethodParameter",
          "displayName": "Assignment to method parameter",
          "enabled": false,
          "description": "Reports assignment to, or modification of method parameters.\n\nAlthough occasionally intended, this construct may be confusing\nand is therefore prohibited in some Java projects.\n\nThe quick-fix adds a declaration of a new variable.\n\n**Example:**\n\n\n      void printTrimmed(String s) {\n        s = s.trim();\n        System.out.println(s);\n      }\n\nAfter the quick-fix is applied:\n\n\n      void printTrimmed(String s) {\n        String trimmed = s.trim();\n        System.out.println(trimmed);\n      }\n\n\nUse the **Ignore if assignment is a transformation of the original parameter** option to ignore assignments that modify\nthe parameter value based on its previous value."
        },
        {
          "shortName": "AssignmentToLambdaParameter",
          "displayName": "Assignment to lambda parameter",
          "enabled": false,
          "description": "Reports assignment to, or modification of lambda parameters. Although occasionally intended, this construct may be confusing and is often caused by a typo or use of a wrong variable.\n\nThe quick-fix adds a declaration of a new variable.\n\n**Example:**\n\n\n      list.forEach(s -> {\n        s = s.trim();\n        System.out.println(\"String: \" + s);\n      });\n\nAfter the quick-fix is applied:\n\n\n      list.forEach(s -> {\n        String trimmed = s.trim();\n        System.out.println(\"String: \" + trimmed);\n      });\n\nUse the **Ignore if assignment is a transformation of the original parameter** option to ignore assignments that modify the parameter\nvalue based on its previous value."
        },
        {
          "shortName": "GroovyAssignmentToMethodParameter",
          "displayName": "Assignment to method parameter",
          "enabled": false,
          "description": "Reports assignment to method parameters.\n\nWhile occasionally intended, this construct can be extremely confusing, and is often the result of a typo.\n\n**Example:**\n\n\n      def m(a, b, c) {\n          a = [] // warning\n      }\n"
        },
        {
          "shortName": "GroovyUncheckedAssignmentOfMemberOfRawType",
          "displayName": "Unchecked assignment from members of raw type",
          "enabled": false,
          "description": "Reports unchecked assignments from members of raw type.\n\n**Example:**\n\n\n      List list = new ArrayList()\n      List&ltString> a = list.get(0)\n"
        },
        {
          "shortName": "GroovyAssignabilityCheck",
          "displayName": "Incompatible type assignments",
          "enabled": false,
          "description": "Reports assignments with incompatible types.\n\nSuch assignments might result in various runtime exceptions.\n\n**Example:**\n\n\n      class A {}\n      class B {}\n\n      // incompatible assignment\n      A a = new B()\n"
        },
        {
          "shortName": "GroovyResultOfAssignmentUsed",
          "displayName": "Result of assignment used",
          "enabled": false,
          "description": "Reports assignment expressions nested inside other expressions to use the assigned value immediately.\n\n\nSuch expressions may be confusing and violating the general design principle that a\ngiven construct should do precisely one thing."
        },
        {
          "shortName": "GroovyNestedAssignment",
          "displayName": "Nested assignment",
          "enabled": false,
          "description": "Reports assignment expressions nested inside other expressions. While admirably terse, such expressions may be confusing, and violate the general design principle that a given construct should do precisely one thing.\n\n**Example:**\n\n\n    a = b = 1\n\n"
        },
        {
          "shortName": "GroovyAssignmentToForLoopParameter",
          "displayName": "Assignment to 'for' loop parameter",
          "enabled": false,
          "description": "Reports assignments to **for** loop parameters inside the **for** loop body.\n\nWhile occasionally intended, this construct can be extremely confusing, and is often the result of a typo.\n\n**Example:**\n\n\n      for (value in [1, 2, 3]) {\n          value = 4 // warning\n      }\n"
        },
        {
          "shortName": "GroovyAssignmentCanBeOperatorAssignment",
          "displayName": "Assignment can be replaced with operator assignment",
          "enabled": false,
          "description": "Reports assignments which can be replaced by an operator assignment.\n\n**Example:**\n\n\n      a = a + b\n\nAfter the quick-fix is applied:\n\n\n      a += b\n\nConfigure the inspection:\n\n* Use the **Ignore conditional operators** option to ignore `&&` and `||` operators.\n* Use the **Ignore obscure operators** option to ignore `^` and `%` operators."
        },
        {
          "shortName": "GroovySillyAssignment",
          "displayName": "Silly assignment",
          "enabled": false,
          "description": "Reports assignments of a variable to itself."
        }
      ]
    },
    {
      "name": "Naming conventions",
      "inspections": [
        {
          "shortName": "GroovyConstantNamingConvention",
          "displayName": "Constant naming convention",
          "enabled": false,
          "description": "Reports constant with names which don't match the specified convention.\n\nConstants are fields of immutable type declared with `static` and `final` modifiers.\nReports constants whose names are either too short, too long, or do not follow the specified regular expression pattern.\n\nConfigure the inspection:\n\n* Use the **Pattern** field to specify `java.util.regex.Pattern` which a constant name is expected to match.\n* Use the **Min length** field to specify the minimum length of a constant name.\n* Use the **Max length** field to specify the maximum length of a constant name."
        },
        {
          "shortName": "GroovyStaticMethodNamingConvention",
          "displayName": "Static method naming convention",
          "enabled": false,
          "description": "Reports static methods whose names are too short, too long, or do not follow the specified regular expression pattern.\n\n\nUse the fields provided below to specify minimum length, maximum length and regular expression expected for static method names.\n\nRegular expressions should be specified in the standard `java.util.regex` format."
        },
        {
          "shortName": "GroovyLocalVariableNamingConvention",
          "displayName": "Local variable naming convention",
          "enabled": false,
          "description": "Reports local variables whose names are too short, too long, or do not follow the specified regular expression pattern.\n\n\nUse the fields provided below to specify minimum length, maximum length and regular expression expected for local variables names.\n\nRegular expressions should be specified in the standard `java.util.regex` format."
        },
        {
          "shortName": "GroovyInstanceMethodNamingConvention",
          "displayName": "Instance method naming convention",
          "enabled": false,
          "description": "Reports instance methods whose names are too short, too long, or do not follow the specified regular expression pattern. Instance methods that override library methods are ignored by this inspection.\n\n\nUse the fields provided below to specify minimum length, maximum length and regular expression expected for instance method names.\n\nRegular expressions should be specified in the standard `java.util.regex` format."
        },
        {
          "shortName": "NewGroovyClassNamingConvention",
          "displayName": "Class naming convention",
          "enabled": false,
          "description": "Reports classes whose names are too short, too long, or do not follow\nthe specified regular expression pattern.\n\nFor each class type, specify the minimum length, maximum length, and the regular expression expected for class names using the\nprovided input fields.\n\nRegular expressions should be specified in the standard `java.util.regex` format."
        },
        {
          "shortName": "GroovyInstanceVariableNamingConvention",
          "displayName": "Instance variable naming convention",
          "enabled": false,
          "description": "Reports instance variables whose names are too short, too long, or do not follow the specified regular expression pattern.\n\n\nUse the fields provided below to specify minimum length, maximum length and regular expression expected for\ninstance variable names.\n\nRegular expressions should be specified in the standard `java.util.regex` format."
        },
        {
          "shortName": "GroovyParameterNamingConvention",
          "displayName": "Method parameter naming convention",
          "enabled": false,
          "description": "Reports method parameters whose names are either too short, too long, or do not follow the specified regular expression pattern.\n\n\nUse the fields provided below to specify minimum length, maximum length and regular expression\nexpected for method parameter names.\n\nRegular expressions should be specified in the standard `java.util.regex` format."
        },
        {
          "shortName": "GroovyStaticVariableNamingConvention",
          "displayName": "Static variable naming convention",
          "enabled": false,
          "description": "Reports `static` variables whose names are too short, too long, or do not follow the specified regular expression pattern.\n\n\nConstants, i.e. variables of immutable type declared\n`static final`, are not checked by this inspection\n\n\nUse the fields provided below to specify minimum length, maximum length and regular expression expected for static variable names.\n\nRegular expressions should be specified in the standard `java.util.regex` format."
        },
        {
          "shortName": "PropertyName",
          "displayName": "Property naming convention",
          "enabled": false,
          "description": "Reports property names that do not follow the recommended naming conventions.\n\n\nConsistent naming allows for easier code reading and understanding.\nAccording to the [Kotlin official style guide](https://kotlinlang.org/docs/coding-conventions.html#naming-rules),\nproperty names should start with a lowercase letter and use camel case.\n\nIt is possible to introduce other naming rules by changing the \"Pattern\" regular expression.\n\n**Example:**\n\n\n      val My_Cool_Property = \"\"\n\nA quick-fix renames the class according to the Kotlin naming conventions:\n\n\n      val myCoolProperty = \"\"\n"
        },
        {
          "shortName": "ObjectPropertyName",
          "displayName": "Object property naming convention",
          "enabled": false,
          "description": "Reports properties that do not follow the naming conventions.\n\nThe following properties are reported:\n\n* Top-level properties\n* Properties in objects and companion objects\n\nYou can specify the required pattern in the inspection options.\n\n[Recommended naming conventions](https://kotlinlang.org/docs/coding-conventions.html#naming-rules): it has to start with an uppercase letter, use camel case and no underscores.\n\n**Example:**\n\n\n      // top-level property\n      val USER_NAME_FIELD = \"UserName\"\n      // top-level property holding reference to singleton object\n      val PersonComparator: Comparator<Person> = /*...*/\n\n      class Person {\n        companion object {\n          // property in companion object\n          val NO_NAME = Person()\n        }\n      }\n"
        },
        {
          "shortName": "ClassName",
          "displayName": "Class naming convention",
          "enabled": false,
          "description": "Reports class names that do not follow the recommended naming conventions.\n\n\nConsistent naming allows for easier code reading and understanding.\nAccording to the [Kotlin official style guide](https://kotlinlang.org/docs/coding-conventions.html#naming-rules),\nclass names should start with an uppercase letter and use camel case.\n\nIt is possible to introduce other naming rules by changing the \"Pattern\" regular expression.\n\n**Example:**\n\n\n      class user(val name: String)\n\nA quick-fix renames the class according to the Kotlin naming conventions:\n\n\n      class User(val name: String)\n"
        },
        {
          "shortName": "EnumEntryName",
          "displayName": "Enum entry naming convention",
          "enabled": false,
          "description": "Reports enum entry names that do not follow the recommended naming conventions.\n\n**Example:**\n\n\n      enum class Foo {\n        _Foo,\n        foo\n      }\n\nTo fix the problem rename enum entries to match the recommended naming conventions."
        },
        {
          "shortName": "InconsistentCommentForJavaParameter",
          "displayName": "Inconsistent comment for Java parameter",
          "enabled": false,
          "description": "Reports inconsistent parameter name for **java** method specified in a comment block.\n\n**Examples:**\n\n\n      // Java\n      public class JavaService {\n          public void invoke(String command) {}\n      }\n\n\n      // Kotlin\n      fun main() {\n          JavaService().invoke(/* name = */ \"fix\")\n      }\n\nThe quick fix corrects parameter name in a comment block:\n\n\n      fun main() {\n          JavaService().invoke(/* command = */ \"fix\")\n      }\n"
        },
        {
          "shortName": "PackageName",
          "displayName": "Package naming convention",
          "enabled": false,
          "description": "Reports package names that do not follow the naming conventions.\n\nYou can specify the required pattern in the inspection options.\n\n[Recommended naming conventions](https://kotlinlang.org/docs/coding-conventions.html#naming-rules): names of packages are always lowercase and should not contain underscores.\n\n**Example:**\n`org.example.project`\n\nUsing multi-word names is generally discouraged, but if you do need to use multiple words, you can either just concatenate them together or use camel case\n\n**Example:**\n`org.example.myProject`"
        },
        {
          "shortName": "LocalVariableName",
          "displayName": "Local variable naming convention",
          "enabled": false,
          "description": "Reports local variables that do not follow the naming conventions.\n\nYou can specify the required pattern in the inspection options.\n\n[Recommended naming conventions](https://kotlinlang.org/docs/coding-conventions.html#function-names): it has to start with a lowercase letter, use camel case and no underscores.\n\n**Example:**\n\n\n      fun fibonacciNumber(index: Int): Long = when(index) {\n          0 -> 0\n          else -> {\n              // does not follow naming conventions: contains underscore symbol (`_`)\n              var number_one: Long = 0\n              // does not follow naming conventions: starts with an uppercase letter\n              var NUMBER_TWO: Long = 1\n              // follow naming conventions: starts with a lowercase letter, use camel case and no underscores.\n              var numberThree: Long = number_one + NUMBER_TWO\n\n              for(currentIndex in 2..index) {\n                  numberThree = number_one + NUMBER_TWO\n                  number_one = NUMBER_TWO\n                  NUMBER_TWO = numberThree\n              }\n              numberThree\n          }\n      }\n"
        },
        {
          "shortName": "PrivatePropertyName",
          "displayName": "Private property naming convention",
          "enabled": false,
          "description": "Reports private property names that do not follow the recommended naming conventions.\n\n\nConsistent naming allows for easier code reading and understanding.\nAccording to the [Kotlin official style guide](https://kotlinlang.org/docs/coding-conventions.html#naming-rules),\nprivate property names should start with a lowercase letter and use camel case.\nOptionally, underscore prefix is allowed but only for **private** properties.\n\nIt is possible to introduce other naming rules by changing the \"Pattern\" regular expression.\n\n**Example:**\n\n\n      val _My_Cool_Property = \"\"\n\nA quick-fix renames the class according to the Kotlin naming conventions:\n\n\n      val _myCoolProperty = \"\"\n"
        },
        {
          "shortName": "TestFunctionName",
          "displayName": "Test function naming convention",
          "enabled": false,
          "description": "Reports test function names that do not follow the [recommended naming conventions](https://kotlinlang.org/docs/coding-conventions.html#names-for-test-methods)."
        },
        {
          "shortName": "FunctionName",
          "displayName": "Function naming convention",
          "enabled": false,
          "description": "Reports function names that do not follow the recommended naming conventions.\n\n**Example:**\n\n\n      fun Foo() {}\n\nTo fix the problem change the name of the function to match the recommended naming conventions."
        },
        {
          "shortName": "ConstPropertyName",
          "displayName": "Const property naming convention",
          "enabled": false,
          "description": "Reports `const` property names that do not follow the recommended naming conventions.\n\n\nConsistent naming allows for easier code reading and understanding.\nAccording to the [Kotlin official style guide](https://kotlinlang.org/docs/coding-conventions.html#property-names),\n`const` properties should use uppercase underscore-separated names.\n\n**Example:**\n\n\n      const val Planck: Double = 6.62607015E-34\n\nA quick-fix renames the property:\n\n\n      const val PLANCK: Double = 6.62607015E-34\n"
        },
        {
          "shortName": "DollarSignInName",
          "displayName": "Use of '$' in identifier",
          "enabled": false,
          "description": "Reports variables, methods, and classes with dollar signs (`$`) in their names. While such names are legal Java, their use outside of generated java code is strongly discouraged.\n\n**Example:**\n\n\n      class SalaryIn${}\n\nRename quick-fix is suggested only in the editor."
        },
        {
          "shortName": "StandardVariableNames",
          "displayName": "Standard variable names",
          "enabled": false,
          "description": "Reports variables with 'standard' names that do not correspond to their types. Such names may be confusing. There are the following standard names for specific types:\n\n* i, j, k, m, n - `int`\n* f - `float`\n* d - `double`\n* b - `byte`\n* c, ch - `char`\n* l - `long`\n* s, str - `String`\n\nRename quick-fix is suggested only in the editor.\n\n\nUse the option to ignore parameter names which are identical to the parameter name from a direct super method."
        },
        {
          "shortName": "JavaModuleNaming",
          "displayName": "Java module name contradicts the convention",
          "enabled": false,
          "description": "Reports cases when a module name contradicts Java Platform Module System recommendations.\n\nOne of the [recommendations](http://mail.openjdk.java.net/pipermail/jpms-spec-experts/2017-March/000659.html)\nis to avoid using digits at the end of module names.\n\n**Example:**\n\n\n    module foo1.bar2 {}\n"
        },
        {
          "shortName": "UpperCaseFieldNameNotConstant",
          "displayName": "Non-constant field with upper-case name",
          "enabled": false,
          "description": "Reports non-`static` non-`final` fields whose names are all in upper case.\n\nSuch fields may cause confusion by breaking a common naming convention and\nare often used by mistake.\n\n**Example:**\n\n\n      public static int THE_ANSWER = 42; //a warning here: final modifier is missing\n\nA quick-fix that renames such fields is available only in the editor."
        },
        {
          "shortName": "PackageNamingConvention",
          "displayName": "Package naming convention",
          "enabled": false,
          "description": "Reports packages whose names are either too short, too long, or do not follow the specified regular expression pattern.\n\n**Example:**\n\n\n      package io;\n\n\nUse the options to specify the minimum and maximum length of the package name\nas well as a regular expression that matches valid package names\n(regular expressions are in standard `java.util.regex` format)."
        },
        {
          "shortName": "QuestionableName",
          "displayName": "Questionable name",
          "enabled": false,
          "description": "Reports variables, methods, or classes with questionable, not really descriptive names. Such names do not help to understand the code, and most probably were created as a temporary thing but were forgotten afterwards.\n\n**Example:**\n\n\n      int aa = 42;\n\nRename quick-fix is suggested only in the editor.\n\n\nUse the option to list names that should be reported."
        },
        {
          "shortName": "LocalVariableNamingConvention",
          "displayName": "Local variable naming convention",
          "enabled": false,
          "description": "Reports local variables whose names are too short, too long, or do not follow the specified regular expression pattern.\n\n**Example:** `int X = 42;`\nshould be reported if the inspection is enabled with the default settings in which a variable name should start with a lowercase letter.\n\nConfigure the inspection:\n\n\nUse the fields in the **Options** section to specify the minimum length, maximum length, and a regular expression expected for local variable names.\nSpecify **0** in order not to check the length of names. Regular expressions should be specified in the standard **java.util.regex** format.\n\nUse checkboxes to ignore `for`-loop and `catch` section parameters."
        },
        {
          "shortName": "LambdaParameterNamingConvention",
          "displayName": "Lambda parameter naming convention",
          "enabled": false,
          "description": "Reports lambda parameters whose names are too short, too long, or do not follow the specified regular expression pattern.\n\n**Example:** `Function<String, String> id = X -> X;`\nshould be reported if the inspection is enabled with the default settings in which a parameter name should start with a lowercase letter.\n\nConfigure the inspection:\n\n\nUse the fields in the **Options** section to specify the minimum length, maximum length, and a regular expression expected for lambda parameter names.\nSpecify **0** in order not to check the length of names.\n\nRegular expressions should be specified in the standard `java.util.regex` format."
        },
        {
          "shortName": "FieldNamingConvention",
          "displayName": "Field naming convention",
          "enabled": false,
          "description": "Reports fields whose names are too short, too long, or do not follow the specified regular expression pattern.\n\n**Example:** if the inspection is enabled for constants, and the minimum specified length for a field name is 5 (the default), the following constant\nproduces a warning because the length of its name is 3, which is less than 5: `public static final int MAX = 42;`.\n\nA quick-fix that renames such fields is available only in the editor.\n\nConfigure the inspection:\n\nUse the list in the **Options** section to specify which fields should be checked. Deselect the checkboxes for the fields for which\nyou want to skip the check.\n\nFor each field type, specify the minimum length, maximum length, and the regular expression expected for field names using the\nprovided input fields.\nSpecify **0** in the length fields to skip the corresponding checks.\n\nRegular expressions should be specified in the standard\n`java.util.regex` format."
        },
        {
          "shortName": "ParameterNameDiffersFromOverriddenParameter",
          "displayName": "Parameter name differs from parameter in overridden method",
          "enabled": false,
          "description": "Reports parameters whose names differ from the corresponding parameters of the methods they override. While legal in Java, such inconsistent names may be confusing and decrease the documentation benefits of good naming practices.\n\n**Example:**\n\n\n      class Person {\n        Person(String fullName) {}\n      }\n      class Child extends Person {\n        Child(String name) { super(name); }\n      }\n\nAfter the quick-fix is applied:\n\n\n      class Person {\n        Person(String fullName) {}\n      }\n      class Child extends Person {\n        Child(String fullName) { super(fullName); }\n      }\n\n\nUse the options to indicate whether to ignore overridden parameter names that are only\na single character long or come from a library method. Both can be useful if\nyou do not wish to be bound by dubious naming conventions used in libraries."
        },
        {
          "shortName": "ParameterNamingConvention",
          "displayName": "Method parameter naming convention",
          "enabled": false,
          "description": "Reports method parameters whose names are too short, too long, or do not follow the specified regular expression pattern.\n\n**Example:** `void fooBar(int X)`\nshould be reported if the inspection is enabled with the default settings in which a parameter name should start with a lowercase letter.\n\nConfigure the inspection:\n\n\nUse the fields in the **Options** section to specify the minimum length, maximum length, and a regular expression expected for\nmethod parameter names. Specify **0** in order not to check the length of names.\n\nRegular expressions should be specified in the standard `java.util.regex` format."
        }
      ]
    },
    {
      "name": "Packaging issues",
      "inspections": [
        {
          "shortName": "PackageWithTooFewClasses",
          "displayName": "Package with too few classes",
          "enabled": false,
          "description": "Reports packages that contain fewer classes than the specified minimum.\n\nPackages which contain subpackages are not reported. Overly small packages may indicate a fragmented design.\n\nAvailable only from **Code \\| Inspect Code** or\n**Code \\| Analyze Code \\| Run Inspection by Name** and isn't reported in the editor.\n\nUse the **Minimum number of classes** field to specify the minimum allowed number of classes in a package."
        },
        {
          "shortName": "ClassUnconnectedToPackage",
          "displayName": "Class independent of its package",
          "enabled": false,
          "description": "Reports classes that don't depend on any other class in their package and are not a dependency for any other class in their package. Such classes indicate ad-hoc or incoherent packaging strategies and often may be profitably moved.\n\nAvailable only from **Code \\| Inspect Code** or\n**Code \\| Analyze Code \\| Run Inspection by Name** and isn't reported in the editor."
        },
        {
          "shortName": "DisjointPackage",
          "displayName": "Package with disjoint dependency graph",
          "enabled": false,
          "description": "Reports packages whose classes can be separated into mutually independent subsets.\n\nSuch disjoint packages indicate ad-hoc packaging or a lack of conceptual cohesion.\n\nAvailable only from **Code \\| Inspect Code** or\n**Code \\| Analyze Code \\| Run Inspection by Name** and isn't reported in the editor."
        },
        {
          "shortName": "ExceptionPackage",
          "displayName": "Exception package",
          "enabled": false,
          "description": "Reports packages that only contain classes that extend `java.lang.Throwable`, either directly or indirectly.\n\nAlthough exceptions usually don't depend on other classes for their implementation, they are normally not used separately.\nIt is often a better design to locate exceptions in the same package as the classes that use them.\n\nAvailable only from **Code \\| Inspect Code** or\n**Code \\| Analyze Code \\| Run Inspection by Name** and isn't reported in the editor."
        },
        {
          "shortName": "ClassOnlyUsedInOnePackage",
          "displayName": "Class only used from one other package",
          "enabled": false,
          "description": "Reports classes that don't depend on any other class in their package, depend on classes from another package, and are themselves a dependency only for classes from this other package. Consider moving such classes to the package on which they depend.\n\nAvailable only from **Code \\| Inspect Code** or\n**Code \\| Analyze Code \\| Run Inspection by Name** and isn't reported in the editor."
        },
        {
          "shortName": "PackageInMultipleModules",
          "displayName": "Package with classes in multiple modules",
          "enabled": false,
          "description": "Reports non-empty packages that are present in several modules. When packages are contained in several modules, it is very easy to create a class with the same name in two modules. A module which depends on these modules will see a conflict if it tries to use such a class. The Java Platform Module System disallows packages contained in more than one module (also called *split packages* )\n\nAvailable only from **Code \\| Inspect Code** or\n**Code \\| Analyze Code \\| Run Inspection by Name** and isn't reported in the editor."
        },
        {
          "shortName": "PackageWithTooManyClasses",
          "displayName": "Package with too many classes",
          "enabled": false,
          "description": "Reports packages that contain too many classes.\n\nOverly large packages may indicate a lack of design clarity.\n\nAvailable only from **Code \\| Inspect Code** or\n**Code \\| Analyze Code \\| Run Inspection by Name** and isn't reported in the editor.\n\nUse the **Maximum number of classes** field to specify the maximum allowed number of classes in a package."
        }
      ]
    },
    {
      "name": "Verbose or redundant code constructs",
      "inspections": [
        {
          "shortName": "ReplaceOnLiteralHasNoEffect",
          "displayName": "Replacement operation has no effect",
          "enabled": false,
          "description": "Reports calls to the `String` methods `replace()`, `replaceAll()` or `replaceFirst()` that have no effect. Such calls can be guaranteed to have no effect when the qualifier and search string are compile-time constants and the search string is not found in the qualifier. This is redundant and may indicate an error.\n\n**Example:**\n\n\n      // replacement does nothing\n      \"hello\".replace(\"$value$\", value);\n\nNew in 2022.1"
        },
        {
          "shortName": "UnnecessaryBreak",
          "displayName": "Unnecessary 'break' statement",
          "enabled": true,
          "description": "Reports any unnecessary `break` statements.\n\nAn `break` statement is unnecessary if no other statements are executed after it has been removed.\n\n**Example:**\n\n\n      switch (e) {\n        case A -> {\n            System.out.println(\"A\");\n            break; // reports 'break' statement is unnecessary\n        }\n        default -> {\n            System.out.println(\"Default\");\n            break; // reports 'break' statement is unnecessary\n        }\n      }\n"
        },
        {
          "shortName": "SimplifyOptionalCallChains",
          "displayName": "Optional call chain can be simplified",
          "enabled": true,
          "description": "Reports **Optional** call chains that can be simplified. Here are several examples of possible simplifications:\n\n* `optional.map(x -> true).orElse(false)`  `optional.isPresent()`\n* `optional.map(x -> Optional.of(x.trim())).orElseGet(Optional::empty)`  `optional.map(String::trim)`\n* `optional.map(x -> (String)x).orElse(null)`  `(String) optional.orElse(null)`\n* `Optional.ofNullable(optional.orElse(null))`  `optional`\n* `val = optional.orElse(null); val != null ? val : defaultExpr `  `optional.orElse(defaultExpr)`\n* `val = optional.orElse(null); if(val != null) expr(val) `  `optional.ifPresent(val -> expr(val))`\n\nNew in 2017.2"
        },
        {
          "shortName": "ConditionCoveredByFurtherCondition",
          "displayName": "Condition is covered by further condition",
          "enabled": true,
          "description": "Reports conditions that become redundant as they are completely covered by a subsequent condition.\n\nFor example, in the `value != -1 && value > 0` condition, the first part is redundant:\nif it's false, then the second part is also false.\nOr in a condition like `obj != null && obj instanceof String`,\nthe null-check is redundant as `instanceof` operator implies non-nullity.\n\nNew in 2018.3"
        },
        {
          "shortName": "UnnecessaryContinue",
          "displayName": "Unnecessary 'continue' statement",
          "enabled": true,
          "description": "Reports `continue` statements if they are the last reachable statements in the loop. These `continue` statements are unnecessary and can be safely removed.\n\nExample:\n\n\n      for (String element: elements) {\n        System.out.println();\n        continue;\n      }\n\nAfter the quick-fix is applied:\n\n\n      for (String element: elements) {\n        System.out.println();\n      }\n\nThe inspection doesn't analyze JSP files.\n\n\nUse the **Ignore in then branch of 'if' statement with 'else' branch** option to ignore\n`continue` statements when they are placed in a `then` branch of a complete\n`if`-`else` statement.\n\nExample:\n\n\n      for (String element: elements) {\n        if(element.isEmpty()) {\n          continue;\n        } else {\n          //...\n        }\n      }\n"
        },
        {
          "shortName": "StringBufferReplaceableByString",
          "displayName": "'StringBuilder' can be replaced with 'String'",
          "enabled": true,
          "description": "Reports usages of `StringBuffer`, `StringBuilder`, or `StringJoiner` which can be replaced with a single `String` concatenation.\n\nUsing `String` concatenation\nmakes the code shorter and simpler.\n\n\nThis inspection only reports when the suggested replacement does not result in significant\nperformance drawback on modern JVMs. In many cases, `String` concatenation may perform better.\n\n**Example:**\n\n\n      StringBuilder result = new StringBuilder();\n      result.append(\"i = \");\n      result.append(i);\n      result.append(\";\");\n      return result.toString();\n\nAfter the quick-fix is applied:\n\n\n      String result = \"i = \" + i + \";\";\n      return result;\n"
        },
        {
          "shortName": "UnnecessaryLabelOnBreakStatement",
          "displayName": "Unnecessary label on 'break' statement",
          "enabled": true,
          "description": "Reports `break` statements with unnecessary labels. Such labels do not change the control flow but make the code difficult to follow.\n\n**Example:**\n\n\n      label:\n      for(int i = 0; i < 10; i++) {\n        if (shouldBreak()) break label;\n        //doSmth\n      }\n\nAfter the quick-fix is applied:\n\n\n      label:\n      for(int i = 0; i < 10; i++) {\n        if (shouldBreak()) break;\n        //doSmth\n      }\n"
        },
        {
          "shortName": "ExplicitArrayFilling",
          "displayName": "Explicit array filling",
          "enabled": true,
          "description": "Reports loops that can be replaced with `Arrays.setAll()` or `Arrays.fill()` calls.\n\nThis inspection suggests replacing loops with `Arrays.setAll()` if the language level of the project or module is 8 or higher.\nReplacing loops with `Arrays.fill()` is possible with any language level.\n\nExample:\n\n\n      for (int i=0; i<array.length; i++) {\n         array[i] = calc(i);\n      }\n\nAfter the quick-fix is applied:\n\n\n      Arrays.setAll(array, this::calc);\n\nNew in 2017.1"
        },
        {
          "shortName": "RedundantFileCreation",
          "displayName": "Redundant 'File' instance creation",
          "enabled": true,
          "description": "Reports redundant `File` creation in one of the following constructors when only `String` path can be used: `FileInputStream`, `FileOutputStream`, `FileReader`, `FileWriter`, `PrintStream`, `PrintWriter`, `Formatter`.\n\nExample:\n\n\n    InputStream is = new FileInputStream(new File(\"in.txt\"));\n\nAfter quick-fix is applied:\n\n\n    InputStream is = new FileInputStream(\"in.txt\");\n\nNew in 2020.3"
        },
        {
          "shortName": "DuplicateExpressions",
          "displayName": "Multiple occurrences of the same expression",
          "enabled": true,
          "description": "Reports multiple equivalent occurrences of the same expression within a method (or constructor, or class initializer) if the result of the expression can be reused.\n\n\nThe expression is reported if it's free of side effects and its result is always the same (in terms of `Object.equals()`).\nThe examples of such expressions are `a + b`, `Math.max(a, b)`, `a.equals(b)`,\n`s.substring(a,b)`. To make sure the result is always the same, it's verified that the variables used in the expression don't\nchange their values between the occurrences of the expression.\n\n\nSuch expressions may contain methods of immutable classes like `String`, `BigDecimal`, and so on,\nand of utility classes like `Objects`, `Math` (except `random()`).\nThe well-known methods, such as `Object.equals()`, `Object.hashCode()`, `Object.toString()`,\n`Comparable.compareTo()`, and `Comparator.compare()` are OK as well because they normally don't have\nany observable side effects.\n\n\nUse the **Expression complexity threshold** option to specify the minimal expression complexity threshold. Specifying bigger\nnumbers will remove reports on short expressions.\n\n\n`Path.of` and `Paths.get` calls are treated as equivalent calls if they have the same arguments. These calls\nare always reported no matter how complex their arguments are. This behaviour can be tweaked using different complexity threshold.\n\nNew in 2018.3"
        },
        {
          "shortName": "UnnecessaryReturn",
          "displayName": "Unnecessary 'return' statement",
          "enabled": true,
          "description": "Reports `return` statements at the end of constructors and methods returning `void`. These statements are redundant and may be safely removed.\n\nThis inspection does not report in JSP files.\n\nExample:\n\n\n      void message() {\n        System.out.println(\"Hello World\");\n        return;\n      }\n\nAfter the quick-fix is applied:\n\n\n      void message() {\n        System.out.println(\"Hello World\");\n      }\n\n\nUse the **Ignore in then branch of 'if' statement with 'else' branch** option to ignore `return` statements in the then branch of `if` statements\nwhich also have an `else` branch."
        },
        {
          "shortName": "RedundantStreamOptionalCall",
          "displayName": "Redundant step in 'Stream' or 'Optional' call chain",
          "enabled": true,
          "description": "Reports redundant `Stream` or `Optional` calls like `map(x -> x)`, `filter(x -> true)` or redundant `sorted()` or `distinct()` calls.\n\nNote that a mapping operation in code like `streamOfIntegers.map(Integer::valueOf)`\nworks as `requireNonNull()` check:\nif the stream contains `null`, it throws a `NullPointerException`, thus it's not absolutely redundant.\nDisable the **Report redundant boxing in Stream.map()** option if you do not want such cases to be reported.\n\nThis inspection only reports if the language level of the project or module is 8 or higher."
        },
        {
          "shortName": "CastCanBeRemovedNarrowingVariableType",
          "displayName": "Too weak variable type leads to unnecessary cast",
          "enabled": true,
          "description": "Reports type casts that can be removed if the variable type is narrowed to the cast type.\n\nExample:\n\n\n      Object x = \"  string  \";\n      System.out.println(((String)x).trim());\n\n\nHere, changing the type of `x` to `String` makes the cast redundant. The suggested quick-fix updates the variable type and\nremoves all redundant casts on that variable:\n\n\n      String x = \"  string  \";\n      System.out.println(x.trim());\n\nNew in 2018.2"
        },
        {
          "shortName": "ExcessiveLambdaUsage",
          "displayName": "Excessive lambda usage",
          "enabled": true,
          "description": "Reports if a trivial lambda expression is used in cases in which there's an alternative method that behaves in the same way, but accepts a concrete value instead of a lambda.\n\nThis inspection helps simplify the code.\n\nExample:\n\n\n      Optional.orElseGet(() -> null)\n\nAfter the quick-fix is applied:\n\n\n      Optional.orElse(null)\n\nNew in 2017.1"
        },
        {
          "shortName": "StringOperationCanBeSimplified",
          "displayName": "Redundant 'String' operation",
          "enabled": true,
          "description": "Reports redundant `String` constructors and calls to methods like `toString()` or `substring()` when they can be replaced with a simplified expression.\n\nFor example, calls to these methods can be safely removed in cases\nlike `\"string\".substring(0)`, `\"string\".toString()`, or\n`new StringBuilder().toString().substring(1,3)`.\n\nExample:\n\n\n      System.out.println(new String(\"message\"));\n\nAfter the quick-fix is applied:\n\n\n      System.out.println(\"message\");\n\n\nNote that the quick-fix removes the redundant constructor, and this may affect `String` referential equality.\nIf you need to preserve it even though it is considered bad practice, suppress the warning or configure the settings to ignore\nredundant `String` constructors.\n\nNew in 2018.1"
        },
        {
          "shortName": "ObviousNullCheck",
          "displayName": "Null-check method is called with obviously non-null argument",
          "enabled": true,
          "description": "Reports if a null-checking method (for example, `Objects.requireNonNull` or `Assert.assertNotNull`) is called on the value that is obviously non-null (for example, a newly created object). Such a check is redundant and may indicate a programming error.\n\nNew in 2017.2"
        },
        {
          "shortName": "RedundantClassCall",
          "displayName": "Redundant 'isInstance()' or 'cast()' call",
          "enabled": true,
          "description": "Reports redundant calls of `java.lang.Class` methods.\n\nFor example, `Xyz.class.isInstance(object)` can be replaced with `object instanceof Xyz`.\nThe instanceof check is preferred: even though the performance will probably be the same as these methods are intrinsics,\nthey better indicate a static check.\n\nNew in 2018.2"
        },
        {
          "shortName": "UnnecessaryStringEscape",
          "displayName": "Unnecessarily escaped character",
          "enabled": true,
          "description": "Reports unnecessarily escaped characters in `String` and optionally `char` literals.\n\nThe escaped tab character `\\t` is not reported, because otherwise it will be invisible.\n\nExamples:\n\n\n      String s = \"\\'Scare\\' quotes\";\n      String t = \"\"\"\n        All you need is\\n\\tLove\\n\"\"\";\n\nAfter the quick-fix is applied:\n\n\n      String s = \"'Scare' quotes\";\n      String t = \"\"\"\n        All you need is\n        \\tLove\n      \"\"\";\n\nNew in 2019.3"
        },
        {
          "shortName": "SimplifyStreamApiCallChains",
          "displayName": "Stream API call chain can be simplified",
          "enabled": true,
          "description": "Reports stream API call chains that can be simplified. Simplification will often avoid some temporary object creation during collection traversal.\n\n\nThe inspection replaces the following call chains:\n\n* `collection.stream().forEach()`  `collection.forEach()`\n* `collection.stream().collect(toList/toSet/toCollection())`  `new CollectionType<>(collection)`\n* `collection.stream().toArray()`  `collection.toArray()`\n* `Arrays.asList().stream()`  `Arrays.stream()` or `Stream.of()`\n* `IntStream.range(0, array.length).mapToObj(idx -> array[idx])`  `Arrays.stream(array)`\n* `IntStream.range(0, list.size()).mapToObj(idx -> list.get(idx))`  `list.stream()`\n* `Collections.singleton().stream()`  `Stream.of()`\n* `Collections.emptyList().stream()`  `Stream.empty()`\n* `stream.filter().findFirst().isPresent()`  `stream.anyMatch()`\n* `stream.collect(counting())`  `stream.count()`\n* `stream.collect(maxBy())`  `stream.max()`\n* `stream.collect(mapping())`  `stream.map().collect()`\n* `stream.collect(reducing())`  `stream.reduce()`\n* `stream.collect(summingInt())`  `stream.mapToInt().sum()`\n* `stream.mapToObj(x -> x)`  `stream.boxed()`\n* `stream.map(x -> {...; return x;})`  `stream.peek(x -> ...)`\n* `!stream.anyMatch()`  `stream.noneMatch()`\n* `!stream.anyMatch(x -> !(...))`  `stream.allMatch()`\n* `stream.map().anyMatch(Boolean::booleanValue)`  `stream.anyMatch()`\n* `IntStream.range(expr1, expr2).mapToObj(x -> array[x])`  `Arrays.stream(array, expr1, expr2)`\n* `Collection.nCopies(count, ...)`  `Stream.generate().limit(count)`\n* `stream.sorted(comparator).findFirst()`  `Stream.min(comparator)`\n* `optional.orElseGet(() -> { throw new ...; })`  `optional.orElseThrow()`\n\n\nNote that the replacement semantics may have minor differences in some cases. For example,\n`Collections.synchronizedList(...).stream().forEach()` is not synchronized while\n`Collections.synchronizedList(...).forEach()` is synchronized.\nAlso, `collect(Collectors.maxBy())` returns an empty `Optional` if the resulting element is\n`null` while `Stream.max()` throws `NullPointerException` in this case."
        },
        {
          "shortName": "RedundantCast",
          "displayName": "Redundant type cast",
          "enabled": false,
          "description": "Reports unnecessary cast expressions.\n\nExample:\n\n\n      static Object toObject(String s) {\n        return (Object) s;\n      }\n\n\nUse the checkbox below to ignore clarifying casts e.g., casts in collection calls where `Object` is expected:\n\n\n      static void removeFromList(List<String> l, Object o) {\n        l.remove((String)o);\n      } \n"
        },
        {
          "shortName": "SimplifyCollector",
          "displayName": "Simplifiable collector",
          "enabled": true,
          "description": "Reports collectors that can be simplified.\n\nIn particular, some cascaded `groupingBy` collectors can be expressed by using a\nsimpler `toMap` collector, which is also likely to be more performant.\n\nExample:\n\n\n      Collectors.groupingByConcurrent(String::length, Collectors.collectingAndThen(Collectors.maxBy(String::compareTo), Optional::get));\n\nAfter the quick-fix is applied:\n\n\n      Collectors.toConcurrentMap(String::length, Function.identity(), BinaryOperator.maxBy(String::compareTo));\n\nThis inspection only reports if the language level of the project or module is 8 or higher.\n\nNew in 2017.1"
        },
        {
          "shortName": "RedundantCollectionOperation",
          "displayName": "Redundant 'Collection' operation",
          "enabled": true,
          "description": "Reports unnecessarily complex collection operations which have simpler alternatives.\n\nExample:\n\n\n      void f(String[] array, Collection<String> collection) {\n        String[] strings = Arrays.asList(array).subList(0, 10).toArray(new String[0]);\n        boolean contains = collection.containsAll(Collections.singletonList(\"x\"));\n      }\n\nAfter the quick-fix is applied:\n\n\n      void f(String[] array, Collection<String> collection) {\n        String[] strings = Arrays.copyOf(array, 10);\n        boolean contains = collection.contains(\"x\");\n      }\n\nNew in 2018.1"
        },
        {
          "shortName": "UnnecessaryDefault",
          "displayName": "Unnecessary 'default' for enum 'switch' statement",
          "enabled": true,
          "description": "Reports enum `switch` statements or expression with `default` branches which can never be taken, because all possible values are covered by a `case` branch.\n\nSuch elements are redundant, especially for `switch` expressions, because they don't compile when all\nenum constants are not covered by a `case` branch.\n\n\nThe language level needs to be configured to 14 to report `switch` expressions.\n\nThe provided quick-fix removes `default` branches.\n\nExample:\n\n\n      enum E { A, B }\n      int foo(E e) {\n        return switch (e) {\n          case A -> 1;\n          case B -> 2;\n          default -> 3;\n        };\n      }\n\nAfter the quick-fix is applied:\n\n\n      enum E { A, B }\n      int foo(E e) {\n        return switch (e) {\n          case A -> 1;\n          case B -> 2;\n        };\n      }\n\nUse the **Only report switch expressions** option to report only redundant `default` branches in switch expressions."
        },
        {
          "shortName": "RedundantCompareCall",
          "displayName": "Redundant 'compare()' method call",
          "enabled": true,
          "description": "Reports comparisons in which the `compare` method is superfluous.\n\nExample:\n\n\n      boolean result = Integer.compare(a, b) == 0;\n\nAfter the quick-fix is applied:\n\n\n      boolean result = a == b;\n\nNew in 2018.2"
        },
        {
          "shortName": "UnnecessaryLabelOnContinueStatement",
          "displayName": "Unnecessary label on 'continue' statement",
          "enabled": true,
          "description": "Reports `continue` statements with unnecessary labels.\n\nExample:\n\n\n      LABEL:\n      while (a > b) {\n        System.out.println(\"Hello\");\n        //the code below is the last statement in a loop,\n        //so unnecessary label and continue can be removed\n        continue LABEL;\n      }\n"
        },
        {
          "shortName": "RedundantArrayCreation",
          "displayName": "Redundant array creation",
          "enabled": true,
          "description": "Reports arrays that are created specifically to be passed as a varargs parameter.\n\nExample:\n\n`Arrays.asList(new String[]{\"Hello\", \"world\"})`\n\nThe quick-fix replaces the array initializer with individual arguments:\n\n`Arrays.asList(\"Hello\", \"world\")`"
        },
        {
          "shortName": "RedundantUnmodifiable",
          "displayName": "Redundant usage of unmodifiable collection wrappers",
          "enabled": true,
          "description": "Reports redundant calls to unmodifiable collection wrappers within the `Collections` class.\n\nIf the argument that is passed to an unmodifiable\ncollection wrapper is already immutable, such a wrapping becomes redundant.\n\nExample:\n\n\n      Collections.unmodifiableList(Collections.singletonList(\"abc\"));\n\nIn order to detect the methods that return unmodifiable collections, the\ninspection uses the `org.jetbrains.annotations.Unmodifiable`\nand `org.jetbrains.annotations.UnmodifiableView` annotations.\nUse them to extend the inspection to your own unmodifiable collection\nwrappers.\n\nNew in 2020.3"
        },
        {
          "shortName": "RedundantTypeArguments",
          "displayName": "Redundant type arguments",
          "enabled": false,
          "description": "Reports all calls to parametrized methods in which explicit argument types can be omitted since they will be unambiguously inferred by the compiler.\n\n\nUsing redundant type arguments makes code superfluous and thus less readable.\n\nExample:\n\n\n      List<String> list = Arrays.<String>asList(\"Hello\", \"World\");\n\nA quick-fix is provided to remove redundant type arguments:\n\n\n      List<String> list = Arrays.asList(\"Hello\", \"World\");\n"
        },
        {
          "shortName": "DuplicateBranchesInSwitch",
          "displayName": "Duplicate branches in 'switch'",
          "enabled": true,
          "description": "Reports `switch` statements or expressions that contain the same code in different branches and suggests merging the duplicate branches.\n\nExample:\n\n\n      switch (n) {\n        case 1:\n          System.out.println(n);\n          break;\n        case 2:\n          System.out.println(n);\n          break;\n        default:\n          System.out.println(\"default\");\n      }\n\nCan be replaced with:\n\n\n      switch (n) {\n        case 1:\n        case 2:\n          System.out.println(n);\n          break;\n        default:\n          System.out.println(\"default\");\n      }\n\nNew in 2019.1"
        },
        {
          "shortName": "ManualMinMaxCalculation",
          "displayName": "Manual min/max calculation",
          "enabled": true,
          "description": "Reports cases where the minimum or the maximum of two numbers can be calculated using a `Math.max()` or `Math.min()` call, instead of doing it manually.\n\n**Example:**\n\n\n      public int min(int a, int b) {\n        return b < a ? b : a;\n      }\n\nAfter the quick-fix is applied:\n\n\n      public int min(int a, int b) {\n        return Math.min(a, b);\n      }\n\n\nUse the **Disable for float and double** option to disable this inspection for `double` and `float` types.\nThis is useful because the quick-fix may slightly change the semantics for `float`/\n`double` types when handling `NaN`. Nevertheless, in most cases this will actually fix\na subtle bug where `NaN` is not taken into account.\n\nNew in 2019.2"
        },
        {
          "shortName": "RedundantComparatorComparing",
          "displayName": "Comparator method can be simplified",
          "enabled": false,
          "description": "Reports redundant `Comparator` combinator constructs which can be simplified.\n\nExample:\n\n\n      c.thenComparing(Comparator.comparing(function));\n\n      Comparator.comparing(Map.Entry::getKey);\n\n      Collections.max(list, Comparator.reverseOrder());\n\nAfter the quick-fixes are applied:\n\n\n      c.thenComparing(function)\n\n      Map.Entry.comparingByKey()\n\n      Collections.min(list, Comparator.naturalOrder());\n\nNew in 2018.1"
        },
        {
          "shortName": "ExcessiveRangeCheck",
          "displayName": "Excessive range check",
          "enabled": true,
          "description": "Reports condition chains in which a value range is checked and these condition chains can be simplified to a single check.\n\nThe quick-fix replaces a condition chain with a simplified expression:\n\nExample:\n\n\n      x > 2 && x < 4\n\nAfter the quick-fix is applied:\n\n\n      x == 3\n\nExample:\n\n\n      arr.length == 0 || arr.length > 1\n\nAfter the quick-fix is applied:\n\n\n      arr.length != 1\n\nNew in 2019.1"
        }
      ]
    },
    {
      "name": "General",
      "inspections": [
        {
          "shortName": "InjectedReferences",
          "displayName": "Injected references",
          "enabled": false,
          "description": "Reports unresolved references injected by [Language Injections](https://www.jetbrains.com/help/idea/using-language-injections.html).\n\nExample:\n\n```\n    @Language(\"file-reference\")\n    String fileName = \"/home/user/nonexistent.file\"; // highlighted if file doesn't exist\n```"
        },
        {
          "shortName": "DefaultFileTemplate",
          "displayName": "Default File Template Usage",
          "enabled": false,
          "description": "Reports usages of the default File Header template and suggests changing it. The File Header template can be modified in [Settings \\| Editor \\| File and Code Templates \\| Includes](settings://fileTemplates?Includes)"
        },
        {
          "shortName": "InconsistentLineSeparators",
          "displayName": "Inconsistent line separators",
          "enabled": false,
          "description": "Reports files with line separators different from the ones that are specified in the project's settings.\n\nFor example, the inspection will be triggered if you set the line separator to `\\n` in\n[Settings \\| Editor \\| Code Style \\| Line separator](settings://preferences.sourceCode?Line%20separator),\nwhile the file you are editing uses `\\r\\n` as a line separator.\n\nThe inspection also warns you about mixed line separators within a file."
        },
        {
          "shortName": "RedundantSuppression",
          "displayName": "Redundant suppression",
          "enabled": false,
          "description": "Reports usages of the following elements that can be safely removed because the inspection they affect is no longer applicable in this context:\n\n* `@SuppressWarning` annotation, or\n* `// noinspection` line comment, or\n* `/** noinspection */` JavaDoc comment\n\nExample:\n\n\n    public class C {\n     // symbol is already private,\n     // but annotation is still around\n      @SuppressWarnings({\"WeakerAccess\"})\n     private boolean CONST = true;\n     void f() {\n        CONST = false;\n      }\n    }\n"
        },
        {
          "shortName": "ProblematicWhitespace",
          "displayName": "Problematic whitespace",
          "enabled": false,
          "description": "Reports the following problems:\n\n* Tabs used for indentation when the code style is configured to use only spaces.\n* Spaces used for indentation when the code style is configured to use only tabs.\n* Spaces used for indentation and tabs used for alignment when the code style is configured to use smart tabs."
        },
        {
          "shortName": "LongLine",
          "displayName": "Line is longer than allowed by code style",
          "enabled": false,
          "description": "Reports lines that are longer than the **Hard wrap at** parameter specified in [Settings \\| Editor \\| Code Style \\| General](settings://preferences.sourceCode?Hard%20wrap%20at)."
        },
        {
          "shortName": "IncorrectFormatting",
          "displayName": "Incorrect formatting",
          "enabled": false,
          "description": "Reports formatting issues that appear if your code doesn't\nfollow your project's code style settings.\n\n\nThis inspection is not compatible with languages that require\nthird-party formatters for code formatting, for example, Go or\nC with CLangFormat enabled."
        },
        {
          "shortName": "TodoComment",
          "displayName": "TODO comment",
          "enabled": false,
          "description": "Reports **TODO** comments in your code.\n\nYou can configure the format for **TODO** comments in [Settings \\| Editor \\| TODO](settings://preferences.toDoOptions).\nSince syntax highlighting for **TODO** comments is already provided,\nthis inspection is intended for use in batch mode or on a continuous integration server."
        },
        {
          "shortName": "EmptyDirectory",
          "displayName": "Empty directory",
          "enabled": false,
          "description": "Reports empty directories.\n\nAvailable only from **Code \\| Inspect Code** or\n**Code \\| Analyze Code \\| Run Inspection by Name** and isn't reported in the editor.\n\nUse the **Only report empty directories located under a source folder** option to have only directories under source\nroots reported."
        },
        {
          "shortName": "SyntaxError",
          "displayName": "Syntax error",
          "enabled": false,
          "description": "Reports syntax errors that have been found in the result of a batch code inspection run."
        },
        {
          "shortName": "Annotator",
          "displayName": "Annotator",
          "enabled": false,
          "description": "Reports problems that are found by language annotators in the result of a batch code inspection run."
        },
        {
          "shortName": "JavaAnnotator",
          "displayName": "Java annotator",
          "enabled": false,
          "description": "Allows viewing the problems reported by the Java annotator: compilation problems, unresolved by IDEA references, and so on."
        },
        {
          "shortName": "KotlinAnnotator",
          "displayName": "Kotlin annotator",
          "enabled": false,
          "description": "Allows viewing the problems reported by the Kotlin annotator: compilation problems, references unresolved by the IDE, and so on."
        },
        {
          "shortName": "QodanaServiceMessage",
          "displayName": "Qodana service message",
          "enabled": false,
          "description": "Reports the Qodana service messages such as suspending a particular inspection due to a large number of reported problems."
        }
      ]
    },
    {
      "name": "Javadoc",
      "inspections": [
        {
          "shortName": "DanglingJavadoc",
          "displayName": "Dangling Javadoc comment",
          "enabled": false,
          "description": "Reports Javadoc comments that don't belong to any class, method or field. The Javadoc tool ignores dangling Javadoc comments and doesn't include them in the HTML documentation it generates.\n\n**Example:**\n\n\n      class A {\n        /**\n         * Dangling comment\n         */\n        /**\n         * Method javadoc\n         */\n         public void m(){}\n      }\n\nA quick-fix is available to delete such comments completely or convert them into a block comment. After the quick-fix is applied:\n\n\n      class A {\n        /*\n          Dangling comment\n        */\n        /**\n         * Method javadoc\n         */\n        public void m(){}\n      }\n\nUse the **Ignore file header comment in JavaDoc format** option to ignore comments at the beginning of Java files.\nThese are usually copyright messages."
        },
        {
          "shortName": "JavadocHtmlLint",
          "displayName": "HTML problems in Javadoc (DocLint)",
          "enabled": false,
          "description": "Reports the same HTML issues in the Javadoc comments that have been reported by DocLint since Java 8.\n\nThe inspection detects the following issues:\n\n* Self-closed, unclosed, unknown, misplaced, or empty tag\n* Unknown or wrong attribute\n* Misplaced text\n\nExample:\n\n\n    /**\n     * Unknown tag: List<String>\n     * Unclosed tag: error</b>\n     * Misplaced text or tag: <ul><li>one</li>, <li>two</li></ul>\n     * Wrong or empty attribute: <a href=\"\"></a>\n     * Self-closed tag: <br/>\n     * ...\n     */\n    void sample(){ }\n"
        },
        {
          "shortName": "MissingPackageInfo",
          "displayName": "Missing 'package-info.java'",
          "enabled": false,
          "description": "Reports packages that contain classes but do not contain the `package-info.java` or `package.html` files and are, thus, missing the package documentation.\n\nThe quick-fix creates an initial `package-info.java` file."
        },
        {
          "shortName": "HtmlTagCanBeJavadocTag",
          "displayName": "'<code>...</code>' can be replaced with '{@code ...}'",
          "enabled": false,
          "description": "Reports usages of `<code>` tags in Javadoc comments. Since Java 5, these tags can be replaced with `{@code ...}` constructs. This allows using angle brackets `<` and `>` inside the comment instead of HTML character entities.\n\n**Example:**\n\n\n      /**\n       * @return empty <code>ArrayList&lt;Integer&gt;</code>\n       */\n      List<Integer> getList(){ ... }\n\nAfter the quick-fix is applied:\n\n\n      /**\n       * @return empty {@code ArrayList<Integer>}\n       */\n      List<Integer> getList(){ ... }\n"
        },
        {
          "shortName": "JavadocReference",
          "displayName": "Declaration has problems in Javadoc references",
          "enabled": false,
          "description": "Reports unresolved references inside Javadoc comments.\n\nIn the following example, the `someParam` parameter is missing, so it will be highlighted:\n\n\n    class A {\n        /**\n         * @param someParam description\n         **/\n        void foo() {\n        }\n    }\n\n\nDisable the **Report inaccessible symbols** option to ignore the tags that reference missing method parameters,\nclasses, fields and methods."
        },
        {
          "shortName": "JavadocLinkAsPlainText",
          "displayName": "Link specified as plain text",
          "enabled": false,
          "description": "Reports links specified as plain text in Javadoc comments.\n\n\nThe quick-fix suggests to wrap the link in \\<a\\> tag.\n\n**Example:**\n\n\n      class Main {\n       /**\n        * https://en.wikipedia.org/\n        */\n        void foo() {}\n      }\n\nAfter the quick-fix is applied:\n\n\n      class Main {\n       /**\n        * <a href=\"https://en.wikipedia.org/\">https://en.wikipedia.org/</a>\n        */\n        void foo() {}\n      }\n\nNew in 2022.1"
        },
        {
          "shortName": "MissingDeprecatedAnnotation",
          "displayName": "Missing '@Deprecated' annotation",
          "enabled": false,
          "description": "Reports module declarations, classes, fields, or methods that have the `@deprecated` Javadoc tag but do not have the `@java.lang.Deprecated` annotation.\n\n**Example:**\n\n\n      /**\n       * @deprecated use {@code example()} instead\n       */\n      void sample(){ }\n\nAfter the quick-fix is applied:\n\n\n      /**\n       * @deprecated use {@code example()} instead\n       */\n      @Deprecated\n      void sample(){ }\n\nThis inspection works only if the language level of the project or module is 5 or higher.\n\n\nUse the checkbox below to be warned on the symbols annotated with `@Deprecated` without\nan explanation in the `@deprecated` Javadoc tag."
        },
        {
          "shortName": "JavadocBlankLines",
          "displayName": "Blank line should be replaced with <p> to break lines",
          "enabled": false,
          "description": "Reports blank lines in Javadoc comments.\n\n\nBlank lines in Javadoc may signal an intention split the text to different paragraphs. However, the Javadoc tool and IntelliJ IDEA will\nignore them when rendering documentation comments.\n\n\nThe quick-fix suggests to replace the blank line with a paragraph tag (\\<p\\>).\n\n**Example:**\n\n\n      class Main {\n        /**\n         * Doesn't do anything.\n         *\n         * Does absolutely nothing\n         */\n        void foo() {}\n      }\n\nAfter the quick-fix is applied:\n\n\n      class Main {\n        /**\n         * Doesn't do anything.\n         * <p>\n         * Does absolutely nothing\n         */\n        void foo() {}\n      }\n\nNew in 2022.1"
        },
        {
          "shortName": "UnnecessaryJavaDocLink",
          "displayName": "Unnecessary Javadoc link",
          "enabled": false,
          "description": "Reports Javadoc `@see`, `{@link}`, and `{@linkplain}` tags that refer to the method owning the comment, the super method of the method owning the comment, or the class containing the comment.\n\nSuch links are unnecessary and can be safely removed with this inspection's quick-fix. The\nquick-fix will remove the entire Javadoc comment if the tag is its only content.\n\n**Example:**\n\n\n      class Example {\n        /**\n         * @see Example#method\n         */\n        public void method() { }\n      }\n\nAfter the quick-fix is applied:\n\n\n    class Example {\n      public void method() { }\n    }\n\n\nUse the checkbox below to ignore inline links (`{@link}` and `{@linkplain}`)\nto super methods. Although a link to all super methods is automatically added by the\nJavadoc tool, an inline link to the super method may sometimes be needed in texts of the Javadoc comments."
        },
        {
          "shortName": "UnnecessaryInheritDoc",
          "displayName": "Unnecessary '{@inheritDoc}' Javadoc comment",
          "enabled": false,
          "description": "Reports Javadoc comments that contain only an `{@inheritDoc}` tag. Since Javadoc copies the super class' comment if no comment is present, a comment containing only `{@inheritDoc}` adds nothing.\n\nAlso, it reports the `{@inheritDoc}` usages in invalid locations, for example, in fields.\n\nSuggests removing the unnecessary Javadoc comment.\n\n**Example:**\n\n\n      class Example implements Comparable<Example> {\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public int compareTo(Example o) {\n          return 0;\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      class Example implements Comparable<Example> {\n        @Override\n        public int compareTo(Example o) {\n          return 0;\n        }\n      }\n"
        },
        {
          "shortName": "JavadocDeclaration",
          "displayName": "Javadoc declaration problems",
          "enabled": false,
          "description": "Reports Javadoc comments and tags with the following problems:\n\n* invalid tag names\n* incomplete tag descriptions\n* duplicated tags\n* missing Javadoc descriptions\n\nExample:\n\n\n      /**\n       * Invalid tag name\n       * @poram param description\n       */\n      public void sample(int param){\n      }\n\nExample:\n\n\n      /**\n       * Pointing to itself {@link #sample(int)}\n       */\n      public void sample(int param){\n      }\n\nQuick-fix adds the unknown Javadoc tag to the list of user defined additional tags.\n\nUse textfield below to define additional Javadoc tags.\n\nUse first checkbox to ignore duplicated 'throws' tag.\n\nUse second checkbox to ignore problem with missing or incomplete first sentence in the description.\n\nUse third checkbox to ignore references pointing to itself."
        },
        {
          "shortName": "PackageDotHtmlMayBePackageInfo",
          "displayName": "'package.html' may be converted to 'package-info.java'",
          "enabled": false,
          "description": "Reports any `package.html` files which are used for documenting packages.\n\nSince JDK 1.5, it is recommended that you use `package-info.java` files instead, as such\nfiles can also contain package annotations. This way, package-info.java becomes a\nsole repository for package level annotations and documentation.\n\nExample: `package.html`\n\n\n    <html>\n      <body>\n        Documentation example.\n      </body>\n    </html>\n\nAfter the quick-fix is applied: `package-info.java`\n\n\n    /**\n     * Documentation example.\n     */\n    package com.sample;\n"
        },
        {
          "shortName": "PackageInfoWithoutPackage",
          "displayName": "'package-info.java' without 'package' statement",
          "enabled": false,
          "description": "Reports `package-info.java` files without a `package` statement.\n\n\nThe Javadoc tool considers such files documentation for the default package even when the file is located somewhere else."
        },
        {
          "shortName": "MissingJavadoc",
          "displayName": "Missing Javadoc",
          "enabled": false,
          "description": "Reports missing Javadoc comments and tags.\n\nExample:\n\n\n      /**\n       * Missing \"@param\" is reported (if configured).\n       */\n      public void sample(int param){\n      }\n\nThe quick-fixes add missing tag or missing Javadoc comment:\n\n\n      /**\n       * Missing \"@param\" is reported (if configured).\n       * @param param\n       */\n      public void sample(int param){\n      }\n\n\nInspection can be configured to ignore deprecated elements or simple accessor methods like `getField()` or `setField()`.\nYou can also use options below to configure required tags and minimal required visibility for the specific code elements like method, field, class, package, module."
        }
      ]
    },
    {
      "name": "Resource management",
      "inspections": [
        {
          "shortName": "HibernateResource",
          "displayName": "Hibernate resource opened but not safely closed",
          "enabled": false,
          "description": "Reports calls to the `openSession()` method if the returned `org.hibernate.Session` resource is not safely closed.\n\n\nBy default, the inspection assumes that the resources can be closed by any method with\n'close' or 'cleanup' in its name.\n\n**Example:**\n\n\n      void doHibernateQuery(SessionFactory factory) {\n        Session session = factory.openSession(); //warning\n        session.createQuery(\"...\");\n      }\n\n\nUse the following options to configure the inspection:\n\n* Whether a `org.hibernate.Session` resource is allowed to be opened inside a `try` block. This style is less desirable because it is more verbose than opening a resource in front of a `try` block.\n* Whether the resource can be closed by any method call with the resource passed as argument."
        },
        {
          "shortName": "SocketResource",
          "displayName": "Socket opened but not safely closed",
          "enabled": true,
          "description": "Reports socket resources that are not safely closed. Socket resources reported by this inspection include `java.net.Socket`, `java.net.DatagramSocket`, and `java.net.ServerSocket`.\n\n\nBy default, the inspection assumes that the resources can be closed by any method with\n'close' or 'cleanup' in its name.\n\n**Example:**\n\n\n      byte[] getMessage(ServerSocket socket) throws IOException {\n        Socket client = socket.accept(); //socket is not closed\n        return client.getInputStream().readAllBytes();\n      }\n\n\nUse the following options to configure the inspection:\n\n* Whether a socket is allowed to be opened inside a `try` block. This style is less desirable because it is more verbose than opening a resource in front of a `try` block.\n* Whether the resource can be closed by any method call with the resource passed as argument."
        },
        {
          "shortName": "IOResource",
          "displayName": "I/O resource opened but not safely closed",
          "enabled": true,
          "description": "Reports I/O resources that are not safely closed. I/O resources checked by this inspection include `java.io.InputStream`, `java.io.OutputStream`, `java.io.Reader`, `java.io.Writer`, `java.util.zip.ZipFile`, `java.io.Closeable` and `java.io.RandomAccessFile`.\n\n\nI/O resources wrapped by other I/O resources are not reported, as the wrapped resource will be closed by the wrapping resource.\n\n\nBy default, the inspection assumes that the resources can be closed by any method with\n'close' or 'cleanup' in its name.\n\n**Example:**\n\n\n      void save() throws IOException {\n        FileWriter writer = new FileWriter(\"filename.txt\"); //warning\n        writer.write(\"sample\");\n      }\n\n\nUse the following options to configure the inspection:\n\n* List I/O resource classes that do not need to be closed and should be ignored by this inspection.\n* Whether an I/O resource is allowed to be opened inside a `try`block. This style is less desirable because it is more verbose than opening a resource in front of a `try` block.\n* Whether the resource can be closed by any method call with the resource passed as argument."
        },
        {
          "shortName": "AutoCloseableResource",
          "displayName": "AutoCloseable used without 'try'-with-resources",
          "enabled": false,
          "description": "Reports `AutoCloseable` instances which are not used in a try-with-resources statement, also known as *Automatic Resource Management* .\n\n\nThis means that the \"open resource before/in `try`, close in `finally`\" style that had been used before\ntry-with-resources became available, is also reported.\nThis inspection is meant to replace all *opened but not safely closed* inspections when developing in Java 7 and higher.\n\n**Example:**\n\n\n      private static void foo() throws IOException {\n        InputStream profile = Thread.currentThread().getContextClassLoader().getResourceAsStream(\"/someFile\");\n        System.out.println(profile.read());\n      }\n\n\nUse the following options to configure the inspection:\n\n* List subclasses of `AutoCloseable` that do not need to be closed and should be ignored by this inspection.   \n  **Note** : The inspection will still report streams returned from the `java.nio.file.Files` methods `lines()`, `walk()`, `list()` and `find()`, even when `java.util.stream.Stream` is listed to be ignored. These streams contain an associated I/O resource that needs to be closed.\n* List methods returning `AutoCloseable` that should be ignored when called.\n* Whether to ignore an `AutoCloseable` if it is the result of a method call. When this option is enabled, the results of factory methods will also be ignored.\n* Whether the inspection should report if an `AutoCloseable` instance is passed as a method call argument. If this option is enabled, the inspection assumes the resource is closed in the called method. Method calls inside a `finally` block with 'close' in the name and an `AutoCloseable` argument will not be ignored.\n* Whether to ignore method references to constructors of resource classes.\n* Whether to ignore methods that return a resource and whose name starts with 'get'. This can reduce false positives because most of the getters do not transfer the ownership of the resource, and their call sites are not responsible for closing the resource."
        },
        {
          "shortName": "ChannelResource",
          "displayName": "'Channel' opened but not safely closed",
          "enabled": false,
          "description": "Reports `Channel` resources that are not safely closed, including any instances created by calling `getChannel()` on a file or socket resource.\n\n\nBy default, the inspection assumes that the resources can be closed by any method with\n'close' or 'cleanup' in its name.\n\n**Example:**\n\n\n      void send(Socket socket) throws IOException {\n        SocketChannel channel = socket.getChannel(); //warning\n        channel.write(ByteBuffer.wrap(\"message\".getBytes()));\n      }\n\n\nUse the following options to configure the inspection:\n\n* Whether a `Channel` resource is allowed to be opened inside a `try` block. This style is less desirable because it is more verbose than opening a `Channel` in front of a `try` block.\n* Whether the resource can be closed by any method call with the resource passed as argument."
        },
        {
          "shortName": "JDBCResource",
          "displayName": "JDBC resource opened but not safely closed",
          "enabled": false,
          "description": "Reports JDBC resources that are not safely closed. JDBC resources reported by this inspection include `java.sql.Connection`, `java.sql.Statement`, `java.sql.PreparedStatement`, `java.sql.CallableStatement`, and `java.sql.ResultSet`.\n\n\nBy default, the inspection assumes that the resources can be closed by any method with\n'close' or 'cleanup' in its name.\n\n**Example:**\n\n\n      ResultSet findAllElements(Connection connection) throws SQLException {\n        PreparedStatement statement = connection.prepareStatement(\"SELECT * FROM TABLE\");//statement is not closed\n        statement.execute();\n        return statement.getResultSet();\n      }\n\n\nUse the following options to configure the inspection:\n\n* Whether a JDBC resource is allowed to be opened inside a `try` block. This style is less desirable because it is more verbose than opening a resource in front of a `try` block.\n* Whether the resource can be closed by any method call with the resource passed as argument."
        },
        {
          "shortName": "JNDIResource",
          "displayName": "JNDI resource opened but not safely closed",
          "enabled": false,
          "description": "Reports JNDI resources that are not safely closed. JNDI resources reported by this inspection include `javax.naming.InitialContext`, and `javax.naming.NamingEnumeration`.\n\n\nBy default, the inspection assumes that the resources can be closed by any method with\n'close' or 'cleanup' in its name.\n\n**Example:**\n\n\n      Object findObject(Properties properties, String name) throws NamingException {\n        Context context = new InitialContext(properties); //context is not closed\n        return context.lookup(name);\n      }\n\n\nUse the following options to configure the inspection:\n\n* Whether a JNDI Resource is allowed to be opened inside a `try` block. This style is less desirable because it is more verbose than opening a resource in front of a `try` block.\n* Whether the resource can be closed by any method call with the resource passed as argument."
        },
        {
          "shortName": "DriverManagerGetConnection",
          "displayName": "Use of 'DriverManager' to get JDBC connection",
          "enabled": false,
          "description": "Reports any uses of `java.sql.DriverManager` to acquire a JDBC connection.\n\n\n`java.sql.DriverManager`\nhas been superseded by `javax.sql.Datasource`, which\nallows for connection pooling and other optimizations.\n\n**Example:**\n\n      Connection conn = DriverManager.getConnection(url, username, password);\n"
        }
      ]
    },
    {
      "name": "Code maturity",
      "inspections": [
        {
          "shortName": "SystemOutErr",
          "displayName": "Use of 'System.out' or 'System.err'",
          "enabled": false,
          "description": "Reports usages of `System.out` or `System.err`.\n\nSuch statements are often used for temporary debugging and should be either removed from the production code, or replaced by a more robust\nlogging facility."
        },
        {
          "shortName": "ObsoleteCollection",
          "displayName": "Use of obsolete collection type",
          "enabled": true,
          "description": "Reports usages of `java.util.Vector`, `java.util.Hashtable` and `java.util.Stack`.\n\nUsages of these classes can often be replaced with usages of\n`java.util.ArrayList`, `java.util.HashMap` and `java.util.ArrayDeque` respectively.\nWhile still supported,\nthe former classes were made obsolete by the JDK1.2 collection classes, and should probably\nnot be used in new development.\n\n\nUse the **Ignore obsolete collection types where they are required** option to ignore any cases where the obsolete collections are used\nas method arguments or assigned to a variable that requires the obsolete type.\nEnabling this option may consume significant processor resources."
        },
        {
          "shortName": "Deprecation",
          "displayName": "Deprecated API usage",
          "enabled": false,
          "description": "Reports usages of deprecated APIs (classes, fields, and methods), for example: `new Thread().stop();`.\n\nBy default, the inspection doesn't produce a warning if it's impossible or hard to avoid it. For example,\nthe following code won't be reported:\n\n\n      abstract class A { //library code\n         @Deprecated\n         abstract void m();\n      }\n      class B extends A { //project code\n         @Override\n         void m() {\n            //doSmth;\n         }\n      }\n\nConfigure the inspection:\n\n\nUse the inspection's options to disable this inspection inside deprecated members,\noverrides of abstract deprecated methods, non-static import statements, methods of deprecated classes, or same top-level classes."
        },
        {
          "shortName": "CommentedOutCode",
          "displayName": "Commented out code",
          "enabled": false,
          "description": "Reports comments that contain Java code.\n\nUsually, code that is commented out gets outdated very quickly and becomes misleading.\nAs most projects use some kind of version control system,\nit is better to delete commented out code completely and use the VCS history instead.\n\nNew in 2020.3"
        },
        {
          "shortName": "RedundantScheduledForRemovalAnnotation",
          "displayName": "Redundant @ScheduledForRemoval annotation",
          "enabled": false,
          "description": "Reports usages of `@ApiStatus.ScheduledForRemoval` annotation without `inVersion` attribute in code which targets Java 9 or newer version.\n\n\nSuch usages can be replaced by `forRemoval` attribute in `@Deprecated` annotation to simplify code.\n\nNew in 2022.1"
        },
        {
          "shortName": "MarkedForRemoval",
          "displayName": "Usage of API marked for removal",
          "enabled": true,
          "description": "Reports usages of deprecated APIs (classes, fields, and methods) that are marked for removal with `@Deprecated(`**forRemoval**`=true)`.\n\n\nThe code that uses an API marked for removal may cause a runtime error with a future version of the API. That is why\nthe recommended severity for this inspection is *Error*.\n\n\nYou can change the severity to *Warning* if you want to use the same code highlighting as in ordinary deprecation.\n\nNew in 2017.3"
        },
        {
          "shortName": "SuppressionAnnotation",
          "displayName": "Inspection suppression annotation",
          "enabled": false,
          "description": "Reports comments or annotations suppressing inspections.\n\nThis inspection can be useful when leaving suppressions intentionally for further review.\n\n**Example:**\n\n\n        @SuppressWarnings(\"unused\")\n        static Stream<String> stringProvider() {\n            return Stream.of(\"foo\", \"bar\");\n        }\n"
        },
        {
          "shortName": "ThrowablePrintStackTrace",
          "displayName": "Call to 'printStackTrace()'",
          "enabled": true,
          "description": "Reports calls to `Throwable.printStackTrace()` without arguments.\n\nSuch statements are often used for temporary debugging and should be either removed from the production code\nor replaced with a more robust logging facility."
        },
        {
          "shortName": "ThrowablePrintedToSystemOut",
          "displayName": "'Throwable' printed to 'System.out'",
          "enabled": true,
          "description": "Reports calls to `System.out.println()` with an exception as an argument.\n\nUsing print statements for logging exceptions hides the stack trace from you, which can complicate the investigation of the problem.\nIt is recommended that you use logger instead.\n\nCalls to `System.out.print()`, `System.err.println()`, and `System.err.print()` with an exception argument are also\nreported. It is better to use a logger to log exceptions instead.\n\nFor example, instead of:\n\n\n      try {\n          foo();\n      } catch (Exception e) {\n          System.out.println(e);\n      }\n\nuse the following code:\n\n\n      try {\n          foo();\n      } catch (Exception e) {\n          logger.warn(e); // logger call may be different\n      }\n"
        },
        {
          "shortName": "ThreadDumpStack",
          "displayName": "Call to 'Thread.dumpStack()'",
          "enabled": true,
          "description": "Reports usages of `Thread.dumpStack()`.\n\nSuch statements are often used for temporary debugging and should be either removed from the production code\nor replaced with a more robust logging facility."
        },
        {
          "shortName": "UseOfObsoleteDateTimeApi",
          "displayName": "Use of obsolete date-time API",
          "enabled": false,
          "description": "Reports usages of `java.util.Date`, `java.util.Calendar`, `java.util.GregorianCalendar`, `java.util.TimeZone`, and `java.util.SimpleTimeZone`.\n\nWhile still supported, these classes were made obsolete by the JDK8 Date-Time API and should probably\nnot be used in new development."
        },
        {
          "shortName": "DeprecatedIsStillUsed",
          "displayName": "Deprecated member is still used",
          "enabled": true,
          "description": "Reports deprecated classes, methods, and fields that are used in your code nonetheless.\n\nExample:\n\n\n      class MyCode {\n        @Deprecated\n        void oldMethod() {}// warning: \"Deprecated member is still used\"\n\n        void newMethod() {\n          oldMethod(); // forgotten usage\n        }\n      }\n\nUsages within deprecated elements are ignored.\n\n**NOTE:** Due to performance reasons, a non-private member is checked only when its name rarely occurs in the project."
        }
      ]
    },
    {
      "name": "Java 5",
      "inspections": [
        {
          "shortName": "RawUseOfParameterizedType",
          "displayName": "Raw use of parameterized class",
          "enabled": false,
          "description": "Reports generic classes with omitted type parameters. Such *raw* use of generic types is valid in Java, but it defeats the purpose of type parameters and may mask bugs. This inspection mirrors the `rawtypes` warning of `javac`.\n\n**Examples:**\n\n\n    //warning: Raw use of parameterized class 'List'\n    List list = new ArrayList<String>();\n    //list of strings was created but integer is accepted as well\n    list.add(1);\n\n\n    //no warning as it's impossible to provide type arguments during array creation\n    IntFunction<List<?>[]> fun = List[]::new;\n\nConfigure the inspection:\n\n* Use the **Ignore construction of new objects** option to ignore raw types used in object construction.\n* Use the **Ignore type casts** option to ignore raw types used in type casts.\n* Use the **Ignore where a type parameter would not compile** option to ignore the cases when a type parameter fails to compile (for example, when creating an array or overriding a library method).\n* Use the **Ignore parameter types of overriding methods** option to ignore type parameters used in parameters of overridden methods.\n* Use the **Ignore when automatic quick-fix is not available** option to ignore the cases when a quick-fix is not available.\nThis inspection only reports if the language level of the project or module is 5 or higher."
        },
        {
          "shortName": "BigDecimalLegacyMethod",
          "displayName": "'BigDecimal' legacy method called",
          "enabled": false,
          "description": "Reports calls to `BigDecimal.divide()` or `BigDecimal.setScale()` that use integer constants to specify the rounding mode. Since JDK 1.5, consider using methods that take the `RoundingMode` `enum` parameter instead.\n\n**Example:**\n\n    new BigDecimal(\"42\").setScale(2, BigDecimal.ROUND_FLOOR);\n\nAfter the quick-fix is applied:\n\n    new BigDecimal(\"42\").setScale(2, RoundingMode.FLOOR);\n"
        },
        {
          "shortName": "UnnecessaryBoxing",
          "displayName": "Unnecessary boxing",
          "enabled": false,
          "description": "Reports explicit boxing, that is wrapping of primitive values in objects.\n\nExplicit manual boxing is unnecessary as for Java 5 and later, and can safely be removed.\n\n**Examples:**\n\n* `Integer i = new Integer(1);`  `Integer i = Integer.valueOf(1);`\n* `int i = Integer.valueOf(1);`  `int i = 1;`\n\n\nUse the **Only report truly superfluously boxed expressions** option to report only truly superfluous boxing,\nwhere a boxed value is immediately unboxed either implicitly or explicitly.\nIn this case, the entire boxing-unboxing step can be removed. The inspection doesn't report simple explicit boxing.\n\nThis inspection only reports if the language level of the project or module is 5 or higher."
        },
        {
          "shortName": "CollectionsFieldAccessReplaceableByMethodCall",
          "displayName": "Reference to empty collection field can be replaced with method call",
          "enabled": false,
          "description": "Reports usages of `java.util.Collections` fields: `EMPTY_LIST`, `EMPTY_MAP` or `EMPTY_SET`. These field usages may be replaced with the following method calls: `emptyList()`, `emptyMap()`, or `emptySet()`. Such method calls prevent unchecked warnings by the compiler because the type parameters can be inferred.\n\n**Example:**\n\n\n      List<Integer> emptyList = Collections.EMPTY_LIST;\n\nAfter the quick-fix is applied:\n\n\n      List<Integer> emptyList = Collections.emptyList();\n\nThis inspection only reports if the language level of the project or module is 5 or higher."
        },
        {
          "shortName": "ForCanBeForeach",
          "displayName": "'for' loop can be replaced with enhanced for loop",
          "enabled": false,
          "description": "Reports `for` loops that iterate over collections or arrays, and can be automatically replaced with an enhanced `for` loop (foreach iteration syntax).\n\n**Example:**\n\n\n      for (Iterator<String> iterator = list.iterator(); iterator.hasNext(); ) {\n        String item = iterator.next();\n        System.out.println(item);\n      }\n\nAfter the quick-fix is applied:\n\n\n      for (String item : list) {\n        System.out.println(item);\n      }\n\n\nUse the **Report indexed 'java.util.List' loops** option to find loops involving `list.get(index)` calls.\nGenerally, these loops can be replaced with enhanced `for` loops,\nunless they modify an underlying list in the process, for example, by calling `list.remove(index)`.\nIf the latter is the case, the enhanced `for` loop may throw `ConcurrentModificationException`.\nAlso, in some cases, `list.get(index)` loops may work a little bit faster.\n\n\nUse the **Do not report iterations over untyped collections** option to ignore collections without type parameters.\nThis prevents the creation of enhanced `for` loop variables of the `java.lang.Object` type and the insertion of casts\nwhere the loop variable is used.\n\nThis inspection only reports if the language level of the project or module is 5 or higher."
        },
        {
          "shortName": "WhileCanBeForeach",
          "displayName": "'while' loop can be replaced with enhanced 'for' loop",
          "enabled": false,
          "description": "Reports `while` loops that iterate over collections and can be replaced with enhanced `for` loops (foreach iteration syntax).\n\n**Example:**\n\n\n      Iterator it = c.iterator();\n      while(it.hasNext()) {\n        Object obj = it.next();\n        System.out.println(obj);\n      }\n\nCan be replaced with:\n\n\n      for (Object obj : c) {\n        System.out.println(obj);\n      }\n\nThis inspection only reports if the language level of the project or module is 5 or higher."
        },
        {
          "shortName": "IndexOfReplaceableByContains",
          "displayName": "'String.indexOf()' expression can be replaced with 'contains()'",
          "enabled": false,
          "description": "Reports comparisons with `String.indexOf()` calls that can be replaced with a call to the `String.contains()` method.\n\n**Example:**\n\n\n      boolean b = \"abcd\".indexOf('e') >= 0;\n\nAfter the quick-fix is applied:\n\n\n      boolean b = \"abcd\".contains('e');\n\nThis inspection only reports if the language level of the project or module is 5 or higher."
        },
        {
          "shortName": "StringBufferReplaceableByStringBuilder",
          "displayName": "'StringBuffer' may be 'StringBuilder'",
          "enabled": false,
          "description": "Reports variables declared as `StringBuffer` and suggests replacing them with `StringBuilder`. `StringBuilder` is a non-thread-safe replacement for `StringBuffer`.\n\nThis inspection only reports if the language level of the project or module is 5 or higher."
        },
        {
          "shortName": "MethodCanBeVariableArityMethod",
          "displayName": "Method can have varargs parameter",
          "enabled": false,
          "description": "Reports methods that can be converted to variable arity methods.\n\n**Example:**\n\n\n      void process(String name, Object[] objects);\n\nAfter the quick-fix is applied:\n\n\n      void process(String name, Object... objects);\n\n\nThis inspection only reports if the language level of the project or module is 5 or higher."
        },
        {
          "shortName": "UnnecessaryUnboxing",
          "displayName": "Unnecessary unboxing",
          "enabled": false,
          "description": "Reports unboxing, that is explicit unwrapping of wrapped primitive values.\n\nUnboxing is unnecessary as for Java 5 and later, and can safely be removed.\n\n**Examples:**\n\n* `Integer i = Integer.valueOf(42).intValue();`  `Integer i = Integer.valueOf(42);`\n* `int k = Integer.valueOf(42).intValue();`  `int k = Integer.valueOf(42);`\n\n  (reports only when the **Only report truly superfluously unboxed expressions** option is not checked)\n\n\nUse the **Only report truly superfluously unboxed expressions** option to only report truly superfluous unboxing,\nwhere an unboxed value is immediately boxed either implicitly or explicitly.\nIn this case, the entire unboxing-boxing step can be removed. The inspection doesn't report simple explicit unboxing.\n\nThis inspection only reports if the language level of the project or module is 5 or higher."
        }
      ]
    },
    {
      "name": "Visibility",
      "inspections": [
        {
          "shortName": "PublicConstructorInNonPublicClass",
          "displayName": "'public' constructor in non-public class",
          "enabled": false,
          "description": "Reports all `public` constructors in non-`public` classes.\n\nUsually, there is no reason for creating a `public` constructor in a class with a lower access level.\nPlease note, however, that this inspection changes the behavior of some reflection calls. In particular,\n`Class.getConstructor()` won't be able to find the updated constructor\n(`Class.getDeclaredConstructor()` should be used instead). Do not use the inspection if your code\nor code of some used frameworks relies on constructor accessibility via `getConstructor()`."
        },
        {
          "shortName": "InnerClassVariableHidesOuterClassVariable",
          "displayName": "Inner class field hides outer class field",
          "enabled": false,
          "description": "Reports inner class fields named identically to a field of a surrounding class. As a result of such naming, you may accidentally use the field from the inner class when using the identically named field of a surrounding class is intended.\n\nA quick-fix is suggested to rename the inner class field.\n\n**Example:**\n\n\n      class Outer {\n        private String name;\n\n        class Inner {\n          private String name;\n        }\n      }\n\n\nUse the option to choose whether this inspection should report all name clashes,\nor only clashes with fields that are visible from the inner class."
        },
        {
          "shortName": "ClassEscapesItsScope",
          "displayName": "Non-accessible 'class' is exposed",
          "enabled": true,
          "description": "Reports usages of classes in a field or method signature when a class in a signature is less visible than the member itself. While legal Java, such members are useless outside of the visibility scope.\n\nExample:\n\n* `public` method which returns a `private` inner `class`.\n* `protected` field whose type is a package-local `class`.\n\n\nIn Java 9, a module may hide some of its classes by excluding their packages from export.\nSo, if the signature of exported API contains a non-exported class, such an API is useless outside of the module.\n\nConfigure the inspection:\n\n* Use the **Module's API exposes not exported classes (Java 9+)** option to report about the module API that exposes unexported classes.  \n  Note that the option works if the language level of the project or module is 9 or higher.\n* Use the **Public API exposes non-accessible classes** option to report about a public API that exposes non-accessible classes.\n* Use the **Package-local API exposes private classes** option to report about package-local API that exposes `private` classes."
        },
        {
          "shortName": "MethodOverloadsParentMethod",
          "displayName": "Possibly unintended overload of method from superclass",
          "enabled": true,
          "description": "Reports instance methods with the same name and the same number of parameters as a method in a superclass, but where at least one of the parameters is of a different incompatible type.\n\n\nIn this case, the method in a subclass will be overloading the method from the superclass\ninstead of overriding it. If it is unintended, it may result in latent bugs.\n\n**Example:**\n\n\n      public class Foo {\n        void foo(int x) {}\n      }\n\n      public class Bar extends Foo {\n        void foo(Number x) {} // Method 'foo()' overloads a compatible method of a superclass,\n                              // when overriding might have been intended\n      }\n\n\nUse the option to choose whether the inspection should also report cases where parameter types are not compatible."
        },
        {
          "shortName": "TypeParameterHidesVisibleType",
          "displayName": "Type parameter hides visible type",
          "enabled": true,
          "description": "Reports type parameters that have the same names as the visible types in the current scope. Such parameter names may be confusing.\n\nExample:\n\n\n      abstract class MyList<T> extends AbstractList<T> {\n        private List<T> elements;\n        // type parameter 'T' hides type parameter 'T'\n        public <T> T[] toArray(T[] array) {\n            return elements.toArray(array);\n        }\n    }\n"
        },
        {
          "shortName": "FieldHidesSuperclassField",
          "displayName": "Subclass field hides superclass field",
          "enabled": false,
          "description": "Reports fields in a derived class that are named identically a field of a superclass. Java fields cannot be overridden in derived classes, so the field in the derived class will hide the field from the superclass.\n\n\nAs a result of such naming, you may accidentally use the field of the derived class\nwhere the identically named field of a base class is intended.\n\nA quick-fix is suggested to rename the field in the derived class.\n\n**Example:**\n\n    class Parent {\n      Parent parent;\n    }\n    class Child extends Parent {\n      Child parent;\n    }\n\n\nYou can configure the following options for this inspection:\n\n1. **Ignore non-accessible fields** - indicates whether this inspection should report all name clashes, or only clashes with fields which are visible from the subclass.\n2. **Ignore static fields hiding static fields** - ignore `static` fields which hide `static` fields in base classes."
        },
        {
          "shortName": "MethodOverridesInaccessibleMethodOfSuper",
          "displayName": "Method overrides inaccessible method of superclass",
          "enabled": false,
          "description": "Reports methods with the same signature as an inaccessible method of a superclass, for example, a private method, or a package-private method of a superclass in another package.\n\n\nSuch method names may be confusing because the method in the subclass may look like an override when in fact\nit hides the inaccessible method of the superclass.\nMoreover, if the visibility of the method in the superclass changes later,\nit may either silently change the semantics of the subclass or cause a compilation error.\n\nA quick-fix is suggested to rename the method.\n\n**Example:**\n\n\n      public class Super {\n        private void test() {\n        }\n      }\n\n      public class Sub extends Super {\n        void test() { // making 'Super.test()' public causes a compilation error\n                      // making 'Super.test()' package-private makes 'Sub.test()' an override\n        }\n      }\n"
        },
        {
          "shortName": "MethodOverridesStaticMethod",
          "displayName": "Method tries to override 'static' method of superclass",
          "enabled": true,
          "description": "Reports `static` methods with a signature identical to a `static` method of a superclass. Such a method may look like an override when in fact it hides the method from the superclass because `static` methods in Java cannot be overridden.\n\n**Example:**\n\n\n      class Parent {\n        static void method(){}\n      }\n\n      class Example extends Parent {\n        static void method(){} //warning\n      }\n"
        },
        {
          "shortName": "AnonymousClassVariableHidesContainingMethodVariable",
          "displayName": "Anonymous class variable hides variable in containing method",
          "enabled": false,
          "description": "Reports fields in an anonymous class that are named identically to local variables or parameters of the containing method or lambda expression.\n\n\nAs a result of such naming, you may accidentally use the anonymous class field where\nthe identically named variable or parameter from the containing method is intended.\n\nA quick-fix is suggested to rename the field.\n\n**Example:**\n\n\n      class Test {\n        public Test(String value) {\n          Object foo = new Object() {\n            private String value = \"TEST\";\n            public void foo() {\n              System.out.println(value); //the field is accessed, not the parameter\n            }\n          };\n        }\n      }\n"
        },
        {
          "shortName": "Java9ModuleExportsPackageToItself",
          "displayName": "Module exports/opens package to itself",
          "enabled": true,
          "description": "Reports packages that are exported to, or opened in the same Java 9 module in which they are defined. The quick-fix removes such directives from `module-info.java`.\n\nExample:\n\n\n      module com.mycomp {\n        exports com.mycomp.main to com.mycomp;\n      }\n\nAfter the quick-fix is applied:\n\n\n      module main {\n      }\n\nThis inspection only reports if the language level of the project or module is 9 or higher."
        },
        {
          "shortName": "ParameterHidingMemberVariable",
          "displayName": "Parameter hides field",
          "enabled": false,
          "description": "Reports method parameters named identically to a field of a surrounding class. As a result of such naming, you may accidentally use the parameter when using the identically named field is intended.\n\nA quick-fix is suggested to rename the parameter.\n\n**Example:**\n\n\n      class Main {\n        private String value;\n\n        public Main(String value) {\n          value = value.toUpperCase();\n        }\n      }\n      \n\nYou can configure the following options for this inspection:\n\n1. **Ignore for property setters** - ignore parameters of simple setters.\n2. **Ignore superclass fields not visible from subclass** - ignore `private` fields in a superclass, which are not visible from the method.\n3. **Ignore for constructors** - ignore parameters of constructors.\n4. **Ignore for abstract methods** - ignore parameters of abstract methods.\n5. **Ignore for static method parameters hiding instance fields** - ignore parameters of `static` methods hiding an instance field and to ignore parameters of instance methods in static inner classes hiding an instance field of an outer class. While not strictly hiding, such parameters can still be confusing."
        },
        {
          "shortName": "AmbiguousFieldAccess",
          "displayName": "Access to inherited field looks like access to element from surrounding code",
          "enabled": false,
          "description": "Reports access to a superclass field from an anonymous, inner or local class, if a local variable, parameter, or field with the same name is available in the code surrounding the class. In this case it may seem that an element from the surrounding code is accessed, when in fact it is an access to a field from the superclass.\n\n\nTo clarify the intent of the code, it is recommended to add an explicit\n`super` qualifier to the field access.\n\n**Example:**\n\n\n        class First {\n          protected String ambiguous;\n        }\n        class Second {\n          void foo(String ambiguous) {\n            new First() {\n              {\n                System.out.println(ambiguous); // the field is accessed, not the parameter\n              }\n            };\n          }\n        }\n\nAfter the quick-fix is applied:\n\n\n        class First {\n          protected String ambiguous;\n        }\n        class Second {\n          void foo(String ambiguous) {\n            new First() {\n              {\n                System.out.println(super.ambiguous);\n              }\n            };\n          }\n        }\n"
        },
        {
          "shortName": "LambdaParameterHidingMemberVariable",
          "displayName": "Lambda parameter hides field",
          "enabled": false,
          "description": "Reports lambda parameters named identically to a field of a surrounding class. As a result of such naming, you may accidentally use the lambda parameter when using the identically named field is intended.\n\nA quick-fix is suggested to rename the lambda parameter.\n\n**Example:**\n\n\n      public class MyClass {\n        public Object foo;\n\n        void sort(List<Integer> list) {\n          list.sort((foo, bar) -> foo - bar);\n        }\n      }\n\n\nUse the option to choose whether to ignore fields that are not visible from the lambda expression.\nFor example, private fields of a superclass."
        },
        {
          "shortName": "LocalVariableHidingMemberVariable",
          "displayName": "Local variable hides field",
          "enabled": false,
          "description": "Reports local variables named identically a field of a surrounding class. As a result of such naming, you may accidentally use the variable where the identically named field is intended.\n\nA quick-fix is suggested to rename the variable.\n\n**Example:**\n\n\n      public class Foo {\n        public Object foo;\n\n        void bar() {\n          Object o = new Object() {\n            void baz() {\n              Object foo; // Local variable 'foo' hides field in class 'Foo'\n            }\n          };\n        }\n      }\n\n\nYou can configure the following options for this inspection:\n\n1. **Ignore non-accessible fields** - ignore local variables named identically to superclass fields that are not visible (for example, because they are private).\n2. **Ignore local variables in a static context hiding non-static fields** - for example when the local variable is inside a static method or inside a method which is inside a static inner class."
        },
        {
          "shortName": "AmbiguousMethodCall",
          "displayName": "Call to inherited method looks like call to local method",
          "enabled": false,
          "description": "Reports calls to a superclass method from an anonymous, inner or local class, if a method with the same signature exists in the code surrounding the class. In this case it may seem that a method from the surrounding code is called, when in fact it is a call to a method from the superclass.\n\n\nTo clarify the intent of the code, it is recommended to add an explicit\n`super` qualifier to the method call.\n\n**Example:**\n\n\n      class Parent {\n        void ambiguous(){}\n      }\n\n      class Example {\n        void ambiguous(){}\n\n        class Inner extends Parent {\n          void example(){\n            ambiguous(); //warning\n          }\n        }\n      }\n      \nAfter the quick-fix is applied:\n\n\n      class Parent {\n        void ambiguous(){}\n      }\n\n      class Example {\n        void ambiguous(){}\n\n        class Inner extends Parent {\n          void example(){\n            super.ambiguous();\n          }\n        }\n      }\n"
        },
        {
          "shortName": "Java9UndeclaredServiceUsage",
          "displayName": "Usage of service not declared in 'module-info'",
          "enabled": true,
          "description": "Reports situations in which a service is loaded with `java.util.ServiceLoader` but it isn't declared with the `uses` clause in the `module-info.java` file and suggests inserting it.\n\nNew in 2018.1"
        }
      ]
    },
    {
      "name": "Lombok",
      "inspections": [
        {
          "shortName": "SpringQualifierCopyableLombok",
          "displayName": "@Qualifier not copyable by lombok",
          "enabled": true,
          "description": "Reports Spring `@Qualifier` annotations on class fields that are ignored by the corresponding Lombok `@RequiredArgsConstructor` and `@AllArgsConstructor` annotations. The generated constructors will not receive the `@Qualifier` annotation without a `lombok.copyableAnnotations` definition inside the `lombok.config` file."
        },
        {
          "shortName": "Lombok",
          "displayName": "Lombok annotations",
          "enabled": true,
          "description": "Offers general inspections for Lombok annotations."
        },
        {
          "shortName": "DeprecatedLombok",
          "displayName": "Deprecated Lombok annotations",
          "enabled": true,
          "description": "Reports deprecated Lombok annotations and suggests quick-fixes to replace them with the ones promoted to the main package."
        }
      ]
    },
    {
      "name": "Redundant definitions",
      "inspections": [
        {
          "shortName": "RedundantSlf4jDefinition",
          "displayName": "@Slf4j",
          "enabled": true,
          "description": "Reports explicitly defined *Slf4j* Loggers. The `@Slf4j` annotation can be used instead."
        }
      ]
    },
    {
      "name": "Encapsulation",
      "inspections": [
        {
          "shortName": "ProtectedInnerClass",
          "displayName": "Protected nested class",
          "enabled": false,
          "description": "Reports `protected` nested classes.\n\n**Example:**\n\n\n      public class Outer {\n        protected static class Nested {} // warning\n        protected class Inner {}         // warning\n        protected enum Mode {}           // warning depends on the setting\n        protected interface I {}         // warning depends on the setting\n      }\n\nConfigure the inspection:\n\n* Use the **Ignore 'protected' inner enums** option to ignore `protected` inner enums.\n* Use the **Ignore 'protected' inner interfaces** option to ignore `protected` inner interfaces."
        },
        {
          "shortName": "PackageVisibleInnerClass",
          "displayName": "Package-visible nested class",
          "enabled": false,
          "description": "Reports nested classes that are declared without any access modifier (also known as package-private).\n\n**Example:**\n\n\n      public class Outer {\n        static class Nested {}  // warning\n        class Inner {}          // warning\n        enum Mode {}            // warning depends on the setting\n        interface I {}          // warning depends on the setting\n      }\n\nConfigure the inspection:\n\n* Use the **Ignore package-visible inner enums** option to ignore package-private inner enums.\n* Use the **Ignore package-visible inner interfaces** option to ignore package-private inner interfaces."
        },
        {
          "shortName": "PublicInnerClass",
          "displayName": "'public' nested class",
          "enabled": false,
          "description": "Reports `public` nested classes.\n\n**Example:**\n\n\n      public class Outer {\n        public static class Nested {} // warning\n        public class Inner {}         // warning\n        public enum Mode {}           // warning depends on the setting\n        public interface I {}         // warning depends on the setting\n      }\n\nConfigure the inspection:\n\n* Use the **Ignore 'public' inner enums** option to ignore `public` inner enums.\n* Use the **Ignore 'public' inner interfaces** option to ignore `public` inner interfaces."
        },
        {
          "shortName": "UseOfAnotherObjectsPrivateField",
          "displayName": "Accessing a non-public field of another object",
          "enabled": false,
          "description": "Reports accesses to `private` or `protected` fields of another object. Java allows access to such fields for objects of the same class as the current object but some coding styles discourage this use. Additionally, such direct access to `private` fields may fail in component-oriented architectures, such as Spring or Hibernate, that expect all access to other objects to be through method calls so the framework can mediate access using proxies.\n\n**Example:**\n\n\n      public class Base {\n        protected int bar;\n\n        void increment(Base base) {\n          bar++;\n          base.bar++; // warning: direct access to another object's non-public field\n        }\n      }\n\nA quick-fix to encapsulate the field is available.\n\nConfigure the inspection:\n\n* Use the **Ignore accesses from the same class** option to ignore access from the same class and only report access from inner or outer classes.\n\n  To ignore access from inner classes as well, use the nested **Ignore accesses from inner classes**.\n* Use the **Ignore accesses from 'equals()' method** to ignore access from an `equals()` method."
        },
        {
          "shortName": "PackageVisibleField",
          "displayName": "Package-visible field",
          "enabled": false,
          "description": "Reports fields that are declared without any access modifier (also known as package-private).\n\nConstants (that is, fields marked `static` and `final`) are not reported.\n\n**Example:**\n\n\n      public class A {\n        Object object;             // warning\n        final static int MODE = 0; // constant, no warning\n      }\n"
        },
        {
          "shortName": "ProtectedField",
          "displayName": "Protected field",
          "enabled": false,
          "description": "Reports `protected` fields.\n\nConstants (that is, variables marked `static` or `final`) are not reported.\n\n**Example:**\n\n\n      public class A {\n        protected Object object;              // warning\n        protected final static int MODE = 0;  // constant, no warning\n      }\n"
        },
        {
          "shortName": "PublicField",
          "displayName": "'public' field",
          "enabled": false,
          "description": "Reports `public` fields. Constants (fields marked with `static` and `final`) are not reported.\n\n**Example:**\n\n\n      class Main {\n        public String name;\n      }\n\nAfter the quick-fix is applied:\n\n\n      class Main {\n        private String name;\n\n        public String getName() {\n            return name;\n        }\n\n        public void setName(String name) {\n            this.name = name;\n        }\n      }\n\nConfigure the inspection:\n\n* Use the **Ignore If Annotated By** list to specify annotations to ignore. The inspection will ignore fields with any of these annotations.\n* Use the **Ignore 'public final' fields of an enum** option to ignore `public final` fields of the `enum` type."
        },
        {
          "shortName": "AssignmentOrReturnOfFieldWithMutableType",
          "displayName": "Assignment or return of field with mutable type",
          "enabled": false,
          "description": "Reports return of, or assignment from a method parameter to an array or a mutable type like `Collection`, `Date`, `Map`, `Calendar`, etc.\n\nBecause such types are mutable, this construct may\nresult in unexpected modifications of an object's state from outside the owning class. Although this construct may be useful for\nperformance reasons, it is inherently prone to bugs.\n\nThe following mutable types are reported:\n\n* `java.util.Date`\n* `java.util.Calendar`\n* `java.util.Collection`\n* `java.util.Map`\n* `com.google.common.collect.Multimap`\n* `com.google.common.collect.Table`\n\nThe quick-fix adds a call to the field's `.clone()` method.\n\n**Example:**\n\n\n      class Log {\n        String[] messages;\n        ...\n\n        String[] getMessages() {\n          return messages; // warning: Return of String[] field 'messages'\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      class Log {\n        String[] messages;\n        ...\n\n        String[] getMessages() {\n          return messages.clone();\n        }\n      }\n\nUse the **Ignore assignments in and returns from private methods** option to ignore assignments and returns in `private` methods."
        }
      ]
    },
    {
      "name": "Concurrency annotation issues",
      "inspections": [
        {
          "shortName": "StaticGuardedByInstance",
          "displayName": "Static member guarded by instance field or this",
          "enabled": false,
          "description": "Reports `@GuardedBy` annotations on `static` fields or methods in which the guard is either a non-static field or `this`.\n\nGuarding a static element with a non-static element may result in\nexcessive concurrency, multiple threads may be able to access the guarded field simultaneously by locking in different object contexts.\n\nExample:\n\n\n        private ReadWriteLock lock = new ReentrantReadWriteLock();\n\n        @GuardedBy(\"lock\")\n        public static void bar() {\n            // ...\n        }\n\nSupported `@GuardedBy` annotations are:\n\n* `net.jcip.annotations.GuardedBy`\n* `javax.annotation.concurrent.GuardedBy`\n* `org.apache.http.annotation.GuardedBy`\n* `com.android.annotations.concurrency.GuardedBy`\n* `androidx.annotation.GuardedBy`\n* `com.google.errorprone.annotations.concurrent.GuardedBy`"
        },
        {
          "shortName": "NonFinalFieldInImmutable",
          "displayName": "Non-final field in '@Immutable' class",
          "enabled": false,
          "description": "Reports any non-final field in a class with the `@Immutable` annotation. This violates the contract of the `@Immutable` annotation.\n\nExample:\n\n\n      import javax.annotation.concurrent.Immutable;\n      @Immutable\n      class Foo {\n        String bar = \"foo\";\n      }\n\nSupported `@GuardedBy` annotations are:\n\n* `net.jcip.annotations.GuardedBy`\n* `javax.annotation.concurrent.GuardedBy`\n* `org.apache.http.annotation.GuardedBy`\n* `com.android.annotations.concurrency.GuardedBy`\n* `androidx.annotation.GuardedBy`\n* `com.google.errorprone.annotations.concurrent.GuardedBy`"
        },
        {
          "shortName": "InstanceGuardedByStatic",
          "displayName": "Instance member guarded by static field",
          "enabled": false,
          "description": "Reports `@GuardedBy` annotations on instance fields or methods in which the guard is a `static` field. Guarding a non-static by a static may result in excessive lock contention, as access to each locked field in any object instance will prevent simultaneous access to that field in every object instance.\n\nExample:\n\n\n        private static ReadWriteLock lock = new ReentrantReadWriteLock(); //static guarding field\n        private Object state;\n\n        @GuardedBy(\"lock\")\n        public void bar() {\n            state = new Object();\n        }\n\nSupported `@GuardedBy` annotations are:\n\n* `net.jcip.annotations.GuardedBy`\n* `javax.annotation.concurrent.GuardedBy`\n* `org.apache.http.annotation.GuardedBy`\n* `com.android.annotations.concurrency.GuardedBy`\n* `androidx.annotation.GuardedBy`\n* `com.google.errorprone.annotations.concurrent.GuardedBy`"
        },
        {
          "shortName": "NonFinalGuard",
          "displayName": "Non-final '@GuardedBy' field",
          "enabled": false,
          "description": "Reports `@GuardedBy` annotations in which the guarding field is not `final`.\n\nGuarding on a non-final field may result in unexpected race conditions, as locks will\nbe held on the value of the field (which may change), rather than the field itself.\n\nExample:\n\n\n        private ReadWriteLock lock = new ReentrantReadWriteLock(); //not final guarding field\n        private Object state;\n\n        @GuardedBy(\"lock\")\n        public void bar() {\n            state = new Object();\n        }\n\nSupported `@GuardedBy` annotations are:\n\n* `net.jcip.annotations.GuardedBy`\n* `javax.annotation.concurrent.GuardedBy`\n* `org.apache.http.annotation.GuardedBy`\n* `com.android.annotations.concurrency.GuardedBy`\n* `androidx.annotation.GuardedBy`\n* `com.google.errorprone.annotations.concurrent.GuardedBy`"
        },
        {
          "shortName": "UnknownGuard",
          "displayName": "Unknown '@GuardedBy' field",
          "enabled": false,
          "description": "Reports `@GuardedBy` annotations in which the specified guarding field is unknown.\n\nExample:\n\n\n        private Object state;\n\n        @GuardedBy(\"lock\") //unknown guard reference\n        public void bar() {\n            state = new Object();\n        }\n\nSupported `@GuardedBy` annotations are:\n\n* `net.jcip.annotations.GuardedBy`\n* `javax.annotation.concurrent.GuardedBy`\n* `org.apache.http.annotation.GuardedBy`\n* `com.android.annotations.concurrency.GuardedBy`\n* `androidx.annotation.GuardedBy`\n* `com.google.errorprone.annotations.concurrent.GuardedBy`"
        },
        {
          "shortName": "FieldAccessNotGuarded",
          "displayName": "Unguarded field access or method call",
          "enabled": false,
          "description": "Reports accesses of fields declared as `@GuardedBy` that are not guarded by an appropriate synchronization structure.\n\nExample:\n\n\n        @GuardedBy(\"this\")\n        void x() {\n            notify();\n        }\n        void y() {\n            x(); // unguarded method call\n        }\n\nSupported `@GuardedBy` annotations are:\n\n* `net.jcip.annotations.GuardedBy`\n* `javax.annotation.concurrent.GuardedBy`\n* `org.apache.http.annotation.GuardedBy`\n* `com.android.annotations.concurrency.GuardedBy`\n* `androidx.annotation.GuardedBy`\n* `com.google.errorprone.annotations.concurrent.GuardedBy`"
        }
      ]
    },
    {
      "name": "JUnit",
      "inspections": [
        {
          "shortName": "TestCaseInProductCode",
          "displayName": "JUnit 'TestCase' in product source",
          "enabled": false,
          "description": "Reports JUnit 3 test classes in product source trees. This most likely indicates a programmer's error and can result in test code being shipped into production."
        },
        {
          "shortName": "MultipleExceptionsDeclaredOnTestMethod",
          "displayName": "Multiple exceptions declared on test method",
          "enabled": false,
          "description": "Reports JUnit test method `throws` clauses with more than one exception. Such clauses are unnecessarily verbose. Test methods will not be called from other project code, so there is no need to handle these exceptions separately.\n\nFor example:\n\n\n      @Test\n      public void testReflection() throws NoSuchMethodException,\n          InvocationTargetException, IllegalAccessException {\n        String result = (String) String.class.getMethod(\"trim\")\n            .invoke(\" hello \");\n        assertEquals(\"hello\", result);\n      }\n\nA quick fix is provided to replace the exception declarations with a single exception:\n\n\n      @Test\n      public void testReflection() throws Exception {\n        String result = (String) String.class.getMethod(\"trim\")\n            .invoke(\" hello \");\n        assertEquals(\"hello\", result);\n      }\n"
        },
        {
          "shortName": "MetaAnnotationWithoutRuntimeRetention",
          "displayName": "Test annotation without '@Retention(RUNTIME)' annotation",
          "enabled": false,
          "description": "Reports annotations with a `SOURCE` or `CLASS` retention policy that are supposed to be used by JUnit 5. Such annotations are not available at runtime and most probably their retention policy should be fixed to be accessible through reflection.\n\nNote that if the retention policy is not specified, then the default retention policy `CLASS` is used.\n\n**Example:**\n\n\n      @Testable\n      public @interface UnitTest {}\n\nAfter the quick-fix is applied:\n\n\n      @Retention(RetentionPolicy.RUNTIME)\n      @Testable\n      public @interface UnitTest {}\n"
        },
        {
          "shortName": "UnconstructableTestCase",
          "displayName": "Unconstructable JUnit 'TestCase'",
          "enabled": false,
          "description": "Reports JUnit test cases that are not `abstract` and do not expose a public `no-arg` constructor or a public constructor that takes a single string as an argument. Such test cases cannot be run by most JUnit test runners.\n\n**Example:**\n\n\n    public class MyTest {\n\n      private MyTest() {} // no-arg constructor is private\n\n      @Test\n      public void testSomething() {\n        assertEquals(1, 1);\n      }\n    }\n"
        },
        {
          "shortName": "ExpectedExceptionNeverThrown",
          "displayName": "Expected exception never thrown in test method body",
          "enabled": false,
          "description": "Reports checked exceptions expected by a JUnit 4 test-method that are never thrown inside the method body. Such test methods will never succeed.\n\n**Example:**\n\n\n      @Test(expected = CloneNotSupportedException.class)\n      public void testIt() {\n      }\n"
        },
        {
          "shortName": "TestCaseWithNoTestMethods",
          "displayName": "Test class with no tests",
          "enabled": false,
          "description": "Reports non-`abstract` test cases without any test methods.\n\nSuch test cases usually indicate unfinished code\nor could be a refactoring leftover that should be removed.\n\nExample:\n\n\n      public class CrucialTest {\n        @Before\n        public void setUp() {\n          System.out.println(\"setting up\");\n        }\n      }\n\nUse the **Ignore test cases which have superclasses with test methods** option to ignore test cases which have super classes\nwith test methods."
        },
        {
          "shortName": "UseOfObsoleteAssert",
          "displayName": "Usage of obsolete 'junit.framework.Assert' method",
          "enabled": false,
          "description": "Reports any calls to methods from the `junit.framework.Assert` class. This class is obsolete and the calls can be replaced by calls to methods from the `org.junit.Assert` class.\n\nFor example:\n\n\n      import org.junit.*;\n      public class NecessaryTest {\n        @Test\n        public void testIt() {\n          junit.framework.Assert.assertEquals(\"expected\", \"actual\");\n        }\n      }\n\nAfter the quick fix is applied, the result looks like the following:\n\n\n      import org.junit;\n      public class NecessaryTest {\n\n        public void testIt() {\n          Assert.assertEquals(\"expected\", \"actual\");\n        }\n      }\n"
        },
        {
          "shortName": "BeforeOrAfterIsPublicVoidNoArg",
          "displayName": "Malformed '@Before' or '@After' method",
          "enabled": false,
          "description": "Reports JUnit 4 `@Before` or `@After` methods that are not declared `public`, do not return `void`, or take arguments. Such methods are easy to create inadvertently, but they will not be executed by JUnit tests runners.\n\nThe inspection provides fixes for method signatures.\n\n**Example:**\n\n\n      @Before private int foo(int arg) { ... }\n\nAfter the quick-fix is applied:\n\n\n      @Before public void foo() { ... }\n"
        },
        {
          "shortName": "TestMethodWithoutAssertion",
          "displayName": "JUnit test method without any assertions",
          "enabled": false,
          "description": "Reports test methods that do not contain any assertions. Such methods may indicate either incomplete or weak test cases.\n\n**Example:**\n\n\n      public class ExtensiveTest {\n\n        @Test\n        public void testAlive() {\n          System.out.println(\"nothing\");\n        }\n      }\n\n\nConfigure the inspection:\n\n* Use the table to specify the combinations of fully qualified class name and method name regular expression that should qualify as assertions. Class names also match subclasses.\n* Use the **'assert' keyword is considered an assertion** option to specify if the Java `assert` statements using the `assert` keyword should be considered an assertion.\n* Use the **Ignore test methods which declare exceptions** option to ignore the test methods that declare exceptions. This can be useful when you have tests that will throw an exception on failure and thus don't need any assertions."
        },
        {
          "shortName": "StaticSuite",
          "displayName": "'suite()' method not declared 'static'",
          "enabled": false,
          "description": "Reports JUnit test case classes with `suite()` methods which aren't declared as `static`."
        },
        {
          "shortName": "JUnit3StyleTestMethodInJUnit4Class",
          "displayName": "Old style JUnit test method in JUnit 4 class",
          "enabled": false,
          "description": "Reports JUnit 3 style test methods that are located inside a class that does not extend the JUnit 3 `TestCase` class and contains JUnit 4 or JUnit 5 `@Test` annotated methods. Such test methods cannot be run."
        },
        {
          "shortName": "JUnit4AnnotatedMethodInJUnit3TestCase",
          "displayName": "JUnit 4 test method in class extending JUnit 3 TestCase",
          "enabled": false,
          "description": "Reports JUnit 4 `@Test` annotated methods inside the inheritor of `junit.framework.TestCase`. Mixing API of JUnit can lead to problems running the tests.\n\n**Example:**\n\n\n      public class MyTest extends TestCase {\n          @Test //name doesn't start from \"test\", thus would be ignored\n          public void wouldBeIgnored() {}\n      \n          @Test   //name starts from \"test\"\n          @Ignore //thus would be executed despite @Ignore annotation\n          public void testWouldBeExecuted() {}\n      }\n\n**Provided fixes:**\n\n* Remove the `@Ignore` annotation and rename the test method, so the name doesn't start with \"test\".\n* Convert a JUnit 3 test class to JUnit 4."
        },
        {
          "shortName": "AssertEqualsMayBeAssertSame",
          "displayName": "'assertEquals()' may be 'assertSame()'",
          "enabled": false,
          "description": "Reports JUnit `assertEquals()` calls that can be replaced with an equivalent `assertSame()` call. This is possible when the arguments are instances of a `final` class that does not override the `Object.equals()` method and makes it explicit that the object identity is compared.\n\nSuggests replacing `assertEquals()` with `assertSame()`.\n\n**Example:**\n\n\n      @Test\n      public void testObjectType() {\n        Object o = getObject();\n        Assert.assertEquals(String.class, o.getClass());\n      }\n\nAfter the quick fix is applied:\n\n\n      @Test\n      public void testSort() {\n        Object o = getObject();\n        Assert.assertSame(String.class, o.getClass());\n      }\n"
        },
        {
          "shortName": "TestCaseWithConstructor",
          "displayName": "JUnit TestCase with non-trivial constructors",
          "enabled": false,
          "description": "Reports JUnit test cases with initialization logic in their constructors. If a constructor fails, the `@After` annotated or `tearDown()` method won't be called. This can leave the test environment partially initialized, which can adversely affect other tests. Instead, initialization of JUnit test cases should be done in a `setUp()` or `@Before` annotated method.\n\nBad example:\n\n\n      public class ImportantTest {\n        private File file;\n        public ImportantTest() throws IOException {\n          file = File.createTempFile(\"xyz\", \".tmp\");\n        }\n\n        // ... tests go here\n      }\n"
        },
        {
          "shortName": "SuperTearDownInFinally",
          "displayName": "'super.tearDown()' not called from 'finally' block",
          "enabled": false,
          "description": "Reports calls of the JUnit 3's `super.tearDown()` method that are not performed inside a `finally` block. If there are other method calls in the `tearDown()` method that may throw an exception before the `super.tearDown()` call, this may lead to inconsistencies and leaks.\n\n**Example:**\n\n\n      public class AnotherTest extends CompanyTestCase {\n        private Path path;\n\n        @Override\n        protected void setUp() throws Exception {\n          super.setUp();\n          path = Files.createTempFile(\"abcde\", \".tmp\");\n        }\n\n        @Override\n        protected void tearDown() throws Exception {\n          Files.delete(path);\n          super.tearDown();\n        }\n      }\n\nImproved code:\n\n\n      public class AnotherTest extends CompanyTestCase {\n        private Path path;\n\n        @Override\n        protected void setUp() throws Exception {\n          super.setUp();\n          path = Files.createTempFile(\"abcde\", \".tmp\");\n        }\n\n        @Override\n        protected void tearDown() throws Exception {\n          try {\n            Files.delete(path);\n          } finally {\n            super.tearDown();\n          }\n        }\n      }\n"
        },
        {
          "shortName": "TestMethodInProductCode",
          "displayName": "JUnit test method in product source",
          "enabled": false,
          "description": "Reports methods annotated with the JUnit 4 or JUnit 5 `@Test` annotation that are located in production source trees. This most likely a mistake and can result in test code being shipped into production."
        },
        {
          "shortName": "AssertEqualsCalledOnArray",
          "displayName": "'assertEquals()' called on array",
          "enabled": false,
          "description": "Reports JUnit `assertEquals()` calls with arguments of an array type. Such methods compare the arrays' identities instead of the arrays' contents. Array contents should be checked with the `assertArrayEquals()` method.\n\n**Example:**\n\n\n      @Test\n      public void testSort() {\n        int[] actual = {248, 496, 0, 56};\n        Arrays.sort(actual);\n        Assert.assertEquals(new int[] {0, 56, 248, 496}, actual);\n      }\n\nAfter the quick-fix is applied:\n\n\n      @Test\n      public void testSort() {\n        int[] actual = {248, 496, 0, 56};\n        Arrays.sort(actual);\n        Assert.assertArrayEquals(new int[] {0, 56, 248, 496}, actual);\n      }\n"
        },
        {
          "shortName": "ParameterizedParametersStaticCollection",
          "displayName": "Parameterized test class without data provider method",
          "enabled": false,
          "description": "Reports JUnit 4 [parameterized test](https://github.com/junit-team/junit4/wiki/parameterized-tests) classes that are annotated with `@RunWith(Parameterized.class)` but either do not include a data provider method annotated with `@Parameterized.Parameters` or this method has an incorrect signature. Such test classes cannot be run. The data provider method should be `public` and `static` and have a return type of `Iterable` or `Object[]`.\n\nSuggests creating an empty parameter provider method or changing the signature of the incorrect data provider method.\n\n**Example:**\n\n\n\n      @RunWith(Parameterized.class)\n      public class ImportantTest {\n        private int input;\n        private int expected;\n\n        ImportantTest(int input, int expected) {\n          this.input = input;\n          this.expected = expected;\n        }\n\n        // ... test cases\n      }\n\nAfter the quick-fix is applied:\n\n\n      @RunWith(Parameterized.class)\n      public class ImportantTest {\n        private int input;\n        private int expected;\n\n        ImportantTest(int input, int expected) {\n          this.input = input;\n          this.expected = expected;\n        }\n\n        @Parameters\n        public static Iterable<Object[]> parameters() {\n          return null;\n        }\n\n        // ... test cases\n      }\n"
        },
        {
          "shortName": "BeforeClassOrAfterClassIsPublicStaticVoidNoArg",
          "displayName": "Malformed '@BeforeClass'/'@BeforeAll' or '@AfterClass'/'@AfterAll' method",
          "enabled": false,
          "description": "Reports JUnit 4.0 `@BeforeClass` or `@AfterClass` methods that are not declared `public` and `static`, do not return `void`, or take arguments. Such methods are easy to create inadvertently, but they will not be executed by JUnit tests runners.\n\n**Example:**\n\n\n      public class MainTest {\n        @BeforeClass\n        String beforeClass(int i) {\n        }\n      }\n\nAfter the quick-fix is applied, the method changes to:\n\n\n      class MainTest {\n        @BeforeClass\n        public static void beforeClass() {\n        }\n      }\n"
        },
        {
          "shortName": "JUnitDatapoint",
          "displayName": "Malformed '@DataPoint' field",
          "enabled": false,
          "description": "Reports fields or methods annotated with `@DataPoint` that are not `public` and/or not `static`. A [theories](https://github.com/junit-team/junit4/wiki/Theories) test class with a malformed `@DataPoint` member cannot be run.\n\nFor example:\n\n\n      @RunWith(Theories.class)\n      public class SeriousTest {\n        @DataPoint\n        private String dataPoint = \"value\";\n\n        @DataPoint(\"generated\")\n        private String generatedDataPoint() {\n          return \"generated value\";\n        }\n\n        @Theory\n        public void theoryMethod(String param) {\n          // ...\n        }\n      }\n\nA quick fix is provided to fix the modifiers:\n\n\n      @RunWith(Theories.class)\n      public class SeriousTest {\n        @DataPoint\n        public static String dataPoint = \"value\";\n\n        @DataPoint(\"generated\")\n        public static String generatedDataPoint() {\n          return \"generated value\";\n        }\n\n        @Theory\n        public void theoryMethod(String param) {\n          // ...\n        }\n      }\n"
        },
        {
          "shortName": "Junit4Converter",
          "displayName": "JUnit 3 test can be JUnit 4",
          "enabled": false,
          "description": "Reports JUnit 3 test classes that can be converted to JUnit 4 test classes.\n\n**Example:**\n\n\n      public class MainTestCase extends junit.framework.TestCase {\n        public void test() {\n          Assert.assertTrue(true);\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      public class MainTestCase {\n        @org.junit.Test\n        public void test() {\n          Assert.assertTrue(true);\n        }\n      }\n\nThis inspection only reports if the language level of the project or module is 5 or higher, and JUnit 4 is available on the classpath."
        },
        {
          "shortName": "TestMethodIsPublicVoidNoArg",
          "displayName": "Malformed test method",
          "enabled": false,
          "description": "Reports any JUnit test methods that are declared `static`, not declared `public`, do not return `void`, or have parameters. Such test methods are easy to create inadvertently, but they will not be executed by JUnit test runners.\n\n**Example:**\n\n\n      @Test\n      void test() {\n        assertEquals(1, 1);\n      }\n\nAfter the quick-fix is applied:\n\n\n      @Test\n      public void test() {\n        assertEquals(1, 1);\n      }\n\nUse the inspection options to specify annotations.\nAny parameter annotated with one of these annotations will not be reported."
        },
        {
          "shortName": "IgnoredJUnitTest",
          "displayName": "JUnit test annotated with '@Ignore'/'@Disabled'",
          "enabled": false,
          "description": "Reports usages of JUnit 4's `@Ignore` or JUnit 5's `@Disabled` annotations. It is considered a code smell to have tests annotated with these annotations for a long time, especially when no reason is specified.\n\n**Example:**\n\n\n      @Ignore\n      public class UrgentTest {\n\n        @Test\n        public void testIt() {\n          Assert.assertEquals(\"expected\", \"actual\");\n        }\n      }\n\n\nConfigure the inspection:\n\n* Use the **Only report annotations without reason** option to only report the cases when no reason is specified as the annotation's `value` attribute."
        },
        {
          "shortName": "MalformedSetUpTearDown",
          "displayName": "Malformed 'setUp()' or 'tearDown()' method",
          "enabled": false,
          "description": "Reports JUnit 3 `setUp()` or `tearDown()` methods that either are not declared `public`, do not return `void`, or take arguments. Such `setUp()` or `tearDown()` methods are most likely created unintentionally, and will not be executed by JUnit test runners.\n\nFor example:\n\n\n      public class WeightyTest extends TestCase {\n        private File file;\n        private int setUp(String prefix) throws IOException {\n          file = File.createTempFile(prefix, \".tmp\");\n          return 0;\n        }\n\n        // ... tests go here\n      }\n"
        },
        {
          "shortName": "MigrateAssertToMatcherAssert",
          "displayName": "JUnit assertion can be 'assertThat()' call",
          "enabled": false,
          "description": "Reports calls to `Assert.assertEquals()`, `Assert.assertTrue()`, etc. methods which can be migrated to Hamcrest declarative style `Assert.assertThat()` calls.\n\nFor example:\n\n\n      public class SubstantialTest {\n        @Test\n        public void testContents(Collection<String> c, String s) {\n          Assert.assertTrue(c.contains(s));\n          Assert.assertEquals(c, s);\n          Assert.assertNotNull(c);\n          Assert.assertNull(c);\n          Assert.assertFalse(c.contains(s));\n        }\n      }\n\nA quick-fix is provided to perform the migration:\n\n\n      public class SubstantialTest {\n        @Test\n        public void testContents(Collection<String> c, String s) {\n          assertThat(c, hasItem(o));\n          assertThat(o, is(c));\n          assertThat(c, notNullValue());\n          assertThat(c, nullValue());\n          assertThat(c, not(hasItem(o)));\n        }\n      }\n\nThis inspection requires that the Hamcrest library is available on the classpath.\n\nUse the **Statically import matcher's methods** option to specify if you want the quick-fix to statically import the Hamcrest matcher methods."
        },
        {
          "shortName": "JUnit5MalformedExtensions",
          "displayName": "JUnit 5 malformed extension registration",
          "enabled": false,
          "description": "Reports fields annotated with `@RegisterExtension` which have a wrong type or are not declared as static when it's required. Such extensions won't be registered correctly and could lead to test startup failures.\n\n**Example:**\n\n\n      public class MyTest {\n        @RegisterExtension\n        private JUnit4Rule rule;\n      }\n"
        },
        {
          "shortName": "JUnit5MalformedNestedClass",
          "displayName": "JUnit 5 malformed '@Nested' class",
          "enabled": false,
          "description": "Reports `static` inner classes annotated with `@Nested`.\n\nThe `@Nested` annotation cannot be used on `static` classes."
        },
        {
          "shortName": "JUnit5MalformedRepeated",
          "displayName": "JUnit 5 malformed repeated test",
          "enabled": false,
          "description": "Reports the following problems with JUnit 5 `@RepeatedTest`:\n\n* `@Test` and `@RepeatedTest` are used on the same method. Even though it is allowed to use them, they have no additional effect together.\n* `RepetitionInfo` parameter is used in the `@BeforeAll` and `@AfterAll` methods. The parameter is not injected in these methods.\n* `RepetitionInfo` parameter is used in the `@BeforeEach` and `@AfterEach` methods in classes with `@Test` methods. In this case, the parameter won't be injected in `@Test` methods."
        },
        {
          "shortName": "Junit5MalformedParameterized",
          "displayName": "Malformed parameterized tests",
          "enabled": false,
          "description": "Reports parameterized tests that have malformed sources:\n\n* `MethodSource` has an unknown target or the method is not static, `no-arg`.\n* `ValueSource` and `EnumSource` types cannot be converted to method parameters.\n* No sources are defined.\n\nExample:\n\n\n      class Test {\n        @MethodSource(\"parameters\")\n        @ParameterizedTest\n        void foo(String param) {}\n      }\n\nAfter the quick-fix is applied:\n\n\n      class Test {\n        private static Stream<Arguments> parameters() {\n            return Stream.empty();\n        }\n\n        @MethodSource(\"parameters\")\n        @ParameterizedTest\n        void foo(String param) {}\n      }\n"
        }
      ]
    },
    {
      "name": "Java 8",
      "inspections": [
        {
          "shortName": "StaticPseudoFunctionalStyleMethod",
          "displayName": "Pseudo-functional expression using static class",
          "enabled": false,
          "description": "Reports usages of pseudo-functional code if `Java Stream API` is available.\n\nThough `guava Iterable API` provides functionality similar to `Java Streams API`, it's slightly different and\nmay miss some features.\nEspecially, primitive-specialized stream variants like `IntStream` are more performant than generic variants.\n\n**Example:**\n\n\n    List<String> transformedIterable = Iterables.transform(someList, someTransformFunction);//warning: Pseudo functional style code\n\nAfter the quick-fix is applied:\n\n    List<String> transformedIterable = someList.stream().map(someTransformFunction).collect(Collectors.toList());\n\n\n**Note:** Code semantics can be changed; for example, guava's `Iterable.transform` produces a lazy-evaluated iterable,\nbut the replacement is eager-evaluated.\n\n\nUse the **Static method calls translated to the 'Stream' API** option\nto configure static method calls that should be translated to the `stream` API.\n\nThis inspection only reports if the language level of the project or module is 8 or higher."
        },
        {
          "shortName": "AnonymousHasLambdaAlternative",
          "displayName": "Anonymous type has shorter lambda alternative",
          "enabled": false,
          "description": "Reports anonymous classes which could be transformed to a constructor or a factory method call with a lambda expression argument.\n\nThe following classes are reported by this inspection:\n\n* Anonymous classes extending `ThreadLocal` which have an `initialValue()` method (can be replaced with `ThreadLocal.withInitial`)\n* Anonymous classes extending `Thread` which have a `run()` method (can be replaced with `new Thread(Runnable)`\n\nExample:\n\n\n      new Thread() {\n        @Override\n        public void run() {\n          System.out.println(\"Hello from thread!\");\n        }\n      }.start();\n\nAfter the quick-fix is applied:\n\n\n      new Thread(() -> {\n        System.out.println(\"Hello from thread!\");\n      }).start();\n"
        },
        {
          "shortName": "Java8ListReplaceAll",
          "displayName": "Loop can be replaced with 'List.replaceAll()'",
          "enabled": false,
          "description": "Reports loops which can be collapsed into a single `List.replaceAll()` call.\n\n**Example:**\n\n\n      for (int i = 0; i < strings.size(); i++) {\n        String str = strings.get(i).toLowerCase();\n        strings.set(i, str);\n      }\n\nAfter the quick-fix is applied:\n\n\n      strings.replaceAll(String::toLowerCase);\n\n\nThis inspection only reports if the language level of the project or module is 8 or higher.\n\nNew in 2022.1"
        },
        {
          "shortName": "FoldExpressionIntoStream",
          "displayName": "Expression can be folded into Stream chain",
          "enabled": false,
          "description": "Reports expressions with a repeating pattern which could be replaced with *Stream API* or `String.join()`.\n\nExample:\n\n\n      boolean allStartWith(String a, String b, String c, String d, String prefix) {\n        return a.startsWith(prefix) && b.startsWith(prefix) && c.startsWith(prefix) && d.startsWith(prefix);\n      }\n\nAfter the quick-fix is applied:\n\n\n      boolean foo(String a, String b, String c, String d, String prefix) {\n        return Stream.of(a, b, c, d).allMatch(s -> s.startsWith(prefix));\n      }\n\nExample:\n\n\n      String joinAll(String a, String b, String c, String d) {\n        return a + \",\" + b + \",\" + c + \",\" + d;\n      }\n\nAfter the quick-fix is applied:\n\n\n      String joinAll(String a, String b, String c, String d) {\n        return String.join(\",\", a, b, c, d);\n      }\n\nThis inspection only reports if the language level of the project or module is 8 or higher.\n\nNew in 2018.2"
        },
        {
          "shortName": "Convert2streamapi",
          "displayName": "Loop can be collapsed with Stream API",
          "enabled": false,
          "description": "Reports loops which can be replaced with stream API calls using lambda expressions.\n\nSuch a replacement changes the style from imperative to more functional and makes the code more compact.\n\nExample:\n\n\n      boolean check(List<String> data) {\n        for (String e : data) {\n          String trimmed = e.trim();\n          if (!trimmed.startsWith(\"xyz\")) {\n            return false;\n          }\n        }\n        return true;\n      }\n\nAfter the quick-fix is applied:\n\n\n      boolean check(List<String> data) {\n        return data.stream().map(String::trim).allMatch(trimmed -> trimmed.startsWith(\"xyz\"));\n      }\n\nThis inspection only reports if the language level of the project or module is 8 or higher."
        },
        {
          "shortName": "LambdaCanBeMethodCall",
          "displayName": "Lambda can be replaced with method call",
          "enabled": false,
          "description": "Reports lambda expressions which can be replaced with a JDK method call.\n\nFor example, the expression `x -> x` of the `Function<T, T>` type\ncan be replaced with the `Function.identity()` call.\n\nNew in 2017.1"
        },
        {
          "shortName": "Anonymous2MethodRef",
          "displayName": "Anonymous type can be replaced with method reference",
          "enabled": false,
          "description": "Reports anonymous classes which can be replaced with method references.\n\n\nNote that if an anonymous class is converted into an unbound method reference, the same method reference object\ncan be reused by the Java runtime during subsequent invocations. On the other hand, when an anonymous class is used,\nseparate objects are created every time. Thus, applying the quick-fix can cause the semantics change in rare cases,\ne.g. when anonymous class instances are used as `HashMap` keys.\n\n**Example:**\n\n\n        Runnable r = new Runnable() {\n          @Override\n          public void run() {\n            System.out.println();\n          }\n        };\n\nThe quick-fix changes this code to the compact form: `Runnable r = System.out::println;`.\n\nUse the **Report when interface is not annotated with @FunctionalInterface** option to enable this inspection for\ninterfaces which are not annotated with @FunctionalInterface.\n\nThis inspection only reports if the language level of the project or module is 8 or higher."
        },
        {
          "shortName": "CodeBlock2Expr",
          "displayName": "Statement lambda can be replaced with expression lambda",
          "enabled": false,
          "description": "Reports lambda expressions with code block bodies when expression-style bodies can be used instead. The result of the conversion is shorter and more clear.\n\nExample:\n\n\n      Comparable<String> c = o -> {return 0;};\n\nAfter the quick-fix is applied:\n\n\n      Comparable<String> c = o -> 0;\n"
        },
        {
          "shortName": "SimplifyForEach",
          "displayName": "Simplifiable forEach() call",
          "enabled": false,
          "description": "Reports `forEach()` calls that can be replaced with a more concise method or from which intermediate steps can be extracted.\n\n**Example:**\n\n\n      List<String> findNStrings(List<String> list, int n) {\n        List<String> other = new ArrayList<>();\n        list.forEach(s -> {\n          if(s.length() > n) other.add(s);\n        });\n        return other;\n      }\n\nAfter the quick-fix is applied:\n\n\n      List<String> findNStrings(List<String> list, int n) {\n        List<String> other = list.stream()\n          .filter(s -> s.length() > n)\n          .collect(Collectors.toList());\n        return other;\n      }\n\nThis inspection only reports if the language level of the project or module is 8 or higher.\n\nNew in 2017.3"
        },
        {
          "shortName": "Guava",
          "displayName": "Guava's functional primitives can be replaced with Java",
          "enabled": false,
          "description": "Reports usages of Guava's functional primitives that can be migrated to standard Java API calls.\n\nFor example, the inspection reports usages of classes and interfaces like `FluentIterable`, `Optional`, `Function`,\n`Predicate`, or `Supplier`.\n\nExample:\n\n\n      ImmutableList<String> results = FluentIterable.from(List.of(1, 2, 3)).transform(Object::toString).toList();\n\nAfter the quick-fix is applied:\n\n\n      List<String> results = List.of(1, 2, 3).stream().map(Object::toString).collect(Collectors.toList());\n\n\nThe quick-fix may change the semantics. Some lazy-evaluated Guava's iterables can be transformed to eager-evaluated.\n\nThis inspection only reports if the language level of the project or module is 8 or higher."
        },
        {
          "shortName": "Java8ListSort",
          "displayName": "'Collections.sort()' can be replaced with 'List.sort()'",
          "enabled": false,
          "description": "Reports calls of `Collections.sort(list, comparator)` which can be replaced with `list.sort(comparator)`.\n\n`Collections.sort` is just a wrapper, so it is better to use an instance method directly.\n\nThis inspection only reports if the language level of the project or module is 8 or higher."
        },
        {
          "shortName": "ComparatorCombinators",
          "displayName": "'Comparator' combinator can be used",
          "enabled": false,
          "description": "Reports `Comparator` instances defined as lambda expressions that could be expressed using `Comparator.comparing()` calls. Chained comparisons which can be replaced by `Comparator.thenComparing()` expression are also reported.\n\nExample:\n\n\n      myList.sort((person1, person2) -> person1.getName().compareTo(person2.getName()));\n\n      myList2.sort((person1, person2) -> {\n          int res = person1.first().compareTo(person2.first());\n          if(res == 0) res = person1.second().compareTo(person2.second());\n          if(res == 0) res = person1.third() - person2.third();\n          return res;\n      });\n\nAfter the quick-fixes are applied:\n\n\n      myList.sort(Comparator.comparing(Person::getName));\n\n      myList2.sort(Comparator.comparing(Person::first)\n                             .thenComparing(Person::second)\n                             .thenComparingInt(Person::third));\n"
        },
        {
          "shortName": "Java8MapForEach",
          "displayName": "Map.forEach() can be used",
          "enabled": false,
          "description": "Suggests replacing `for(Entry<?,?> entry : map.entrySet()) {...}` or `map.entrySet().forEach(entry -> ...)` with `map.forEach((key, value) -> ...)`.\n\nExample\n\n\n      void print(Map<String, Integer> map) {\n        map.entrySet().forEach(entry -> {\n          String str = entry.getKey();\n          System.out.println(str + \":\" + entry.getValue());\n        });\n      }\n\nAfter the quick-fix is applied:\n\n\n      void print(Map<String, Integer> map) {\n        map.forEach((str, value) -> System.out.println(str + \":\" + value));\n      }\n\n\nWhen the **Do not report loops** option is enabled, only `entrySet().forEach()` cases will be reported.\nHowever, the quick-fix action will be available for `for`-loops as well.\n\nThis inspection only reports if the language level of the project or module is 8 or higher.\n\nNew in 2017.1"
        },
        {
          "shortName": "Convert2Lambda",
          "displayName": "Anonymous type can be replaced with lambda",
          "enabled": false,
          "description": "Reports anonymous classes which can be replaced with lambda expressions.\n\nExample:\n\n\n      new Thread(new Runnable() {\n        @Override\n        public void run() {\n          // run thread\n        }\n      });\n\nAfter the quick-fix is applied:\n\n\n      new Thread(() -> {\n        // run thread\n      });\n\n\nNote that if an anonymous class is converted into a stateless lambda, the same lambda object\ncan be reused by Java runtime during subsequent invocations. On the other hand, when an anonymous class is used,\nseparate objects are created every time. Thus, applying the quick-fix can cause the semantics change in rare cases,\ne.g. when anonymous class instances are used as `HashMap` keys.\n\nLambda syntax is not supported in Java 1.7 and earlier JVMs.\n\n\nUse the **Report when interface is not annotated with @FunctionalInterface** option to ignore the cases in which an anonymous\nclass implements an interface without `@FunctionalInterface` annotation."
        },
        {
          "shortName": "Java8CollectionRemoveIf",
          "displayName": "Loop can be replaced with 'Collection.removeIf()'",
          "enabled": false,
          "description": "Reports loops which can be collapsed into a single `Collection.removeIf` call.\n\nExample:\n\n\n      for (Iterator<String> it = collection.iterator(); it.hasNext(); ) {\n        String aValue = it.next();\n        if(shouldBeRemoved(aValue)) {\n          it.remove();\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      collection.removeIf(aValue -> shouldBeRemoved(aValue));\n\n\nThis inspection only reports if the language level of the project or module is 8 or higher."
        },
        {
          "shortName": "Convert2MethodRef",
          "displayName": "Lambda can be replaced with method reference",
          "enabled": false,
          "description": "Reports lambdas that can be replaced with method references. While often it could be a matter of taste, method references are more clear and readable compared to lambdas.\n\nExample:\n\n\n      Runnable r = () -> System.out.println();\n\nAfter the quick-fix is applied:\n\n\n      Runnable r = System.out::println;\n\n\nThe inspection may suggest method references even if a lambda doesn't call any method, like replacing `obj -> obj != null`\nwith `Objects::nonNull`.\nUse the [Settings \\| Editor \\| Code Style \\| Java \\| Code Generation](settings://preferences.sourceCode.Java?Lambda%20Body)\nsettings to configure special method references.\n\nThis inspection only reports if the language level of the project or module is 8 or higher."
        },
        {
          "shortName": "Java8MapApi",
          "displayName": "Simplifiable 'Map' operations",
          "enabled": false,
          "description": "Reports common usage patterns of `java.util.Map` and suggests replacing them with: `getOrDefault()`, `computeIfAbsent()`, `putIfAbsent()`, `merge()`, or `replaceAll()`.\n\nExample:\n\n\n      map.containsKey(key) ? map.get(key) : \"default\";\n\nAfter the quick-fix is applied:\n\n\n      map.getOrDefault(key, \"default\");\n\nExample:\n\n\n      List<String> list = map.get(key);\n      if (list == null) {\n        list = new ArrayList<>();\n        map.put(key, list);\n      }\n\nAfter the quick-fix is applied:\n\n\n      map.computeIfAbsent(key, localKey -> new ArrayList<>());\n\nExample:\n\n\n      Integer val = map.get(key);\n      if (val == null) map.put(key, 1);\n      else map.put(key, val + 1);\n\nAfter the quick-fix is applied:\n\n\n      map.merge(key, 1, (localKey, localValue) -> localValue + 1);\n\nExample:\n\n\n      for (Map.Entry<String, String> entry : map.entrySet()) {\n        map.put(entry.getKey(), transform(entry.getValue()));\n      }\n\nAfter the quick-fix is applied:\n\n\n      map.replaceAll((localKey, localValue) -> transform(localValue));\n\nNote that the replacement with `computeIfAbsent()` or `merge()` might work incorrectly for some `Map`\nimplementations if the code extracted to the lambda expression modifies the same `Map`. By default,\nthe warning doesn't appear if this code might have side effects. If necessary, enable the\n**Suggest replacement even if lambda may have side effects** option to always show the warning.\n\nAlso, due to different handling of the `null` value in old methods like `put()` and newer methods like\n`computeIfAbsent()` or `merge()`, semantics might change if storing the `null` value into given\n`Map` is important. The inspection won't suggest the replacement when the value is statically known to be nullable,\nbut for values with unknown nullability the replacement is still suggested. In these cases, we recommended suppressing the warning\nand adding an explanatory comment.\n\nThis inspection works only if the language level of the project or module is 8 or higher."
        }
      ]
    },
    {
      "name": "Java language level issues",
      "inspections": [
        {
          "shortName": "EnumClass",
          "displayName": "Enumerated class",
          "enabled": false,
          "description": "Reports **enum** classes. Such statements are not supported in Java 1.4 and earlier JVM."
        },
        {
          "shortName": "AnnotationClass",
          "displayName": "Annotation class",
          "enabled": false,
          "description": "Reports annotation interfaces. Such interfaces are not supported in Java 1.4 and earlier JVM."
        },
        {
          "shortName": "AssertStatement",
          "displayName": "'assert' statement",
          "enabled": false,
          "description": "Reports `assert` statements. By default, `assert` statements are disabled during execution in the production environment. Consider using logger or exceptions instead.\n\nThe `assert` statements are not supported in Java 1.3 and earlier JVM."
        },
        {
          "shortName": "ForeachStatement",
          "displayName": "Enhanced 'for' statement",
          "enabled": false,
          "description": "Reports enhanced `for` statements. Such `for` statements are not supported by Java of version 1.4 and older.\n\nExample:\n\n\n      for (int x: Arrays.asList(1, 2, 3)) {\n        System.out.println(x);\n      }\n\nAfter the quick-fix is applied:\n\n\n      for (Iterator<Integer> iterator = Arrays.asList(1, 2, 3).iterator(); iterator.hasNext(); ) {\n        final int x = iterator.next();\n        System.out.println(x);\n      }\n"
        },
        {
          "shortName": "Annotation",
          "displayName": "Annotation",
          "enabled": false,
          "description": "Reports annotations. Annotations are not supported in Java 1.4 and earlier JVM."
        },
        {
          "shortName": "VarargParameter",
          "displayName": "Varargs method",
          "enabled": false,
          "description": "Reports methods that accept an arbitrary number of parameters (also known as varargs methods).\n\nSuch methods are not supported under Java 1.4 or earlier JVMs.\n\n**Example:**\n\n\n      enum EnumConstants {\n      A(null), B, C;\n\n      EnumConstants(String... ss) {}\n    }\n\nA quick-fix is available to replace a variable argument\nparameter with an equivalent array parameter. Relevant arguments in method calls are wrapped in an array initializer expression.\nAfter the quick-fix is applied:\n\n\n      enum EnumConstants {\n      A(null), B(new String[]{}), C(new String[]{});\n\n      EnumConstants(String[] ss) {}\n    }\n"
        },
        {
          "shortName": "ForwardCompatibility",
          "displayName": "Forward compatibility",
          "enabled": true,
          "description": "Reports Java code constructs that may fail to compile in future Java versions.\n\nThe following problems are reported:\n\n* Use of `assert`\\>, `enum` or _ as an identifier\n* Use of the `var`, `yield`, or `record` restricted identifier as a type name\n* Unqualified calls to the `yield` method\n* Modifiers on the `requires java.base` statement inside of `module-info.java`\n\n**Example:**\n\n\n      // Since Java 14, this class will stop compiling, as 'yield' becomes a restricted identifier.\n      public class yield {} \n\nFixing these issues timely may simplify migration to future Java versions."
        }
      ]
    },
    {
      "name": "XML",
      "inspections": [
        {
          "shortName": "DeprecatedClassUsageInspection",
          "displayName": "Deprecated API usage in XML",
          "enabled": false,
          "description": "Reports usages of deprecated classes and methods in XML files."
        },
        {
          "shortName": "XmlWrongRootElement",
          "displayName": "Wrong root element",
          "enabled": false,
          "description": "Reports a root tag name different from the name specified in the `<doctype>` tag."
        },
        {
          "shortName": "CheckXmlFileWithXercesValidator",
          "displayName": "Failed external validation",
          "enabled": false,
          "description": "Reports a discrepancy in an XML file with the specified DTD or schema detected by the Xerces validator."
        },
        {
          "shortName": "XmlHighlighting",
          "displayName": "XML highlighting",
          "enabled": false,
          "description": "Reports XML validation problems in the results of a batch code inspection."
        },
        {
          "shortName": "XmlDuplicatedId",
          "displayName": "Duplicate 'id' attribute",
          "enabled": false,
          "description": "Reports a duplicate `id` attribute in XML."
        },
        {
          "shortName": "XmlUnboundNsPrefix",
          "displayName": "Unbound namespace prefix",
          "enabled": false,
          "description": "Reports an unbound namespace prefix in XML."
        },
        {
          "shortName": "XmlUnusedNamespaceDeclaration",
          "displayName": "Unused schema declaration",
          "enabled": false,
          "description": "Reports an unused namespace declaration or location hint in XML."
        },
        {
          "shortName": "XmlPathReference",
          "displayName": "Unresolved file reference",
          "enabled": false,
          "description": "Reports an unresolved file reference in XML."
        },
        {
          "shortName": "XmlDefaultAttributeValue",
          "displayName": "Redundant attribute with default value",
          "enabled": false,
          "description": "Reports a redundant assignment of the default value to an XML attribute."
        },
        {
          "shortName": "CheckDtdRefs",
          "displayName": "Unresolved DTD reference",
          "enabled": false,
          "description": "Reports inconsistency in a DTD-specific reference, for example, in a reference to an XML entity or to a DTD element declaration. Works in DTD an XML files."
        },
        {
          "shortName": "CheckTagEmptyBody",
          "displayName": "Empty element content",
          "enabled": false,
          "description": "Reports XML elements without contents.\n\n**Example:**\n\n\n      <user>\n        <name></name>\n      </user>\n\nAfter the quick-fix is applied:\n\n\n      <user>\n        <name/>\n      </user>\n"
        },
        {
          "shortName": "XmlInvalidId",
          "displayName": "Unresolved 'id' reference",
          "enabled": false,
          "description": "Reports an unresolved `id` reference in XML."
        },
        {
          "shortName": "XmlDeprecatedElement",
          "displayName": "Deprecated symbol",
          "enabled": false,
          "description": "Reports a deprecated XML element or attribute.\n\nSymbols can be marked by XML comment or documentation tag with text 'deprecated'."
        }
      ]
    },
    {
      "name": "Finalization",
      "inspections": [
        {
          "shortName": "FinalizeNotProtected",
          "displayName": "'finalize()' should be protected, not public",
          "enabled": true,
          "description": "Reports any implementations of the `Object.finalize()` method that are declared `public`.\n\n\nAccording to the contract of the `Object.finalize()`, only the garbage\ncollector calls this method. Making this method public may be confusing, because it\nmeans that the method can be used by users.\n\n\nThe quick-fix makes the method protected to prevent it from being explicitly invoked\nby other classes.\n\n**Example:**\n\n\n      class X {\n        public void finalize() {\n          /* ... */\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      class X {\n        protected void finalize() {\n          /* ... */\n        }\n      }\n"
        },
        {
          "shortName": "Finalize",
          "displayName": "'finalize()' should not be overridden",
          "enabled": true,
          "description": "Reports overriding the `Object.finalize()` method.\n\nAccording to the `Object.finalize()` documentation:\n>\n> The finalization mechanism is inherently problematic. Finalization can lead\n> to performance issues, deadlocks, and hangs. Errors in finalizers can lead\n> to resource leaks; there is no way to cancel finalization if it is no longer\n> necessary; and no ordering is specified among calls to `finalize`\n> methods of different objects. Furthermore, there are no guarantees regarding\n> the timing of finalization. The `finalize` method might be called\n> on a finalizable object only after an indefinite delay, if at all.\n\nConfigure the inspection:\n\n* Use the **Ignore for trivial 'finalize()' implementations** option to ignore `finalize()` implementations with an empty method body or a body containing only `if` statements that have a condition which evaluates to `false` and is a compile-time constant. For performance reasons it can be beneficial to override a non-trivial `finalize()` with an empty implementation in a subclass. An empty final `finalize()` implementation can also be used to prevent subclasses from overriding."
        },
        {
          "shortName": "NoExplicitFinalizeCalls",
          "displayName": "'finalize()' called explicitly",
          "enabled": false,
          "description": "Reports calls to `Object.finalize()`.\n\nCalling `Object.finalize()` explicitly may result in objects being placed in an\ninconsistent state.\nThe garbage collector automatically calls this method on an object when it determines that there are no references to this object.\n\nThe inspection doesn't report calls to `super.finalize()` from within implementations of `finalize()` as\nthey're benign.\n\n**Example:**\n\n\n      MyObject m = new MyObject();\n      m.finalize();\n      System.gc()\n"
        }
      ]
    },
    {
      "name": "Logging",
      "inspections": [
        {
          "shortName": "LogStatementGuardedByLogCondition",
          "displayName": "Logging call not guarded by log condition",
          "enabled": false,
          "description": "Reports logging calls with non-constant arguments that are not surrounded by a guard condition. The evaluation of the arguments of a logging call can be expensive. Surrounding a logging call with a guard clause prevents that cost when logging is disabled for the level used by the logging statement. This is especially useful for the least serious level (trace, debug, finest) of logging calls, because those are most often disabled in a production environment.\n\n**Example:**\n\n\n      public class Principal {\n        void bad(Object object) {\n          if (true) {\n            LOG.debug(\"log log log \" + expensiveCalculation(object));\n          }\n          LOG.debug(\"some more logging \" + expensiveCalculation(1));\n        }\n\n        void good(Object) {\n          if (LOG.isDebug()) {\n            LOG.debug(\"value: \" + expensiveCalculation(object));\n          }\n        }\n      }\n\n\nConfigure the inspection:\n\n* Use the **Logger class name** field to specify the logger class name used.\n*\n  Use the table to specify the logging methods this inspection should warn on, with the corresponding log condition text.\n\n* Use the **Flag all unguarded logging calls** option to have the inspection flag all unguarded log calls, not only those with non-constant arguments."
        },
        {
          "shortName": "LoggingConditionDisagreesWithLogStatement",
          "displayName": "Log condition does not match logging call",
          "enabled": false,
          "description": "Reports *is log enabled for* conditions of `if` statements that do not match the log level of the contained logging call.\n\n\nFor example:\n\n\n      if (LOG.isTraceEnabled()) {\n        // debug level logged, but checked for trace level\n        LOG.debug(\"some log message\");\n      }\n\nThis inspection understands the *java.util.logging* , *log4j* , *Log4j 2* , *Apache Commons Logging*\nand the *SLF4J* logging frameworks."
        },
        {
          "shortName": "NonStaticFinalLogger",
          "displayName": "Non-constant logger",
          "enabled": true,
          "description": "Reports logger fields that are not declared `static` and/or `final`. Ensuring that every class logger is effectively constant and bound to that class simplifies the task of providing a unified logging implementation for an application.\n\nA quick-fix is provided to change the logger modifiers to `static final`.\n\n**Example:**\n\n\n      public class Significant {\n        private Logger LOG = Logger.getLogger(Critical.class);\n      }\n\nAfter the quick-fix is applied:\n\n\n      public class Significant {\n        private static final Logger LOG = Logger.getLogger(Critical.class);\n      }\n\n\nConfigure the inspection:\n\n* Use the **Logger class name** table to specify logger class names. The inspection will report the fields that are not `static` and `final` and are of the type equal to one of the specified class names."
        },
        {
          "shortName": "PublicMethodWithoutLogging",
          "displayName": "'public' method without logging",
          "enabled": false,
          "description": "Reports any public methods that do not contain a logging statement. This inspection does not report simple getters and setters.\n\nFor example:\n\n\n      public class Crucial {\n        private static finalLogger LOG = LoggerFactory.getLogger(Crucial.class);\n        public void doImportantStuff() {\n          // warning on this method\n        }\n\n        public void doOtherStuff() {\n          LOG.info(\"do other stuff\");\n        }\n      }\n\n\nUse the table below to specify Logger class names.\nPublic methods that do not use instance methods of the specified classes will be reported by this inspection."
        },
        {
          "shortName": "PlaceholderCountMatchesArgumentCount",
          "displayName": "Number of placeholders does not match number of arguments in logging call",
          "enabled": false,
          "description": "Reports SLF4J or Log4j 2 logging calls, such as `logger.info(\"{}: {}\", key)` where the number of `{}` placeholders in the logger message doesn't match the number of other arguments to the logging call."
        },
        {
          "shortName": "ClassWithMultipleLoggers",
          "displayName": "Class with multiple loggers",
          "enabled": false,
          "description": "Reports classes that have multiple loggers declared. Ensuring that every class has a single dedicated logger is an important step in providing a unified logging implementation for an application.\n\nFor example:\n\n\n      public class Critical {\n        protected static final Logger LOG = Logger.getLogger(Critical.class);\n\n        protected static final Logger myLogger = Logger.getLogger(getClass());\n      }\n\n\nUse the table below to specify Logger class names.\nClasses which declare multiple fields that have the type of one of the specified classes will be reported by this inspection."
        },
        {
          "shortName": "LoggerInitializedWithForeignClass",
          "displayName": "Logger initialized with foreign class",
          "enabled": false,
          "description": "Reports `Logger` instances that are initialized with a `class` literal from a different class than the `Logger` is contained in. This can easily happen when copy-pasting some code from another class and may result in logging events under an unexpected category and cause filters to be applied incorrectly.\n\nA quick-fix is provided to replace the foreign class literal with one from the surrounding class.\n\n**Example:**\n\n\n      public class Paramount {\n        protected static final Logger LOG = Logger.getLogger(Critical.class);\n\n        // ... other fields and methods\n      }\n\nAfter the quick-fix is applied:\n\n\n      public class Paramount {\n        protected static final Logger LOG = Logger.getLogger(Paramount.class);\n\n        // ... other fields and methods\n      }\n\n\nConfigure the inspection:\n\n* Use the table to specify the logger factory classes and logger factory methods recognized by this inspection.\n* Use the **Ignore loggers initialized with a superclass** option to ignore loggers that are initialized with a superclass of the class containing the logger.\n* Use the **Ignore loggers in non-public classes** to only warn on loggers in `public` classes."
        },
        {
          "shortName": "ClassWithoutLogger",
          "displayName": "Class without logger",
          "enabled": false,
          "description": "Reports classes which do not have a declared logger.\n\nEnsuring that every class has a dedicated logger is an important step in providing a unified logging\nimplementation for an application. Interfaces, enumerations, annotations, inner classes, and abstract classes are not reported by this inspection.\n\nFor example:\n\n\n      public class NoLoggerDeclared {\n\n        int calculateNthDigitOfPi(int n) {\n          // todo\n          return 1;\n        }\n      }\n\n\nUse the table in the **Options** section to specify logger class names.\nClasses which do not declare a field with the type of one of the specified classes will be reported by this inspection."
        },
        {
          "shortName": "StringConcatenationArgumentToLogCall",
          "displayName": "Non-constant string concatenation as argument to logging call",
          "enabled": false,
          "description": "Reports non-constant string concatenations that are used as arguments to **SLF4J** and **Log4j 2** logging methods. Non-constant concatenations are evaluated at runtime even when the logging message is not logged; this can negatively impact performance. It is recommended to use a parameterized log message instead, which will not be evaluated when logging is disabled.\n\n**Example:**\n\n\n      public class Vital {\n        private static final Logger LOG = LoggerFactory.getLogger(Vital.class);\n\n        public void saveTheWorld(int i, String s, boolean b) {\n          LOG.info(\"saveTheWorld(\" + i + \", \" + s + \", \"  + b + \")\");\n          // todo\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      public class Vital {\n        private static final Logger LOG = LoggerFactory.getLogger(Vital.class);\n\n        public void saveTheWorld(int i, String s, boolean b) {\n          LOG.info(\"saveTheWorld({}, {}, {})\", i, s, b);\n          // todo\n        }\n      }\n\n\nConfigure the inspection:\n\n* Use the **Warn on** list to ignore certain higher logging levels. Higher logging levels may be enabled even in production, and the arguments will always be evaluated."
        },
        {
          "shortName": "KotlinPlaceholderCountMatchesArgumentCount",
          "displayName": "Number of placeholders does not match number of arguments in logging call",
          "enabled": false,
          "description": "Reports SLF4J or Log4j 2 logging calls, such as `logger.info(\"{}: {}\", key)` where the number of `{}` placeholders in the logger message doesn't match the number of other arguments to the logging call."
        },
        {
          "shortName": "KotlinLoggerInitializedWithForeignClass",
          "displayName": "Logger initialized with foreign class",
          "enabled": false,
          "description": "Reports `Logger` instances initialized with a class literal other than the class the `Logger` resides in.\n\n\nThis can happen when copy-pasting from another class.\nIt may result in logging events under an unexpected category and incorrect filtering.\n\n\nUse the inspection options to specify the logger factory classes and methods recognized by this inspection.\n\n**Example:**\n\n\n    class AnotherService\n    class MyService {\n        private val logger = LoggerFactory.getLogger(AnotherService::class.java)\n    }\n\nAfter the quick-fix is applied:\n\n\n    class MyService {\n        private val logger = LoggerFactory.getLogger(MyService::class.java)\n    }\n"
        }
      ]
    },
    {
      "name": "Modularization issues",
      "inspections": [
        {
          "shortName": "ModuleWithTooManyClasses",
          "displayName": "Module with too many classes",
          "enabled": false,
          "description": "Reports modules that contain too many classes. Overly large modules may indicate a lack of design clarity. Java, Kotlin and Groovy classes are counted.\n\nAvailable only from **Code \\| Inspect Code** or\n**Code \\| Analyze Code \\| Run Inspection by Name** and isn't reported in the editor.\n\nUse the **Maximum number of classes** field to specify the maximum number of classes a module may have."
        },
        {
          "shortName": "ClassOnlyUsedInOneModule",
          "displayName": "Class only used from one other module",
          "enabled": false,
          "description": "Reports classes that:\n\n* do not depend on any other class in their module\n* depend on classes from a different module\n* are a dependency only for classes from this other module\n\nSuch classes could be moved into the module on which they depend.\n\nAvailable only from **Code \\| Inspect Code** or\n**Code \\| Analyze Code \\| Run Inspection by Name** and isn't reported in the editor."
        },
        {
          "shortName": "ClassIndependentOfModule",
          "displayName": "Class independent of its module",
          "enabled": false,
          "description": "Reports classes that:\n\n* do not depend on any other class in their module\n* are not a dependency for any other class in their module\n\nSuch classes are an indication of ad-hoc or incoherent modularisation strategies,\nand may often profitably be moved.\n\nAvailable only from **Code \\| Inspect Code** or\n**Code \\| Analyze Code \\| Run Inspection by Name** and isn't reported in the editor."
        },
        {
          "shortName": "InconsistentLanguageLevel",
          "displayName": "Inconsistent language level settings",
          "enabled": false,
          "description": "Reports modules which depend on other modules with a higher language level.\n\nSuch dependencies should be removed or the language level of the module be increased.\n\nAvailable only from **Code \\| Inspect Code** or\n**Code \\| Analyze Code \\| Run Inspection by Name** and isn't reported in the editor."
        },
        {
          "shortName": "ModuleWithTooFewClasses",
          "displayName": "Module with too few classes",
          "enabled": false,
          "description": "Reports modules that contain too few classes. Overly small modules may indicate a too fragmented design. Java, Kotlin and Groovy classes are counted.\n\nAvailable only from **Code \\| Inspect Code** or\n**Code \\| Analyze Code \\| Run Inspection by Name** and isn't reported in the editor.\n\nUse the **Minimum number of classes** field to specify the minimum number of classes a module may have."
        }
      ]
    },
    {
      "name": "Java interop issues",
      "inspections": [
        {
          "shortName": "PackageDirectoryMismatch",
          "displayName": "Package name does not match containing directory",
          "enabled": true,
          "description": "Reports `package` directives that do not match the location of the file."
        },
        {
          "shortName": "FakeJvmFieldConstant",
          "displayName": "Kotlin non-const property used as Java constant",
          "enabled": true,
          "description": "Reports Kotlin properties that are not `const` and used as Java annotation arguments.\n\n\nFor example, a property with the `@JvmField` annotation has an initializer that can be evaluated at compile-time,\nand it has a primitive or `String` type.\n\n\nSuch properties have a `ConstantValue` attribute in bytecode in Kotlin 1.1-1.2.\nThis attribute allows javac to fold usages of the corresponding field and use that field in annotations.\nThis can lead to incorrect behavior in the case of separate or incremental compilation in mixed Java/Kotlin code.\nThis behavior is subject to change in Kotlin 1.3 (no `ConstantValue` attribute any more).\n\n**Example:**\n\nKotlin code in foo.kt file:\n\n\n      annotation class Ann(val s: String)\n      @JvmField val importantString = \"important\"\n\nJava code:\n\n\n      public class JavaUser {\n          // This is dangerous\n          @Ann(s = FooKt.importantString)\n          public void foo() {}\n      }\n\nTo fix the problem replace the `@JvmField` annotation with the `const` modifier on a relevant Kotlin property or inline it."
        },
        {
          "shortName": "HasPlatformType",
          "displayName": "Function or property has platform type",
          "enabled": true,
          "description": "Reports functions and properties that have a platform type.\n\nTo prevent unexpected errors, the type should be declared explicitly.\n\n**Example:**\n\n\n      fun foo() = java.lang.String.valueOf(1)\n\nThe quick fix allows you to specify the return type:\n\n\n      fun foo(): String = java.lang.String.valueOf(1)\n"
        },
        {
          "shortName": "JavaCollectionsStaticMethodOnImmutableList",
          "displayName": "Call of Java mutator method on immutable Kotlin collection",
          "enabled": true,
          "description": "Reports Java mutator methods calls (like `fill`, `reverse`, `shuffle`, `sort`) on an immutable Kotlin collection.\n\nThis can lead to `UnsupportedOperationException` at runtime.\n\n**Example:**\n\n\n      import java.util.Collections\n\n      fun test() {\n          val immutableList = listOf(1, 2)\n          Collections.reverse(immutableList)\n      }\n\nTo fix the problem make the list mutable."
        },
        {
          "shortName": "KotlinInternalInJava",
          "displayName": "Usage of Kotlin internal declarations from Java",
          "enabled": true,
          "description": "Reports usages of Kotlin `internal` declarations in Java code that is located in a different module.\n\n\nThe `internal` keyword is designed to restrict access to a class, function, or property from other modules.\nDue to JVM limitations, `internal` classes, functions, and properties can still be\naccessed from outside Kotlin, which may later lead to compatibility problems."
        },
        {
          "shortName": "KotlinSealedInheritorsInJava",
          "displayName": "Inheritance of Kotlin sealed interface/class from Java",
          "enabled": true,
          "description": "Reports attempts to inherit from Kotlin sealed interfaces or classes in Java code.\n\n**Example:**\n\n\n    // Kotlin file: MathExpression.kt\n\n    sealed class MathExpression\n\n    data class Const(val number: Double) : MathExpression()\n    data class Sum(val e1: MathExpression, val e2: MathExpression) : MathExpression()\n\n\n    // Java file: NotANumber.java\n\n    public class NotANumber extends MathExpression {\n    }\n"
        },
        {
          "shortName": "RedundantNotNullExtensionReceiverOfInline",
          "displayName": "'inline fun' extension receiver can be explicitly nullable until Kotlin 1.2",
          "enabled": false,
          "description": "Reports inline functions with non-nullable extension receivers which don't use the fact that extension receiver is not nullable.\n\n\nBefore Kotlin 1.2, calls of `inline fun` with flexible nullable extension receiver (a platform type with an unknown\nnullability) did not include nullability checks in bytecode. Since Kotlin 1.2, nullability checks are included into the bytecode\n(see [KT-12899](https://youtrack.jetbrains.com/issue/KT-12899)).\n\n\nThus functions which do not use the fact that extension receiver is not nullable are dangerous in Kotlin until 1.2 and it's\nrecommended to make such functions to have nullable receiver.\n\n**Example:**\n\n\n      inline fun String.greet() {\n          println(\"Hello, $this!\")\n      }\n\n      fun main() {\n          // `System.getProperty` returns not denotable `String!` type\n          val user = System.getProperty(\"user.name\")\n          user.greet()\n      }\n\nAfter the quick-fix is applied:\n\n\n      inline fun String.greet() {\n          println(\"Hello, $this!\")\n      }\n\n      fun main() {\n          // `System.getProperty` returns not denotable `String!` type\n          val user = System.getProperty(\"user.name\")\n          user.greet()\n      }\n\nThis inspection only reports if the Kotlin language level of the project or module is lower than 1.2."
        },
        {
          "shortName": "PlatformExtensionReceiverOfInline",
          "displayName": "'inline fun' with nullable receiver until Kotlin 1.2",
          "enabled": true,
          "description": "Reports potentially unsafe calls of inline functions with flexible nullable (platform type with unknown nullability) extension receivers.\n\n\nBefore Kotlin 1.2, calls of `inline fun` with flexible nullable extension receiver (a platform type with an unknown\nnullability) did not include nullability checks in bytecode. Since Kotlin 1.2, nullability checks are included into the bytecode\n(see [KT-12899](https://youtrack.jetbrains.com/issue/KT-12899)).\n\n\nIt's recommended to add an explicit `!!` you want an exception to be thrown,\nor consider changing the function's receiver type to nullable if it should work without exceptions.\n\n**Example:**\n\n\n      inline fun String.removePrefix(prefix: String): String {\n          return this.substring(prefix.length)\n      }\n\n      fun main() {\n          // `System.getProperty` returns not denotable `String!` type\n          val property = System.getProperty(\"user.dir\")\n          println(property.removePrefix(\"/home\"))\n      }\n\nAfter the quick-fix is applied:\n\n\n      inline fun String.removePrefix(prefix: String): String {\n          return this.substring(prefix.length)\n      }\n\n      fun main() {\n          // `System.getProperty` returns not denotable `String!` type\n          val property = System.getProperty(\"user.dir\")\n          println(property!!.removePrefix(\"/home\"))\n      }\n\nThis inspection only reports if the Kotlin language level of the project or module is lower than 1.2."
        }
      ]
    },
    {
      "name": "Class",
      "inspections": [
        {
          "shortName": "ExceptionNameDoesntEndWithException",
          "displayName": "Exception class name does not end with 'Exception'",
          "enabled": false,
          "description": "Reports exception classes whose names don't end with `Exception`.\n\n**Example:** `class NotStartedEx extends Exception {}`\n\nA quick-fix that renames such classes is available only in the editor."
        },
        {
          "shortName": "ClassNameSameAsAncestorName",
          "displayName": "Class name same as ancestor name",
          "enabled": false,
          "description": "Reports classes that have the same name as one of their superclasses, while their fully qualified names remain different. Such class names may be very confusing.\n\n**Example:**\n\n\n      package util;\n      abstract class Iterable<T> implements java.lang.Iterable<T> {}\n\nA quick-fix that renames such classes is available only in the editor."
        },
        {
          "shortName": "NewClassNamingConvention",
          "displayName": "Class naming convention",
          "enabled": false,
          "description": "Reports classes whose names are too short, too long, or do not follow the specified regular expression pattern.\n\n**Example:** if the inspection is enabled for tests, and the specified length for the minimum class name is 8 (the default), the following test class\nproduces a warning because the length of its name is 6, which is less than 8: `public class MyTest{}`.\n\nA quick-fix that renames such classes is available only in the editor.\n\nConfigure the inspection:\n\n\nUse the list in the **Options** section to specify which classes should be checked. Deselect the checkboxes for the classes for which\nyou want to skip the check.\n\nFor each class type, specify the minimum length, maximum length, and the regular expression expected for class names using the\nprovided input fields. Specify **0** in the length fields to skip corresponding checks.\n\nRegular expressions should be specified in the standard `java.util.regex` format."
        },
        {
          "shortName": "ClassNamePrefixedWithPackageName",
          "displayName": "Class name prefixed with package name",
          "enabled": false,
          "description": "Reports classes whose names are prefixed with their package names, ignoring differences in capitalization.\n\nWhile occasionally having such names is reasonable, they are often used due to a poor naming scheme, may be redundant and\nannoying.\n\n**Example:**\n\n\n      package byteCode;\n      class ByteCodeAnalyzer {}\n\nA quick-fix that renames such classes is available only in the editor."
        },
        {
          "shortName": "NonExceptionNameEndsWithException",
          "displayName": "Non-exception class name ends with 'Exception'",
          "enabled": false,
          "description": "Reports non-`exception` classes whose names end with `Exception`.\n\nSuch classes may cause confusion by breaking a common naming convention and\noften indicate that the `extends Exception` clause is missing.\n\n**Example:**\n\n    public class NotStartedException {}\n\nA quick-fix that renames such classes is available only in the editor."
        }
      ]
    },
    {
      "name": "Memory",
      "inspections": [
        {
          "shortName": "ZeroLengthArrayInitialization",
          "displayName": "Zero-length array allocation",
          "enabled": false,
          "description": "Reports allocations of arrays with known lengths of zero.\n\n\nSince array lengths in Java are non-modifiable, it is almost always possible to share zero-length arrays, rather than repeatedly\nallocate new ones. Such sharing may provide useful optimizations in the program runtime or footprint.\n\n\nNote that the inspection does not report zero-length arrays allocated as static final fields,\nsince those arrays are assumed to be used for implementing array sharing."
        },
        {
          "shortName": "StringBufferField",
          "displayName": "'StringBuilder' field",
          "enabled": false,
          "description": "Reports fields of type `java.lang.StringBuffer` or `java.lang.StringBuilder`. Such fields can grow without limit and are often the cause of memory leaks.\n\n**Example:**\n\n\n      public class Example {\n        private StringBuilder builder = new StringBuilder();\n\n      }\n"
        },
        {
          "shortName": "UnnecessaryEmptyArrayUsage",
          "displayName": "Unnecessary zero length array usage",
          "enabled": true,
          "description": "Reports allocations of arrays with known lengths of zero when there is a constant for that in the class of the array's element type. As zero-length arrays are immutable, you can save memory reusing the same array instance.\n\n**Example:**\n\n\n      class Item {\n        // Public zero-length array constant that can be reused \n        public static final Item[] EMPTY_ARRAY = new Item[0];\n      }\n      class EmptyNode {\n        Item[] getChildren() {\n          // Unnecessary zero-length array creation\n          return new Item[0];\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      class EmptyNode {\n        Item[] getChildren() {\n          return Item.EMPTY_ARRAY;\n        }\n      }\n"
        },
        {
          "shortName": "ReturnOfInnerClass",
          "displayName": "Return of instance of anonymous, local or inner class",
          "enabled": false,
          "description": "Reports `return` statements that return an instance of an anonymous, local, or inner class. Such instances keep an implicit reference to the outer instance, which can prevent the outer instance from being garbage-collected. Any caller of a method returning such an instance might cause a memory leak by holding on to the instance returned.\n\n\nConfigure the inspection:\n\n* Use the **Ignore returns from non-public methods** option to ignore returns from `protected` or package-private methods. Returns from `private` methods are always ignored."
        },
        {
          "shortName": "StaticCollection",
          "displayName": "Static collection",
          "enabled": false,
          "description": "Reports static fields of a `Collection` type. While it's not necessarily a problem, static collections often cause memory leaks and are therefore prohibited by some coding standards.\n\n**Example:**\n\n\n      public class Example {\n        static List<String> list = new ArrayList<>();\n\n      }\n\n\nConfigure the inspection:\n\n* Use the **Ignore weak static collections or maps** option to ignore the fields of the `java.util.WeakHashMap` type."
        },
        {
          "shortName": "SystemGC",
          "displayName": "Call to 'System.gc()' or 'Runtime.gc()'",
          "enabled": false,
          "description": "Reports `System.gc()` or `Runtime.gc()` calls. While occasionally useful in testing, explicitly triggering garbage collection via `System.gc()` is almost never recommended in production code and can result in serious performance issues."
        },
        {
          "shortName": "InnerClassMayBeStatic",
          "displayName": "Inner class may be 'static'",
          "enabled": true,
          "description": "Reports inner classes that can be made `static`.\n\nA `static` inner class does not keep an implicit reference to its enclosing instance.\nThis prevents a common cause of memory leaks and uses less memory per instance of the class.\n\n**Example:**\n\n\n      public class Outer {\n        class Inner { // not static\n          public void foo() {\n            bar(\"x\");\n          }\n\n          private void bar(String string) {}\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      public class Outer {\n        static class Inner {\n          public void foo() {\n            bar(\"x\");\n          }\n\n          private void bar(String string) {}\n        }\n      }\n"
        },
        {
          "shortName": "AnonymousInnerClassMayBeStatic",
          "displayName": "Anonymous class may be a named 'static' inner class",
          "enabled": false,
          "description": "Reports anonymous classes that may be safely replaced with `static` inner classes. An anonymous class may be a `static` inner class if it doesn't explicitly reference its enclosing instance or local classes from its surrounding method.\n\n\nA `static` inner class does not keep an implicit reference to its enclosing instance.\nThis prevents a common cause of memory leaks and uses less memory per class instance.\n\nThe quick-fix extracts the anonymous class into a named `static` inner class.\n\n**Example:**\n\n\n      void sample() {\n        Thread thread = new Thread(new Runnable() {\n          @Override\n          public void run() {\n          }\n        });\n      }\n\nAfter the quick-fix is applied:\n\n\n      void sample() {\n        Thread thread = new Thread(new Task());\n      }\n\n      private static class Task implements Runnable {\n        @Override\n        public void run() {\n        }\n      }\n"
        }
      ]
    },
    {
      "name": "Potentially confusing code constructs",
      "inspections": [
        {
          "shortName": "GroovyPointlessArithmetic",
          "displayName": "Pointless arithmetic expression",
          "enabled": false,
          "description": "Reports pointless arithmetic expressions.\n\n\nSuch expressions include adding or subtracting zero, multiplying by zero or one,\ndivision by one, and shift by zero. Such expressions may be the result of automated refactorings\nnot completely followed through to completion, and in any case are unlikely to be what the developer\nintended to do.\n\n**Example:**\n\n\n      a + 0\n\nAfter the quick-fix is applied:\n\n\n      a\n"
        },
        {
          "shortName": "UnnecessaryQualifiedReference",
          "displayName": "Unnecessary qualified reference",
          "enabled": false,
          "description": "Reports fully qualified references, which can be replaced with import.\n\n**Example:**\n\n\n      def swingBuilder = new groovy.swing.SwingBuilder()\n\nAfter the quick-fix is applied:\n\n\n      import groovy.swing.SwingBuilder\n     \n      def swingBuilder = new SwingBuilder()\n"
        },
        {
          "shortName": "GroovyOverlyComplexArithmeticExpression",
          "displayName": "Overly complex arithmetic expression",
          "enabled": false,
          "description": "Reports arithmetic expressions with too many terms.\n\n\nSuch expressions may be confusing and bug-prone.\n\n\nUse the **Maximum number of terms** field to specify the maximum number of terms allowed in an arithmetic expression."
        },
        {
          "shortName": "GroovyNegatedIf",
          "displayName": "Negated if condition expression",
          "enabled": false,
          "description": "Reports `if` statements which contain `else` branches and whose conditions are negated. Flipping the order of the `if` and `else` branches will usually increase the clarity of such statements.\n\n**Example:**\n\n\n    if (!condition) {\n      return \"1\"\n    } else {\n      return \"2\"\n    }\n\n"
        },
        {
          "shortName": "ClashingGetters",
          "displayName": "Clashing getters",
          "enabled": false,
          "description": "Reports boolean methods which can be accessed via the same property name.\n\nThe result of accessing such property might be unexpected.\n\n**Example:**\n\n\n      class X {\n          boolean isFoo() { true }\n          boolean getFoo() { false }\n      }\n\n      // getFoo() will be called\n      new X().foo\n"
        },
        {
          "shortName": "GroovyGStringKey",
          "displayName": "GString map key",
          "enabled": false,
          "description": "Reports statements which use a `groovy.lang.GString` object as a key to map. In general `GString` objects are mutable and probably should not be used as keys. Also, a `GString` entry cannot be accessed with a `java.lang.String` object with same value.\n\n**Example:**\n\n\n    def map = [:]\n    def key = 'foo'\n    map << [\"${key}\": 'bar']\n    assert map[key] == null // confusing 'true' result of comparison\n\nNew in 2017.1"
        },
        {
          "shortName": "NewInstanceOfSingleton",
          "displayName": "New instance of class annotated with @groovy.lang.Singleton",
          "enabled": false,
          "description": "Reports new instance creation of classes annotated with `@groovy.lang.Singleton`.\nSuch constructions can lead to runtime exception **Can't instantiate singleton**.\n\n**Example:**\n\n\n      @Singleton\n      class Foo{\n      }\n      \n      Foo foo = new Foo()\n\nAfter the quick-fix is applied:\n\n\n      @Singleton\n      class Foo{\n      }\n      \n      Foo foo = Foo.instance\n"
        },
        {
          "shortName": "GrReassignedInClosureLocalVar",
          "displayName": "Local variable is reassigned in closure or anonymous class",
          "enabled": false,
          "description": "Reports local variables assigned to expression with different type inside of closure or anonymous class.\n\n**Example:**\n\n\n      int sum = 0\n      [1, 2, 3].each { sum += 'as' }\n      println(sum)\n\nAs a result, the `integer` variable **sum** is reassigned to a `String` expression."
        },
        {
          "shortName": "GroovyNestedConditional",
          "displayName": "Nested conditional expression",
          "enabled": false,
          "description": "Reports ternary conditional expressions that are nested inside other conditional expressions. Such nested conditionals may be very confusing. \"Elvis\" expressions are counted as conditionals for purpose of this inspection.\n\n**Example:**\n\n\n    return (condition ? \"result\" : null) ?: \"fail\"\n\n"
        },
        {
          "shortName": "GroovyEmptyStatementBody",
          "displayName": "Statement with empty body",
          "enabled": false,
          "description": "Reports `if`, `while`, `do` or `for` statements with empty bodies. While occasionally intended, this construction is confusing, and often the result of a typo.\n\n**Example:**\n\n\n    if (condition) {}\n    while(true){}\n\n"
        },
        {
          "shortName": "GroovyImplicitNullArgumentCall",
          "displayName": "Implicit null argument",
          "enabled": false,
          "description": "Reports calls with no arguments to method that has exactly one parameter. This is equivalent to call with `null`, and that behavior is often confusing and unintended.\n\n**Example:**\n\n\n    def foo(String s){}\n    foo() // this call is actually 'foo(null)' call\n\n"
        },
        {
          "shortName": "GrPackage",
          "displayName": "Package mismatch",
          "enabled": false,
          "description": "Reports files with a declared package that does not match the package expected. Also, reports files without `package` statements if the class is not located directly in the source root directory."
        },
        {
          "shortName": "GroovyOverlyComplexBooleanExpression",
          "displayName": "Overly complex boolean expression",
          "enabled": false,
          "description": "Reports boolean expressions with too many terms.\n\n\nSuch expressions may be confusing and bug-prone.\n\n\nUse the **Maximum number of terms** field to specify the maximum number of terms allowed in a boolean expression."
        },
        {
          "shortName": "GroovyPointlessBoolean",
          "displayName": "Pointless boolean expression",
          "enabled": false,
          "description": "Reports pointless or pointlessly complicated boolean expressions.\n\n\nSuch expressions include conjunction with true,\ndisjunction with false,\nequality comparison with a boolean literal, or negation of a boolean literal. Such expressions may be\nthe result of automated refactorings\nnot completely followed through to completion, and in any case are unlikely to be what the developer\nintended to do.\n\n**Example:**\n\n\n      if (someBool && true) {}\n\nAfter the quick-fix is applied:\n\n\n      if (someBool) {}\n"
        },
        {
          "shortName": "ClashingTraitMethods",
          "displayName": "Clashing trait methods",
          "enabled": false,
          "description": "Reports classes which implement two or more traits that contain methods with same signatures.\n\nThe result of calling such methods might be unexpected.\n\nThe quick-fix adds an explicit overriding method.\n\n**Example:**\n\n\n      trait T1 {\n          def foo() {}\n      }\n\n      trait T2 {\n          def foo() {}\n      }\n\n      class X implements T1, T2 {}\n\n      // T2.foo() will be called\n      new X().foo()\n\nAfter the quick-fix is applied:\n\n\n      class X implements T1, T2 {\n          @Override\n          Object foo() {\n              return T2.super.foo()\n          }\n      }\n"
        },
        {
          "shortName": "GroovyDoubleNegation",
          "displayName": "Double negation",
          "enabled": false,
          "description": "Reports double negation that can be simplified.\n\n**Example:**\n\n\n    if (!!functionCall()) {} // double negation\n    if (!(a != b)) {} // double negation\n\nAfter the quick-fix is applied:\n\n\n    if (functionCall()) {}\n    if (a == b) {}\n\n"
        },
        {
          "shortName": "GroovyNegatedConditional",
          "displayName": "Negated conditional expression",
          "enabled": false,
          "description": "Reports conditional expressions whose conditions are negated. Flipping the order of the conditional expression branches will usually increase the clarity of such statements.\n\n**Example:**\n\n\n    ~condition ? \"1\" : \"2\"\n\n"
        },
        {
          "shortName": "GroovyNestedSwitch",
          "displayName": "Nested switch statement",
          "enabled": false,
          "description": "Reports `switch` statements that are nested inside other `switch` statements. Such nested switch statements are confusing, and may result in unexpected behaviour.\n\n**Example:**\n\n\n    switch (outer) {\n      case 1:\n        switch (inner) {\n          case 1:\n            print \"inner 1\"\n            break\n          default:\n            print \"inner default\"\n        }\n        break\n      default:\n        print \"default\"\n    }\n\n"
        },
        {
          "shortName": "GrDeprecatedAPIUsage",
          "displayName": "Deprecated API usage",
          "enabled": false,
          "description": "Reports references to deprecated classes, fields, and methods."
        },
        {
          "shortName": "GroovyOctalInteger",
          "displayName": "Octal integer",
          "enabled": false,
          "description": "Reports octal integer literals.\n\n\nSome coding standards prohibit the\nuse of octal literals, as they may be easily confused with decimal literals."
        },
        {
          "shortName": "GroovyResultOfIncrementOrDecrementUsed",
          "displayName": "Result of increment or decrement used",
          "enabled": false,
          "description": "Reports increment or decrement expressions nested inside other expressions.\n\n\nSuch expressions may be confusing, and violate the general design principle that a\ngiven construct should do precisely one thing."
        }
      ]
    },
    {
      "name": "TestNG",
      "inspections": [
        {
          "shortName": "groupsTestNG",
          "displayName": "Undefined group name",
          "enabled": false,
          "description": "Reports undefined group names passed to the `dependsOnGroups` or `groups` attributes in the `@Test` annotation.\n\nThe quick-fix adds an undefined name to a list of known groups.\n\nUse the **Defined Groups** field to define a comma-separated list of known groups."
        },
        {
          "shortName": "JUnitTestNG",
          "displayName": "JUnit Test can be converted to TestNG",
          "enabled": false,
          "description": "Reports any JUnit-based test class that can be converted into TestNG based unit test.\n\nExample:\n\n\n    import org.junit.Test;\n    import static org.junit.Assert.*;\n\n    public class ExampleTest {\n      @Test\n      public void testExample(){\n        assertEquals(2 + 2, 4);\n      }\n    }\n\nAfter the quick-fix is applied:\n\n\n    import org.testng.Assert;\n    import org.testng.annotations.Test;\n\n    public class ExampleTest {\n      @Test\n      public void testExample(){\n        Assert.assertEquals(4, 2 + 2);\n      }\n    }\n"
        },
        {
          "shortName": "ConvertJavadoc",
          "displayName": "TestNG Javadoc can be converted to annotations",
          "enabled": false,
          "description": "Asserts your TestNG tests with Javadoc annotations and converts them to JDK annotations.\n\nExample:\n\n\n      /**\n        * @testng.before-test\n      */\n      public void sample() {}\n\nAfter the quick-fix is applied:\n\n\n      @BeforeTest\n      public void sample() {}\n"
        },
        {
          "shortName": "DataProviderReturnType",
          "displayName": "Invalid data provider return type",
          "enabled": false,
          "description": "Reports methods marked with `@DataProvider` annotation that doesn't return `Object[][]` or `Iterator<Object>`. If another type is returned, TestNG throws an exception.\n\nExample:\n\n\n    public class TestNgTest {\n      @DataProvider(name = \"Languages\")\n      List&ltString> getData() {\n        return List.of(\"Java\", \"Kotlin\");\n      }\n\n      @Test(dataProvider = \"Languages\")\n      public void testData(String language) {\n        System.out.println(language);\n      }\n    }\n"
        },
        {
          "shortName": "ExpectedExceptionNeverThrownTestNG",
          "displayName": "Expected exception never thrown in test method body",
          "enabled": false,
          "description": "Reports checked exceptions expected by a TestNG test method that are never thrown inside the method body.\n\n**Example:**\n\n\n      @Test(expectedExceptions = Exception.class) // warning: Expected 'Exception' never thrown\n      public void testEngineIsRunning() {\n        assertTrue(engine.isRunning());\n      }\n      \n"
        },
        {
          "shortName": "UndeclaredTests",
          "displayName": "Undeclared test",
          "enabled": false,
          "description": "Reports test classes that are not registered in `testing.xml`. This is often a mistake because such tests won't be executed."
        },
        {
          "shortName": "ConvertOldAnnotations",
          "displayName": "Old TestNG annotation @Configuration is used",
          "enabled": false,
          "description": "Reports TestNG `org.testng.annotations.Configuration` annotations.\n\nIt's better to configure a test suite with the modern `@BeforeXXX`/`@AfterXXX` annotations.\n\nExample:\n\n\n      public class Test {\n        @Configuration(beforeSuite = true, afterTest = true)\n        public void afterBefore(){\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      public class Test {\n        @AfterTest()\n        @BeforeSuite()\n        public void afterBefore(){\n        }\n      }\n"
        },
        {
          "shortName": "DuplicatedDataProviderNames",
          "displayName": "Duplicated data provider names",
          "enabled": false,
          "description": "Reports `TestNG` data providers with equal names if `org.testng.TestNGException` has occurred.\n\nExample:\n\n\n      public class DuplicatedDataProviders {\n        @DataProvider\n        public Object[][] intTestData() { // duplicate 1\n          return new Integer[][]{\n            new Integer[]{1, 1},\n          };\n        }\n\n        @DataProvider(name = \"intTestData\")\n        public Object[][] someTestData() { // duplicate 2\n          return new Integer[][]{\n            new Integer[]{1, 1},\n          };\n        }\n\n        @Test(dataProvider = \"intTestData\")\n        public void testIsOK(Integer key, Integer value) {\n          assertEquals(key, value);\n        }\n      }\n"
        },
        {
          "shortName": "dependsOnMethodTestNG",
          "displayName": "Illegal method name passed to 'dependsOnMethods'",
          "enabled": false,
          "description": "Reports illegal method names passed to the `dependsOnMethods` attribute in the `@Test` annotation.\n\nA method name is considered illegal if it can't be resolved into a valid, accessible `@Test` annotated method in the current class\nor any of its parent classes.\n\nExample:\n\n\n      public class SampleTest {\n        @Test(dependsOnMethods = \"testSpellignError\")\n        public void testSample() {}\n        @Test\n        public void testSpellingError(){}\n      }\n"
        },
        {
          "shortName": "MalformedDataProvider",
          "displayName": "Data provider problems",
          "enabled": false,
          "description": "Reports references to data provider methods that do not exist or are not accessible.\n\nExample:\n\n\n    public class InstanceDataProviderFromForeignClass {\n      // method data() doesn't exist in class A\n      @Test(dataProvider = \"data\", dataProviderClass = A.class)\n      public void test() {\n      }\n    }\n    class A { }\n\nAfter the quick-fix is applied:\n\n\n    //the needed data() method is created in class A\n    class A {\n      @DataProvider\n      public Object[][] data() {\n        return new Object[][]{};\n      }\n    }\n"
        }
      ]
    },
    {
      "name": "Plugin DevKit",
      "inspections": [
        {
          "shortName": "ComponentRegistrationProblems",
          "displayName": "Component type mismatch",
          "enabled": false,
          "description": "Reports incorrect registration of plugin components (Components and Actions) both in code and in the `plugin.xml` descriptor.\n\n\nThe following problems are reported:\n\n* Unresolved component/action implementation-classes (`plugin.xml`)\n* Unresolved component interface-classes (`plugin.xml`)\n* Component implementation-class is not assignable to its interface-class (`plugin.xml`)\n* Incorrect component registration, e.g. `ProjectComponent` is registered as Application Component, or the class doesn't implement any component interface at all (`plugin.xml` and Java code)\n* Incorrect class modifiers: Action classes must be `public` and must have a public no-argument constructor. Additionally, Action and Component implementation classes must not be abstract (`plugin.xml` and Java code)\n* Duplicate interface-class: A class may only be used once as interface-class (`plugin.xml`)\n\nConfigure the inspection:\n\n* Use the **Check Plugin Descriptor (plugin.xml)** option to disable checks in `plugin.xml` descriptor.\n* Use the **Check Java Actions** option to disable checks in Action code.\n* Use the **Check Java Code** option to disable all checks in code."
        },
        {
          "shortName": "DevKitPropertiesQuotesValidation",
          "displayName": "Quotes validation in properties files",
          "enabled": false,
          "description": "Reports wrong number of quotes around parameter in property value.\n\n\nIf parameters are present in the property value, then the value will be passed as a pattern to `java.text.MessageFormat`.\nThis means that single quotes are used for escaping. Thus to keep a quote visible, it must be duplicated:\n\n* `'{0}'`  `{0}`\n* `''{0}''`  `'$value$'`\n\n\nWhen using choice format, nested formats are evaluated as formats themselves, and second double quotes are required.\nWhen passing `1`:\n\n* `{0, choice, 0#no|#1''{0}'' file}`  `{0} files`\n* `{0, choice, 0#no|#1''''{0}'''' file}`  `'$number_of_files$' files`"
        }
      ]
    },
    {
      "name": "Plugin descriptor",
      "inspections": [
        {
          "shortName": "PluginXmlCapitalization",
          "displayName": "Plugin.xml text capitalization",
          "enabled": false,
          "description": "Reports text capitalization problems in `plugin.xml`.\n\n\nThe following elements are checked:\n\n* `<name>`\n* `<action>, <group>`\n* `<separator, <synonym>, <override-text>`\n* extension point properties annotated with `org.jetbrains.annotations.Nls` specifying required `capitalization`\n\n\nPlease see [Capitalization](https://jetbrains.design/intellij/text/capitalization/) in IntelliJ Platform UI Guidelines for more\ninformation."
        },
        {
          "shortName": "InspectionMappingConsistency",
          "displayName": "<inspection> tag consistency",
          "enabled": false,
          "description": "Reports problems for inspection extension point registration in `plugin.xml`.\n\n\nInspection (group) name must be defined using respective attributes for proper presentation in IDE."
        },
        {
          "shortName": "PluginXmlDynamicPlugin",
          "displayName": "Plugin.xml dynamic plugin verification",
          "enabled": false,
          "description": "Reports dynamic plugin problems.\n\n\nDynamic plugins can be installed, updated and uninstalled without restarting the IDE (supported in 2020.1 and later).\n\n\nPlease see [Dynamic Plugins](https://plugins.jetbrains.com/docs/intellij/dynamic-plugins.html?from=PluginXmlDynamicPlugin) for further reference.\n\nNew in 2020.1"
        },
        {
          "shortName": "PluginXmlI18n",
          "displayName": "Plugin.xml i18n verification",
          "enabled": false,
          "description": "Reports hardcoded texts in `plugin.xml`.\n\n\nUsing texts defined in resource bundles allows supporting multiple languages in the IDE.\n\n\nThe following elements are checked:\n\n* `<action>, <group>`\n* `<separator, <override-text>`\n* known extension points having `bundle/key` alternative"
        },
        {
          "shortName": "PluginXmlValidity",
          "displayName": "Plugin.xml validity",
          "enabled": false,
          "description": "Reports problems in `plugin.xml`.\n\n\nInvalid configuration can lead to problems at runtime."
        }
      ]
    },
    {
      "name": "Other problems",
      "inspections": [
        {
          "shortName": "ConvertArgumentToSet",
          "displayName": "Argument could be converted to 'Set' to improve performance",
          "enabled": false,
          "description": "Detects the function calls that could work faster with an argument converted to `Set`.\n\n\nOperations like 'minus' or 'intersect' are more effective when their argument is a set.\nAn explicit conversion of an `Iterable<T>` or an `Array<T>`\ninto a `Set<T>` can often make code more effective.\n\n\nThe quick-fix adds an explicit conversion to the function call.\n\n**Example:**\n\n\n      fun <T> f(a: Iterable<T>, b: Iterable<T>): Int =\n          a.intersect(b).size\n\nAfter the quick-fix is applied:\n\n\n      fun <T> f(a: Iterable<T>, b: Iterable<T>): Int =\n          a.intersect(b.toSet()).size\n"
        },
        {
          "shortName": "DeprecatedCallableAddReplaceWith",
          "displayName": "@Deprecated annotation without 'replaceWith' argument",
          "enabled": false,
          "description": "Reports deprecated functions and properties that do not have the `kotlin.ReplaceWith` argument in its `kotlin.deprecated` annotation and suggests to add one based on their body.\n\n\nKotlin provides the `ReplaceWith` argument to replace deprecated declarations automatically.\nIt is recommended to use the argument to fix deprecation issues in code.\n\n**Example:**\n\n\n      @Deprecated(\"Use refined() instead.\")\n      fun deprecated() = refined()\n\n      fun refined() = 42\n\nA quick-fix adds the `ReplaceWith()` argument:\n\n\n      @Deprecated(\"Use refined() instead.\", ReplaceWith(\"refined()\"))\n      fun deprecated() = refined()\n\n      fun refined() = 42\n"
        },
        {
          "shortName": "FloatingPointLiteralPrecision",
          "displayName": "Floating-point literal exceeds the available precision",
          "enabled": false,
          "description": "Reports floating-point literals that cannot be represented with the required precision using [IEEE 754](https://en.wikipedia.org/wiki/IEEE_754) `Float` and `Double` types.\n\n\nFor example, `1.9999999999999999999` has too many significant digits,\nso its representation as a `Double` will be rounded to `2.0`.\nSpecifying excess digits may be misleading as it hides the fact that computations\nuse rounded values instead.\n\n\nThe quick-fix replaces the literal with a rounded value that matches the actual representation\nof the constant.\n\n**Example:**\n\n\n      val x: Float = 3.14159265359f\n\nAfter the quick-fix is applied:\n\n\n      val x: Float = 3.1415927f\n"
        },
        {
          "shortName": "KDocMissingDocumentation",
          "displayName": "Missing KDoc comments for public declarations",
          "enabled": false,
          "description": "Reports public declarations that do not have KDoc comments.\n\n**Example:**\n\n\n      class A\n\nThe quick fix generates the comment block above the declaration:\n\n\n      /**\n       *\n       */\n      class A\n"
        },
        {
          "shortName": "PublicApiImplicitType",
          "displayName": "Public API declaration with implicit return type",
          "enabled": false,
          "description": "Reports `public` and `protected` functions and properties that have an implicit return type.\nFor API stability reasons, it's recommended to specify such types explicitly.\n\n**Example:**\n\n\n      fun publicFunctionWhichAbusesTypeInference() =\n          otherFunctionWithNotObviousReturnType() ?: yetAnotherFunctionWithNotObviousReturnType()\n\nAfter the quick-fix is applied:\n\n\n      fun publicFunctionWhichAbusesTypeInference(): Api =\n          otherFunctionWithNotObviousReturnType() ?: yetAnotherFunctionWithNotObviousReturnType()\n"
        },
        {
          "shortName": "ReplaceWithEnumMap",
          "displayName": "'HashMap' can be replaced with 'EnumMap'",
          "enabled": true,
          "description": "Reports `hashMapOf` function or `HashMap` constructor calls that can be replaced with an `EnumMap` constructor call.\n\nUsing `EnumMap` constructor makes your code simpler.\n\nThe quick-fix replaces the function call with the `EnumMap` constructor call.\n\n**Example:**\n\n\n      enum class E {\n          A, B\n      }\n\n      fun getMap(): Map<E, String> = hashMapOf()\n\nAfter the quick-fix is applied:\n\n\n      enum class E {\n          A, B\n      }\n\n      fun getMap(): Map<E, String> = EnumMap(E::class.java)\n"
        },
        {
          "shortName": "OverridingDeprecatedMember",
          "displayName": "Overriding deprecated member",
          "enabled": true,
          "description": "Reports declarations that inherit from deprecated members.\n\n**Example:**\n\n\n    open class BaseService {\n      @Deprecated(\"obsolete\", replaceWith = ReplaceWith(\"connection\"))\n      open fun connect() {}\n\n      open fun connection() {}\n    } \n\n    class SomeService: BaseService() {\n      override fun connect() {\n        super.connect()\n      }\n    }\n"
        },
        {
          "shortName": "MigrateDiagnosticSuppression",
          "displayName": "Diagnostic name should be replaced",
          "enabled": true,
          "description": "Reports suppressions with old diagnostic names, for example `@Suppress(\"HEADER_WITHOUT_IMPLEMENTATION\")`.\n\n\nSome of diagnostics from Kotlin 1.2 and earlier are now obsolete, making such suppressions redundant.\n\n**Example:**\n\n\n    @Suppress(\"HEADER_DECLARATION_WITH_BODY\")\n    expect fun connection() {\n      // ...\n    }\n\nAfter the quick-fix is applied:\n\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    expect fun connection() {\n      // ...\n    }\n"
        }
      ]
    },
    {
      "name": "Abstraction issues",
      "inspections": [
        {
          "shortName": "UseOfConcreteClass",
          "displayName": "Use of concrete class",
          "enabled": false,
          "description": "Reports usages of concrete classes, rather than interfaces. Such declarations may represent a failure of abstraction and may make testing more difficult.\n\n\nDeclarations whose classes come from system or third-party libraries will not be reported by this inspection.\nCasts, instanceofs, and local variables are not reported in `equals()` method implementations.\nAlso, casts are not reported in `clone()` method implementations.\n\nExample:\n\n\n      interface Entity {}\n      class EntityImpl implements Entity {}\n\n      void processObject(Object obj) {\n        // warning: instanceof of the concrete class\n        if (obj instanceof EntityImpl) {\n          // warning: cast to the concrete class,\n          // rather than the interface\n          processEntity((EntityImpl)obj);\n        }\n      }\n      // warning: parameter of concrete class\n      void processEntity(EntityImpl obj) {\n      }\n\n\nUse the **Ignore abstract class type** option to ignore casts to abstract classes.\n\nUse the subsequent options to control contexts where the problem is reported."
        },
        {
          "shortName": "MethodOnlyUsedFromInnerClass",
          "displayName": "Private method only used from inner class",
          "enabled": false,
          "description": "Reports `private` methods which are only called from an inner class of the class containing the method. Such methods can be safely moved into that inner class.\n\nExample:\n\n\n    public class Outer {\n      public static void main(String[] args) {\n        new Inner().run(args[0]);\n      }\n\n      static class Inner {\n        void run(String arg) {\n          // Method isEmpty() is used from Inner class only\n          // consider moving it to the Inner class\n          if (!isEmpty(arg)) {\n            System.out.println(\"Argument is supplied\");\n          }\n        }\n      }\n\n      private static boolean isEmpty(String s) {\n        return s != null && s.trim().isEmpty();\n      }\n    }\n\n\nUse the first checkbox below to ignore `private`\nmethods which are called from an anonymous or local class.\n\n\nUse the third checkbox to only report `static` methods."
        },
        {
          "shortName": "DeclareCollectionAsInterface",
          "displayName": "Collection declared by class, not interface",
          "enabled": false,
          "description": "Reports declarations of `Collection` variables made by using the collection class as a type, rather than an appropriate interface. The warning is not issued if weakening the variable type will cause a compilation error.\n\nExample:\n\n\n      // Warning: concrete collection class ArrayList used.\n      int getTotalLength(ArrayList<String> list) {\n        return list.stream().mapToInt(String::length).sum();\n      }\n\n      // No warning, as trimToSize() method is not\n      // available in the List interface\n      void addData(ArrayList<String> data) {\n        data.add(\"Hello\");\n        data.add(\"World\");\n        data.trimToSize();\n      }\n\nA quick-fix is suggested to use the appropriate collection interface (e.g. `Collection`, `Set`, or `List`)."
        },
        {
          "shortName": "PublicMethodNotExposedInInterface",
          "displayName": "'public' method not exposed in interface",
          "enabled": false,
          "description": "Reports `public` methods in classes which are not exposed in an interface.\n\nExposing all `public` methods via an interface is important for\nmaintaining loose coupling, and may be necessary for certain component-based programming styles.\n\nExample:\n\n\n    interface Person {\n      String getName();\n    }\n\n    class PersonImpl implements Person {\n      private String name;\n\n      // ok: method is exposed in interface\n      @Override\n      public String getName() {\n        return name;\n      }\n\n      // warning: method is public\n      // but not exposed in interface\n      public void setName() {\n        this.name = name;\n      }\n    }\n\n\nUse the **Ignore if annotated by** list to specify special annotations. Methods annotated with one of\nthese annotations will be ignored by this inspection.\n\n\nUse the **Ignore if the containing class does not implement a non-library interface** option to ignore methods from classes which do not\nimplement any interface from the project."
        },
        {
          "shortName": "TypeMayBeWeakened",
          "displayName": "Type may be weakened",
          "enabled": false,
          "description": "Reports variable and method return types that can be changed to a more abstract (weaker) type. This allows making the code more abstract, hence more reusable.\n\nExample:\n\n\n      // Type of parameter can be weakened to java.util.List\n      void processList(ArrayList<String> list) {\n        if (list.isEmpty()) return;\n        System.out.println(\"Processing\");\n        for (String s : list) {\n          System.out.println(\"String: \" + s);\n        }\n      }\n\n\nEnable the **Use righthand type** checkbox below\nto prevent weakening the left side of assignments when the right side is not\na type cast or a new expression. When storing the result of a method call in a variable, it is\nuseful to retain the type of the method call result instead of unnecessarily weakening it.\n\n\nEnable the **Use parameterized type** checkbox below\nto use the parameterized type of the collection as the weakest type when\nthe object evaluated is used as an argument to a collection method with a parameter type of\n`java.lang.Object`.\nUse this option to prevent weakening to `Object` when passing an object to the following collection methods:\n`get()`, `remove()`,\n`contains()`, `indexOf()`,\n`lastIndexOf()`, `containsKey()` and `containsValue()`.\n\n\nEnable the **Do not weaken to Object** checkbox below\nto specify whether a type should be weakened to `java.lang.Object`.\nWeakening to `java.lang.Object` is rarely very useful.\n\n\nEnable the **Only weaken to an interface** checkbox below\nto only report a problem when the type can be weakened to an interface type.\n\n\nEnable the **Do not weaken return type** checkbox below\nto prevent reporting a problem when the return type may be weakened.\nOnly variables will be analyzed.\n\n\nEnable the **Do not suggest weakening variable declared as 'var'** checkbox below\nto prevent reporting on local variables declared using the 'var' keyword (Java 10+)\n\n\n**Stop classes** are intended to prevent weakening to classes\nlower than stop classes, even if it is possible.\nIn some cases, this may improve readability."
        },
        {
          "shortName": "BooleanParameter",
          "displayName": "'public' method with 'boolean' parameter",
          "enabled": false,
          "description": "Reports public methods that accept a `boolean` parameter.\n\nIt's almost always bad practice to add a `boolean` parameter to a public method (part of an API) if that method is not a setter.\nWhen reading code using such a method, it can be difficult to decipher what the `boolean` stands for without looking at\nthe source or documentation.\n\nThis problem is also known as [the boolean trap](https://ariya.io/2011/08/hall-of-api-shame-boolean-trap).\nThe `boolean` parameter can often be replaced with an `enum`.\n\nExample:\n\n\n      // Warning: it's hard to understand what the\n      // boolean parameters mean when looking at\n      // a call to this method\n      public boolean setPermission(File f,\n                                   int access,\n                                   boolean enable,\n                                   boolean ownerOnly) {\n        // ...\n      }\n\n\nUse the **Only report methods with multiple boolean parameters** option to warn only when a method contains more than one boolean parameter."
        },
        {
          "shortName": "ClassReferencesSubclass",
          "displayName": "Class references one of its subclasses",
          "enabled": false,
          "description": "Reports classes which contain references to one of their subclasses. Such references may be confusing and violate several rules of object-oriented design.\n\nExample:\n\n\n      class Entity {\n        // Warning: the class references its subclass\n        void compare(SimpleEntity entity) {\n          ...\n        }\n      }\n      class SimpleEntity extends Entity {\n        ...\n      }\n"
        },
        {
          "shortName": "OptionalUsedAsFieldOrParameterType",
          "displayName": "'Optional' used as field or parameter type",
          "enabled": true,
          "description": "Reports any cases in which `java.util.Optional<T>`, `java.util.OptionalDouble`, `java.util.OptionalInt`, `java.util.OptionalLong`, or `com.google.common.base.Optional` are used as types for fields or parameters.\n\n`Optional` was designed to provide a limited mechanism for library method return types in which a clear way to represent \"no result\"\nwas needed.\n\nUsing a field with the `java.util.Optional` type is also problematic if the class needs to be\n`Serializable`, as `java.util.Optional` is not serializable.\n\nExample:\n\n\n      class MyClass {\n        Optional<String> name; // Optional field\n\n        // Optional parameter\n        void setName(Optional<String> name) {\n          this.name = name;\n        }\n      }\n"
        },
        {
          "shortName": "InstanceofChain",
          "displayName": "Chain of 'instanceof' checks",
          "enabled": false,
          "description": "Reports any chains of `if`-`else` statements all of whose conditions are `instanceof` expressions or class equality expressions (e.g. comparison with `String.class`). Such constructions usually indicate a failure in object-oriented design which dictates that such type-based dispatch should be done via polymorphic method calls rather than explicit chains of type tests.\n\nExample:\n\n\n      double getArea(Shape shape) {\n        // Warning: abstraction failure.\n        // It would be better to declare a getArea()\n        // abstract method in the shape interface\n        // and implement it in every inheritor.\n        if (shape instanceof Point) {\n          return 0;\n        }\n        if (shape instanceof Circle) {\n          return Math.PI *\n            Math.pow(((Circle) shape).radius(), 2);\n        }\n        if (shape instanceof Rectangle) {\n          return ((Rectangle) shape).width() *\n            ((Rectangle) shape).height();\n        }\n        throw new IllegalArgumentException();\n      }\n\n\nUse the checkbox below to ignore `instanceof` expressions on library classes."
        },
        {
          "shortName": "UnresolvedClassReferenceRepair",
          "displayName": "Unresolved class reference",
          "enabled": false,
          "description": "Reports an unresolved class reference.\n\nThe quick-fix suggests trying to resolve reference."
        },
        {
          "shortName": "OverlyStrongTypeCast",
          "displayName": "Overly strong type cast",
          "enabled": false,
          "description": "Reports type casts that are overly strong. For instance, casting an object to `ArrayList` when casting it to `List` would do just as well.\n\n\n**Note:** much like the *Redundant type cast*\ninspection, applying the fix for this inspection may change the semantics of your program if you are\nintentionally using an overly strong cast to cause a `ClassCastException` to be generated.\n\nExample:\n\n\n      interface Super {\n        void doSmth();\n      }\n      interface Sub extends Super { }\n\n      void use(Object obj) {\n        // Warning: ((Super)obj).doSmth() could be used\n        ((Sub)obj).doSmth();\n      }\n\n\nUse the checkbox below to ignore casts when there's a matching `instanceof` check in the code."
        },
        {
          "shortName": "InterfaceMethodClashesWithObject",
          "displayName": "Interface method clashes with method in 'Object'",
          "enabled": true,
          "description": "Reports interface methods that clash with the **protected** methods `clone()` and `finalize()` from the `java.lang.Object` class.\n\nIn an interface, it is possible to declare these methods with a return type that is incompatible with the `java.lang.Object` methods.\nA class that implements such an interface will not be compilable.\nWhen the interface is functional, it remains possible to create a lambda from it, but this is not recommended.\n\nExample:\n\n\n      // Warning: this interface cannot be implemented\n      // by any class, only by a lambda or method reference\n      interface MyInterface {\n        double clone();\n      }\n"
        },
        {
          "shortName": "StaticMethodOnlyUsedInOneClass",
          "displayName": "Static member only used from one other class",
          "enabled": false,
          "description": "Reports `static` methods and fields that are only used from a class other than the containing class. Such members could be moved into the using class. Factory methods and members accessed from an anonymous class inside the member's class are ignored by this inspection. Convenience overloads, which call a method with the same name in the same class but have fewer parameters, are also ignored.\n\n\nUse the first checkbox to supress this inspection when the static member is only used from a test class.\n\n\nUse the second checkbox below to ignore member usages from inside anonymous, local, or non-static inner classes.\n\n\nUse the third checkbox below to not warn on members that cannot be moved without problems,\nfor example, because a method with an identical signature is already present in the target class,\nor because a field or a method used inside the method will not be accessible when this method is moved.\n\n\nUse the fourth checkbox to ignore members located in utility classes."
        },
        {
          "shortName": "FeatureEnvy",
          "displayName": "Feature envy",
          "enabled": false,
          "description": "Reports the *Feature Envy* code smell. The warning is thrown when a method calls methods on another class three or more times. Calls to library classes, parent classes, contained or containing classes are not counted by this inspection. Feature envy is often an indication of the fact that this functionality is located in a wrong class.\n\nExample:\n\n\n      class JobManager {\n        // Warning: this method calls three methods\n        // of the Job class\n        // It would be better to move this chain of\n        // calls to the Job class itself.\n        void performJob(Job job) {\n          job.beforeStart();\n          job.process();\n          job.afterProcessing();\n        }\n      }\n"
        },
        {
          "shortName": "InstanceofThis",
          "displayName": "'instanceof' check for 'this'",
          "enabled": false,
          "description": "Reports usages of `instanceof` or `getClass() == SomeClass.class` in which a `this` expression is checked.\n\nSuch expressions indicate a failure of the object-oriented design, and should be replaced by\npolymorphic constructions.\n\nExample:\n\n\n    class Super {\n      void process() {\n        if (this instanceof Sub) { // warning\n          doSomething();\n        } else {\n          doSomethingElse();\n        }\n      }\n    }\n      \n    class Sub extends Super {}\n\nTo fix the problem, use an overriding method:\n\n\n    class Super {\n      void process() {\n        doSomethingElse();\n      }\n    }\n      \n    class Sub extends Super {\n      @Override\n      void process() {\n        doSomething();\n      }\n    }  \n"
        },
        {
          "shortName": "MagicNumber",
          "displayName": "Magic number",
          "enabled": false,
          "description": "Reports \"magic numbers\": numeric literals that are not named by a constant declaration.\n\nUsing magic numbers can lead to unclear code, as well as errors if a magic\nnumber is changed in one location but remains unchanged not another. The numbers 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 100, 1000, 0L, 1L, 2L,\n0.0, 1.0, 0.0F and 1.0F are not reported by this inspection.\n\nExample:\n\n\n      void checkFileSize(long bytes) {\n        if (bytes > 1_048_576) {\n          throw new IllegalArgumentException(\"too big\");\n        }\n      }\n\nA quick-fix introduces a new constant:\n\n\n      static final int MAX_SUPPORTED_FILE_SIZE = 1_048_576;\n\n      void checkFileSize(long bytes) {\n        if (bytes > MAX_SUPPORTED_FILE_SIZE) {\n          throw new IllegalArgumentException(\"too big\");\n        }\n      }\n\nConfigure the inspection:\n\n* Use the **Ignore constants in 'hashCode()' methods** option to disable this inspection within `hashCode()` methods.\n* Use the **Ignore in annotations** option to ignore magic numbers in annotations.\n* Use the **Ignore initial capacity for StringBuilders and Collections** option to ignore magic numbers used as initial capacity when constructing `Collection`, `Map`, `StringBuilder` or `StringBuffer` objects."
        }
      ]
    },
    {
      "name": "Java 9",
      "inspections": [
        {
          "shortName": "Java9CollectionFactory",
          "displayName": "Immutable collection creation can be replaced with collection factory call",
          "enabled": false,
          "description": "Reports `java.util.Collections` unmodifiable collection calls that can be converted to newer collection factory methods. These can be replaced with e.g. `List.of()` or `Set.of()` introduced in Java 9 or `List.copyOf()` introduced in Java 10.\n\nNote that in contrast to `java.util.Collections` methods, Java 9 collection factory methods:\n\n* Do not accept `null` values.\n* Require unique set elements and map keys.\n* Do not accept `null` arguments to query methods like `List.contains()` or `Map.get()` of the collections returned.\n\nWhen these cases are violated, exceptions are thrown.\nThis can change the semantics of the code after the migration.\n\nExample:\n\n\n      List<Integer> even = Collections.unmodifiableList(\n        Arrays.asList(2, 4, 6, 8, 10, 2));\n      List<Integer> evenCopy = Collections.unmodifiableList(\n        new ArrayList<>(list1));\n\nAfter the quick-fix is applied:\n\n\n      List<Integer> even = List.of(2, 4, 6, 8, 10, 2);\n      List<Integer> evenCopy = List.copyOf(list);\n\nThis inspection only reports if the language level of the project or module is 9 or higher.\n\n\nUse the **Do not warn when content is non-constant** option to report only in cases when the supplied arguments are compile-time constants.\nThis reduces the chances that the behavior changes,\nbecause it's not always possible to statically check whether original elements are unique and not `null`.\n\n\nUse the **Suggest 'Map.ofEntries'** option to suggest replacing unmodifiable maps with more than 10 entries with `Map.ofEntries()`.\n\nNew in 2017.2"
        },
        {
          "shortName": "JavaRequiresAutoModule",
          "displayName": "Dependencies on automatic modules",
          "enabled": false,
          "description": "Reports usages of automatic modules in a `requires` directive.\n\nAn automatic\nmodule is unreliable since it can depend on the types on the class path,\nand its name and exported packages can change if it's\nconverted into an explicit module.\n\nCorresponds to `-Xlint:requires-automatic` and `-Xlint:requires-transitive-automatic` Javac options.\nThe first option increases awareness of when automatic modules are used.\nThe second warns the authors of a module that they're putting the users of that module at risk by establishing implied readability to an automatic module.\n\n**Example:**\n\n\n      //module-info.java\n      module org.printer {\n        requires transitive drivers.corp.org; // reported in case 'drivers.corp.org' is an automatic module\n      }\n\n\nUse the **Highlight only transitive dependencies** option to warn only about transitive dependencies."
        },
        {
          "shortName": "ReplaceNullCheck",
          "displayName": "Null check can be replaced with method call",
          "enabled": false,
          "description": "Reports null checks that can be replaced with an `Objects`/`Stream` static method.\n\n**Example:**\n\n\n    if (message == null) {\n      application.messageStorage().save(new EmptyMessage());\n    } else {\n      application.messageStorage().save(message);\n    }\n\nAfter the quick-fix is applied:\n\n\n      application.messageStorage()\n        .save(Objects.requireNonNullElseGet(message, () -> new EmptyMessage()));\n\n\nUse the **Don't warn if length of replacement bigger than original** option to ignore the cases when the replacement is longer than the\noriginal code.\n\nNew in 2017.3"
        }
      ]
    },
    {
      "name": "XSLT",
      "inspections": [
        {
          "shortName": "XsltUnusedDeclaration",
          "displayName": "Unused variable or parameter",
          "enabled": false,
          "description": "Reports local variables and parameters that are never used.\n\nPowered by XPathView + XSLT-Support"
        },
        {
          "shortName": "XsltDeclarations",
          "displayName": "Incorrect declaration",
          "enabled": false,
          "description": "Reports duplicate declarations and illegal identifiers in XSLT variables, parameters, and named templates:\n\nPowered by XPathView + XSLT-Support"
        },
        {
          "shortName": "XsltVariableShadowing",
          "displayName": "Shadowed variable",
          "enabled": false,
          "description": "Reports shadowed XSLT variables.\n\nPowered by XPathView + XSLT-Support"
        },
        {
          "shortName": "XsltTemplateInvocation",
          "displayName": "Incorrect template invocation",
          "enabled": false,
          "description": "Reports missing arguments, passing arguments that are not declared, and passing arguments for parameters more than once in named XSLT template invocations.\n\n\nParameters declared with a default value are optional and will not be reported as missing.\n\nPowered by XPathView + XSLT-Support"
        }
      ]
    },
    {
      "name": "Other",
      "inspections": [
        {
          "shortName": "GrMethodMayBeStatic",
          "displayName": "Method can be made 'static'",
          "enabled": false,
          "description": "Reports methods which may safely be made `static`.\n\n\nA method may be `static` if it is not `synchronized`,\nit does not reference any of its class' instance methods and instance fields,\nand it is not overridden in a subclass."
        },
        {
          "shortName": "TypeCustomizer",
          "displayName": "Type customizer inspection",
          "enabled": false,
          "description": "Reports files which can be custom type checkers and are not added to compiler resources yet."
        }
      ]
    },
    {
      "name": "Cloning issues",
      "inspections": [
        {
          "shortName": "CloneInNonCloneableClass",
          "displayName": "'clone()' method in non-Cloneable class",
          "enabled": false,
          "description": "Reports classes that override the `clone()` method but don't implement the `Cloneable` interface. This usually represents a programming error.\n\n\nUse the **Only warn on 'public' clone methods** option to ignore methods that aren't `public`.\n\nFor classes designed to be inherited, you may choose to override `clone()` and declare it as `protected`\nwithout implementing the `Cloneable` interface and decide whether to implement the `Cloneable` interface in subclasses."
        },
        {
          "shortName": "UseOfClone",
          "displayName": "Use of 'clone()' or 'Cloneable'",
          "enabled": false,
          "description": "Reports implementations of and calls to the `clone()` method and uses of `java.lang.Cloneable`.\n\nSome coding standards prohibit the use of `clone()` and recommend using a copy constructor or\nthe `static` factory method instead.\n\nThe inspection ignores calls to `clone()` on arrays because it's a correct and compact way to copy an array."
        },
        {
          "shortName": "CloneableImplementsClone",
          "displayName": "Cloneable class without 'clone()' method",
          "enabled": false,
          "description": "Reports classes implementing the `Cloneable` interface that don't override the `clone()` method.\n\nSuch classes use the default implementation of `clone()`,\nwhich isn't `public` but `protected`, and which does not copy the mutable state of the class.\n\nA quick-fix is available to generate a basic `clone()` method,\nwhich can be used as a basis for a properly functioning `clone()` method\nexpected from a `Cloneable` class.\n\n**Example:**\n\n\n      public class Data implements Cloneable {\n        private String[] names;\n      }\n\nAfter the quick-fix is applied:\n\n\n      public class Data implements Cloneable {\n        private String[] names;\n\n        @Override\n        public Data clone() {\n          try {\n            Data clone = (Data) super.clone();\n            // TODO: copy mutable state here, so the clone can't change the internals of the original\n            return clone;\n          } catch (CloneNotSupportedException e) {\n            throw new AssertionError();\n          }\n        }\n      }\n\nUse the **Ignore classes cloneable due to inheritance** option to ignore classes that are\n`Cloneable` because they inherit from the `Cloneable` class.\n\nUse the **Ignore when Cloneable is necessary to call clone() method of super class**\noption to ignore classes that require implementing `Cloneable` because they call the `clone()` method from a superclass."
        },
        {
          "shortName": "CloneCallsConstructors",
          "displayName": "'clone()' instantiates objects with constructor",
          "enabled": false,
          "description": "Reports calls to object constructors inside `clone()` methods.\n\nIt is considered good practice to call `clone()` to instantiate objects inside of a `clone()` method\ninstead of creating them directly to support later subclassing.\nThis inspection will not report\n`clone()` methods declared as `final`\nor `clone()` methods on `final` classes."
        },
        {
          "shortName": "CloneDeclaresCloneNotSupported",
          "displayName": "'clone()' does not declare 'CloneNotSupportedException'",
          "enabled": false,
          "description": "Reports `clone()` methods that do not declare `throws CloneNotSupportedException`.\n\nIf `throws CloneNotSupportedException` is not declared, the method's subclasses will not be able to prohibit cloning\nin the standard way. This inspection does not report `clone()` methods declared `final`\nand `clone()` methods on `final` classes.\n\nConfigure the inspection:\n\nUse the **Only warn on 'protected' clone methods** option to indicate that this inspection should only warn on `protected clone()` methods.\nThe *Effective Java* book (second and third edition) recommends omitting the `CloneNotSupportedException`\ndeclaration on `public` methods, because the methods that do not throw checked exceptions are easier to use.\n\nExample:\n\n\n      public class Example implements Cloneable {\n        // method doesn't declare 'throws CloneNotSupportedException'\n        protected Object clone() {\n            try {\n                return super.clone();\n            } catch (CloneNotSupportedException e) {\n                return null;\n            }\n        }\n      }\n"
        },
        {
          "shortName": "CloneReturnsClassType",
          "displayName": "'clone()' should have return type equal to the class it contains",
          "enabled": false,
          "description": "Reports `clone()` methods with return types different from the class they're located in.\n\nOften a `clone()` method will have a return type of `java.lang.Object`, which makes it harder to use by its clients.\n*Effective Java* (the second and third editions) recommends making the return type of the `clone()` method the same as the\nclass type of the object it returns.\n\n**Example:**\n\n\n      class Foo implements Cloneable {\n        public Object clone() {\n          try {\n            return super.clone();\n          } catch (CloneNotSupportedException e) {\n            throw new AssertionError();\n          }\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      class Foo implements Cloneable {\n        public Foo clone() {\n          try {\n            return (Foo)super.clone();\n          } catch (CloneNotSupportedException e) {\n            throw new AssertionError();\n          }\n        }\n      }\n"
        },
        {
          "shortName": "NonPublicClone",
          "displayName": "'clone()' method not 'public'",
          "enabled": false,
          "description": "Reports `clone()` methods that are `protected` and not `public`.\n\nWhen overriding the `clone()` method from `java.lang.Object`, it is expected to make the method `public`,\nso that it is accessible from non-subclasses outside the package."
        }
      ]
    },
    {
      "name": "RegExp",
      "inspections": [
        {
          "shortName": "RegExpRedundantEscape",
          "displayName": "Redundant character escape",
          "enabled": true,
          "description": "Reports redundant character escape sequences that can be replaced with unescaped characters preserving the meaning. Many escape sequences that are redundant inside square brackets `[]` of a character class are necessary outside of a character class.\n\n\nAlthough unescaped opening curly braces `{` outside of character classes are allowed in some dialects (JavaScript, Python, and so on),\nit can cause confusion and make the pattern less portable, because there are dialects that require escaping curly braces as characters.\nFor this reason the inspection does not report escaped opening curly braces.\n\n**Example:**\n\n\n      \\-\\;[\\.]\n\nAfter the quick-fix is applied:\n\n\n      -;[.]\n\n\nThe **Ignore escaped closing brackets '}' and '\\]'** option specifies whether to report `\\}` and `\\]` outside of a character class\nwhen they are allowed to be unescaped by the RegExp dialect.\n\nNew in 2017.3"
        },
        {
          "shortName": "RegExpUnexpectedAnchor",
          "displayName": "Begin or end anchor in unexpected position",
          "enabled": true,
          "description": "Reports `^` or `\\A` anchors not at the beginning of the pattern and `$`, `\\Z` or `\\z` anchors not at the end of the pattern. In the wrong position these RegExp anchors prevent the pattern from matching anything. In case of the `^` and `$` anchors, most likely the literal character was meant and the escape forgotten.\n\n**Example:**\n\n\n      (Price $10)\n\n\nNew in 2018.1"
        },
        {
          "shortName": "RegExpEscapedMetaCharacter",
          "displayName": "Escaped meta character",
          "enabled": true,
          "description": "Reports escaped meta characters. Some RegExp coding styles specify that meta characters should be placed inside a character class, to make the regular expression easier to understand. This inspection does not warn about the meta character `[`, `]` and `^`, because those would need additional escaping inside a character class.\n\n**Example:**\n\n\n      \\d+\\.\\d+\n\nAfter the quick-fix is applied:\n\n\n      \\d+[.]\\d+\n\nNew in 2017.1"
        },
        {
          "shortName": "RegExpDuplicateCharacterInClass",
          "displayName": "Duplicate character in character class",
          "enabled": true,
          "description": "Reports duplicate characters inside a RegExp character class. Duplicate characters are unnecessary and can be removed without changing the semantics of the regex.\n\n**Example:**\n\n\n      [aabc]\n\nAfter the quick-fix is applied:\n\n\n      [abc]\n"
        },
        {
          "shortName": "RegExpSimplifiable",
          "displayName": "Regular expression can be simplified",
          "enabled": false,
          "description": "Reports regular expressions that can be simplified.\n\n**Example:**\n\n\n      [a] [0-9] xx* [ah-hz]\n\nAfter the quick-fix is applied:\n\n\n      a \\d x+ [ahz]\n\nNew in 2022.1"
        },
        {
          "shortName": "RegExpEmptyAlternationBranch",
          "displayName": "Empty branch in alternation",
          "enabled": true,
          "description": "Reports empty branches in a RegExp alternation. An empty branch will only match the empty string, and in most cases that is not what is desired. This inspection will not report a single empty branch at the start or the end of an alternation.\n\n**Example:**\n\n\n      (alpha||bravo)\n\nAfter the quick-fix is applied:\n\n\n      (alpha|bravo)\n\nNew in 2017.2"
        },
        {
          "shortName": "RegExpUnnecessaryNonCapturingGroup",
          "displayName": "Unnecessary non-capturing group",
          "enabled": true,
          "description": "Reports unnecessary non-capturing groups, which have no influence on the match result.\n\n**Example:**\n\n\n      Everybody be cool, (?:this) is a robbery!\n\nAfter the quick-fix is applied:\n\n\n      Everybody be cool, this is a robbery!\n\nNew in 2021.1"
        },
        {
          "shortName": "RegExpSuspiciousBackref",
          "displayName": "Suspicious back reference",
          "enabled": false,
          "description": "Reports back references that will not be resolvable at runtime. This means that the back reference can never match anything. A back reference will not be resolvable when the group is defined after the back reference, or if the group is defined in a different branch of an alternation.\n\n**Example of a group defined after its back reference:**\n\n\n      \\1(abc)\n\n**Example of a group and a back reference in different branches:**\n\n\n      a(b)c|(xy)\\1z\n\nNew in 2022.1"
        },
        {
          "shortName": "RegExpSingleCharAlternation",
          "displayName": "Single character alternation",
          "enabled": true,
          "description": "Reports single char alternation in a RegExp. It is simpler to use a character class instead. This may also provide better matching performance.\n\n**Example:**\n\n\n      a|b|c|d\n\nAfter the quick-fix is applied:\n\n\n      [abcd]\n\n\nNew in 2017.1"
        },
        {
          "shortName": "RegExpRedundantNestedCharacterClass",
          "displayName": "Redundant nested character class",
          "enabled": true,
          "description": "Reports unnecessary nested character classes.\n\n**Example:**\n\n\n      [a-c[x-z]]\n\nAfter the quick-fix is applied:\n\n\n      [a-cx-z]\n\nNew in 2020.2"
        },
        {
          "shortName": "RegExpOctalEscape",
          "displayName": "Octal escape",
          "enabled": true,
          "description": "Reports octal escapes, which are easily confused with back references. Use hexadecimal escapes to avoid confusion.\n\n**Example:**\n\n\n      \\07\n\nAfter the quick-fix is applied:\n\n\n      \\x07\n\nNew in 2017.1"
        },
        {
          "shortName": "RegExpAnonymousGroup",
          "displayName": "Anonymous capturing group or numeric back reference",
          "enabled": false,
          "description": "Reports anonymous capturing groups and numeric back references in a RegExp. These are only reported when the RegExp dialect supports named group and named group references. Named groups and named back references improve code readability and are recommended to use instead. When a capture is not needed, matching can be more performant and use less memory by using a non-capturing group, i.e. `(?:xxx)` instead of `(xxx)`.\n\n**Example:**\n\n\n      (\\d\\d\\d\\d)\\1\n\nA better regex pattern could look like this:\n\n\n      (?<quad>\\d\\d\\d\\d)\\k<quad>\n\nNew in 2017.2"
        },
        {
          "shortName": "RegExpDuplicateAlternationBranch",
          "displayName": "Duplicate branch in alternation",
          "enabled": true,
          "description": "Reports duplicate branches in a RegExp alternation. Duplicate branches slow down matching and obscure the intent of the expression.\n\n**Example:**\n\n\n      (alpha|bravo|charlie|alpha)\n\nAfter the quick-fix is applied:\n\n\n      (alpha|bravo|charlie)\n\nNew in 2017.1"
        },
        {
          "shortName": "RegExpRepeatedSpace",
          "displayName": "Consecutive spaces",
          "enabled": true,
          "description": "Reports multiple consecutive spaces in a RegExp. Because spaces are not visible by default, it can be hard to see how many spaces are required. The RegExp can be made more clear by replacing the consecutive spaces with a single space and a counted quantifier.\n\n**Example:**\n\n\n      (     )\n\nAfter the quick-fix is applied:\n\n\n      ( {5})\n\n\nNew in 2017.1"
        }
      ]
    },
    {
      "name": "Style",
      "inspections": [
        {
          "shortName": "JavaStylePropertiesInvocation",
          "displayName": "Java-style property access",
          "enabled": false,
          "description": "Reports properties accessed via method calls.\n\n**Example:**\n\n\n      class Foo {\n          int foo\n      }\n\n      def bar = new Foo()\n      print(bar.getFoo())\n\nAfter the quick-fix is applied:\n\n\n      class Foo {\n          int foo\n      }\n\n      def bar = new Foo()\n      print(bar.foo)\n"
        },
        {
          "shortName": "GrUnnecessarySemicolon",
          "displayName": "Unnecessary semicolon",
          "enabled": false,
          "description": "Reports unnecessary semicolons.\n\n**Example:**\n\n\n      print 2; print 3 // semicolon is required\n      print 2; // semicolon is unnecessary\n"
        },
        {
          "shortName": "ChangeToMethod",
          "displayName": "Operator invocation can be replaced with method call",
          "enabled": false,
          "description": "Reports operator invocations that can be replaced with method calls.\n\n**Example:**\n\n\n      a + b\n\nAfter the quick-fix is applied:\n\n\n      a.plus(b)\n"
        },
        {
          "shortName": "ChangeToOperator",
          "displayName": "Method call can be replaced with operator invocation",
          "enabled": false,
          "description": "Reports method calls that can be replaced with operator invocations.\n\n**Example:**\n\n\n      a.plus(b)\n\nAfter the quick-fix is applied:\n\n\n      a + b\n"
        },
        {
          "shortName": "GroovyConditional",
          "displayName": "Ternary expression",
          "enabled": false,
          "description": "Reports ternary expressions.\n\nSome coding standards prohibit the use of the condition operator in favor of `if` statements."
        },
        {
          "shortName": "GrUnnecessaryAlias",
          "displayName": "Unnecessary import alias",
          "enabled": false,
          "description": "Reports unnecessary import aliases.\n\n**Example:**\n\n\n      import com.foo.Bar as Bar\n\nAfter the quick-fix is applied:\n\n\n      import com.foo.Bar\n"
        },
        {
          "shortName": "GrUnnecessaryNonSealedModifier",
          "displayName": "Unnecessary 'non-sealed' modifier",
          "enabled": false,
          "description": "Reports unnecessary `non-sealed` modifiers which used on methods, fields, or variables.\n\nThis modifier has effect only on classes, interfaces and traits.\n\n**Example:**\n\n\n      non-sealed boolean foo() {} // modifier is unnecessary\n      non-sealed Object bar // modifier is unnecessary\n\n      // modifier is required and therefore not highlighted\n      non-sealed class A {}\n"
        },
        {
          "shortName": "GrUnnecessaryDefModifier",
          "displayName": "Unnecessary 'def'",
          "enabled": false,
          "description": "Reports unnecessary `def` modifiers when used with explicit type declaration.\n\n**Example:**\n\n\n      def boolean foo() {} // modifier is unnecessary\n      def Object bar // modifier is unnecessary\n\n      // modifier is required and therefore not highlighted\n      def (int a, String b) = []\n"
        },
        {
          "shortName": "GrUnnecessaryFinalModifier",
          "displayName": "Unnecessary 'final'",
          "enabled": false,
          "description": "Reports unnecessary `final` modifiers when used with the record definition.\n\n**Example:**\n\n\n      final record R(int a) {} // modifier is unnecessary\n"
        },
        {
          "shortName": "GrUnnecessaryPublicModifier",
          "displayName": "Unnecessary 'public'",
          "enabled": false,
          "description": "Reports unnecessary `public` modifiers as Groovy classes and methods are `public` by default.\n\n**Example:**\n\n\n      public class Foo{\n          public void bar(){\n          }\n      }\n\nAfter the quick-fix is applied:\n\n\n      class Foo{\n          void bar(){\n          }\n      }\n"
        },
        {
          "shortName": "GrStringStyleViolation",
          "displayName": "String style violation",
          "enabled": false,
          "description": "Reports strings with quotation that doesn't match code style.\n\n**Example:**\n\n\n      def hw = \"Hello, world!\"\n\nAfter the quick-fix is applied:\n\n\n      def hw = 'Hello, world!'\n\nUse the fields provided below to specify code style for different kinds of strings."
        },
        {
          "shortName": "GrUnnecessarySealedModifier",
          "displayName": "Unnecessary 'sealed' modifier",
          "enabled": false,
          "description": "Reports unnecessary `sealed` modifiers which used on methods, fields, or variables.\n\nThis modifier has effect only on classes, interfaces and traits.\n\n**Example:**\n\n\n      sealed boolean foo() {} // modifier is unnecessary\n      sealed Object bar // modifier is unnecessary\n\n      // modifier is required and therefore not highlighted\n      sealed class A {}\n"
        }
      ]
    },
    {
      "name": "Code",
      "inspections": [
        {
          "shortName": "UseDPIAwareBorders",
          "displayName": "Use DPI-aware borders",
          "enabled": false,
          "description": "Reports usages of `javax.swing.border.EmptyBorder`.\n\n\nThese are not DPI-aware and can result in UI layout problems.\n\n\nQuick-fix performs replacement with `JBUI.Borders.empty()`."
        },
        {
          "shortName": "NonDefaultConstructor",
          "displayName": "Non-default constructors for service and extension class",
          "enabled": false,
          "description": "Reports extension/service class having a non-default (empty) constructor.\n\n\nOther dependencies should be acquired when needed in corresponding methods only.\nConstructor having `Project` for extension/service on the corresponding level is allowed."
        },
        {
          "shortName": "PresentationAnnotation",
          "displayName": "Invalid icon path in @Presentation",
          "enabled": false,
          "description": "Reports invalid and deprecated value for `icon` attribute in `com.intellij.ide.presentation.Presentation` annotation."
        },
        {
          "shortName": "UseVirtualFileEquals",
          "displayName": "Use 'VirtualFile#equals(Object)'",
          "enabled": false,
          "description": "Reports comparing `VirtualFile` instances using `==`.\n\n\nReplace with `equals()` call."
        },
        {
          "shortName": "InspectionUniqueToolbarId",
          "displayName": "Specify toolbar id",
          "enabled": false,
          "description": "Reports passing non-unique `place` parameter for `ActionManager.createActionToolbar()`.\n\n\nSpecifying proper `place` is required to distinguish Action's usage in `update()/actionPerformed()` via `AnActionEvent.getPlace()`."
        },
        {
          "shortName": "ActionIsNotPreviewFriendly",
          "displayName": "Field blocks intention preview",
          "enabled": false,
          "description": "Reports fields in `LocalQuickFix` implementations that prevent intention preview action from functioning properly.\n\n\nIntention preview is an IntelliJ platform feature that displays how quick-fix or intention action\nwill change the current file when applied. To implement this, `LocalQuickFix.generatePreview()`\nis called with a custom `ProblemDescriptor` that points to the non-physical copy of current file.\nNormally, it just delegates to `LocalQuickFix.applyFix()`. However, some quick-fixes\nmay refer directly or indirectly to physical elements and use them for writing. As a result,\npreview won't work, as the quick-fix will attempt to update physical PSI instead of non-physical one.\nTo avoid this, default implementation of `generatePreview()` delegates only if all the\ninstance fields of a quick-fix class have safe types: primitives, Strings, etc.\n\n\nYou may fix this problem in a number of ways:\n\n1. If the field does not actually store any PSI reference, or that PSI is used only for reading, you may annotate the field with `@SafeFieldForPreview`\n2. You may override `getFileModifierForPreview()` method and create a copy of the quick-fix rebinding it to the non-physical file copy which is supplied as a parameter. Use `PsiTreeUtil.findSameElementInCopy()` to find the corresponding PSI elements inside the supplied non-physical copy.\n3. Instead of storing PSI references in fields, try to extract all the necessary information from `ProblemDescriptor.getPsiElement()`.\n4. You may override `generatePreview()` method and provide completely custom preview behavior. For example, it's possible to display a custom HTML document instead of actual preview if your action does something besides modifying a current file.\n\n\nThis inspection does not report if a custom implementation of `getFileModifierForPreview()`\nor `generatePreview()` exists. However, this doesn't mean that the implementation is correct and preview works.\nPlease test. Also note that preview result is calculated in background thread, so you cannot start a write action\nduring the preview or do any operation that requires a write action. Finally, no preview is generated automatically\nif `startInWriteAction()` returns `false`. In this case, having custom `generatePreview()`\nimplementation is desired.\n\nNew in 2022.1"
        },
        {
          "shortName": "InspectionUsingGrayColors",
          "displayName": "Using new Color(a,a,a)",
          "enabled": false,
          "description": "Reports usages of `java.awt.Color` to create gray colors.\n\n\nQuick-fix **Convert to Gray** replaces it using `com.intellij.ui.Gray` constants instead.\n\n**Example:**\n`Color myGray = new Color(55, 55, 55);`\n\nAfter the quick-fix is applied:\n`Color myGray = Gray._55;`"
        },
        {
          "shortName": "MissingRecentApi",
          "displayName": "Usage of IntelliJ API not available in older IDEs",
          "enabled": false,
          "description": "Reports usages of IntelliJ Platform API introduced in a version *newer* than the one specified in `<idea-version>` `@since-build` in `plugin.xml`.\n\n\nUsing such API may lead to incompatibilities of the plugin with older IDE versions.\n\n\nTo avoid possible issues when running the plugin in older IDE versions, increase `since-build` accordingly,\nor remove usages of this API.\n\nConfigure the inspection:\nIf `<idea-version>` `@since/until-build` attributes are not specified in `plugin.xml`, set **Since** /**Until** explicitly."
        },
        {
          "shortName": "MissingAccessibleContext",
          "displayName": "Accessible context is missing",
          "enabled": false,
          "description": "Reports Swing components that do not provide accessibility context.\n\n\nThis information is used by screen readers. Failing to provide it makes the component inaccessible for\nvisually impaired users.\n\n**Example:**\n\n      ListCellRenderer<String> renderer = (list, val, index, sel, cell) -> {\n        JPanel panel = new JPanel();\n        return panel;\n      };\n\n\nTo fix the problem, you should either call `setAccessibleName()` on the returned `JPanel`\nor override its `getAccessibleContext()` method.\n\n\nThe returned text should reflect the purpose\nof the component. For example, in the case of `ListCellRenderer`, this would be the text of the menu\nitem."
        },
        {
          "shortName": "UseJBColor",
          "displayName": "Use Darcula aware JBColor",
          "enabled": false,
          "description": "Reports usages of `java.awt.Color`.\n\n\nThese are not aware of \"dark\" themes (e.g., bundled \"Darcula\") and might result in bad looking UI.\n\n\nQuick-fix replaces usages with `JBColor`, which defines \"dark\" color variant."
        },
        {
          "shortName": "UElementAsPsi",
          "displayName": "UElement as PsiElement usage",
          "enabled": false,
          "description": "Reports usage of UAST `UElement` as `PsiElement`.\n\n\nThe `PsiElement` obtained this way is ambiguous.\n\n\nTo obtain \"physical\" `PsiElement` use `UElementKt.getSourcePsiElement()`,\nfor `PsiElement` that \"emulates\" behaviour of Java-elements (`PsiClass`, `PsiMethod`, etc.)\nuse `UElementKt.getAsJavaPsiElement()`.\n\n\nSee [UAST - Unified Abstract Syntax Tree](https://plugins.jetbrains.com/docs/intellij/uast.html) in SDK Docs."
        },
        {
          "shortName": "UsePrimitiveTypes",
          "displayName": "Use 'PsiType#equals(Object)' with primitive types",
          "enabled": false,
          "description": "Reports comparing `PsiPrimitiveType` instances using `==`.\n\n\nPrimitive types should be compared with `equals` as Java 8 type annotations are also applicable for them.\n\n\nReplace with `equals()` call."
        },
        {
          "shortName": "QuickFixGetFamilyNameViolation",
          "displayName": "QuickFix's getFamilyName() implementation must not depend on a specific context",
          "enabled": false,
          "description": "Reports `QuickFix#getFamilyName()` using contextual information.\n\n\nThis method must not use any non-static information."
        },
        {
          "shortName": "UseCouple",
          "displayName": "Use Couple instead of Pair",
          "enabled": false,
          "description": "Reports usages of `Pair<T, T>` replaceable by `Couple<T>`.\n\n\nQuick-fix performs replacement."
        },
        {
          "shortName": "UsePluginIdEquals",
          "displayName": "Use 'PluginId#equals(Object)'",
          "enabled": false,
          "description": "Reports comparing `PluginId` instances using `==`.\n\n\nReplace with `equals()` call."
        },
        {
          "shortName": "StatefulEp",
          "displayName": "Stateful extension",
          "enabled": false,
          "description": "Reports extensions and quick-fixes holding potentially leaking state.\n\n\nKeeping references to `PsiElement`, `PsiReference`, or `Project` instances can result in memory leaks.\n\n\nIdeally, these should be stateless.\nFor quick-fix, see `LocalQuickFixOnPsiElement` as a convenient base class."
        },
        {
          "shortName": "IncorrectParentDisposable",
          "displayName": "Incorrect parentDisposable parameter",
          "enabled": false,
          "description": "Reports using `Application` or `Project` as a parent `Disposable` in plugin code.\n\n\nSuch usages will lead to plugins not being unloaded correctly.\nPlease see [Choosing a\nDisposable Parent](https://plugins.jetbrains.com/docs/intellij/disposers.html?from=IncorrectParentDisposable#choosing-a-disposable-parent) in SDK Docs."
        },
        {
          "shortName": "SerializableCtor",
          "displayName": "Non-default constructor in serializable class",
          "enabled": false,
          "description": "Reports non-default constructor in serializable classes.\n\n\nThe platform's `IonObjectSerializer` requires specifying `@PropertyMapping` explicitly.\n\n\nQuick-fix generates necessary `@PropertyMapping` annotation for the constructor."
        },
        {
          "shortName": "PsiElementConcatenation",
          "displayName": "Using PsiElement string representation to generate new expression is incorrect",
          "enabled": false,
          "description": "Reports direct usage of `PsiElement` and `PsiType` in strings.\n\n\nWhen building strings for `PsiJavaParserFacade.createExpressionFromText()` (or similar methods), `PsiElement.getText()` should be used\ninstead."
        },
        {
          "shortName": "ComponentNotRegistered",
          "displayName": "Component/Action not registered",
          "enabled": false,
          "description": "Reports plugin components and actions that are not registered in a `plugin.xml` descriptor.\n\n\nThis eases developing new components when using the \"Create Class\" intention and helps keep track of potentially obsolete components.\n\n\nProvided quick-fix to register the component adds necessary registration in `plugin.xml` descriptor.\n\nConfigure the inspection:\n\n* Use the **Check Actions** option to turn off the check for Actions, as they may be intentionally created and registered dynamically.\n* Use the **Ignore non-public classes** option to ignore abstract and non-public classes."
        },
        {
          "shortName": "UnsafeReturnStatementVisitor",
          "displayName": "Unsafe return statements visitor",
          "enabled": false,
          "description": "Reports unsafe use of `JavaRecursiveElementVisitor.visitReturnStatement()`.\n\n\nProcessing `PsiReturnStatement`s\neven if they belong to another `PsiClass` or `PsiLambdaExpression` is a bug in most cases.\n\n\nQuick-fix inserts necessary explicit `visitClass()/visitLambdaExpression()` method(s)."
        },
        {
          "shortName": "UnresolvedPluginConfigReference",
          "displayName": "Unresolved plugin configuration reference",
          "enabled": false,
          "description": "Reports unresolved references to plugin configuration elements.\n\n\nReferencing extension with an unknown `id` might result in errors at runtime.\n\n\nThe following extension points are supported:\n\n* `com.intellij.advancedSetting` in resource bundle `advanced.setting.*` key\n* `com.intellij.experimentalFeature` in `Experiments.isFeatureEnabled()/setFeatureEnabled()`\n* `com.intellij.notificationGroup` in `Notification` constructor and `NotificationGroupManager.getNotificationGroup()`\n* `com.intellij.registryKey` in `Registry` methods `key` parameter\n* `com.intellij.toolWindow` in resource bundle `toolwindow.stripe.*` key"
        },
        {
          "shortName": "UseDPIAwareInsets",
          "displayName": "Use DPI-aware insets",
          "enabled": false,
          "description": "Reports usages of `java.awt.Insets`.\n\n\nThese are not DPI-aware and can result in UI layout problems.\n\n\nQuick-fix performs replacement with `JBUI.insets()`."
        },
        {
          "shortName": "UndesirableClassUsage",
          "displayName": "Undesirable class usage",
          "enabled": false,
          "description": "Reports usages of undesirable classes (mostly Swing components).\n\n\nQuick-fix offers replacement with recommended IntelliJ Platform replacement."
        },
        {
          "shortName": "LeakableMapKey",
          "displayName": "Map key may leak",
          "enabled": false,
          "description": "Reports using `Language` or `FileType` as a map key in plugin code.\n\n\nSuch usages might lead to inability to unload the plugin properly.\n\n\nPlease consider using `String` as keys instead.\n\n\nSee [Dynamic\nPlugins](https://plugins.jetbrains.com/docs/intellij/dynamic-plugins.html) in SDK Docs for more information."
        },
        {
          "shortName": "UnsafeVfsRecursion",
          "displayName": "Unsafe VFS recursion",
          "enabled": false,
          "description": "Reports usage of `VirtualFile.getChildren()` inside recursive methods.\n\n\nThis may cause endless loops when iterating over cyclic symlinks.\nUse `VfsUtilCore.visitChildrenRecursively()` instead."
        },
        {
          "shortName": "FileEqualsUsage",
          "displayName": "File.equals() usage",
          "enabled": false,
          "description": "Reports usages of `java.io.File.equals()/hashCode()/compareTo()` methods.\n\n\nThese do not honor case-insensitivity on macOS.\n\n\nUse `com.intellij.openapi.util.io.FileUtil.filesEquals()/fileHashCode()/compareFiles()` methods instead."
        }
      ]
    },
    {
      "name": "UI form",
      "inspections": [
        {
          "shortName": "NoLabelFor",
          "displayName": "No label for component",
          "enabled": false,
          "description": "Reports components that do not have any static text and do not have any label marked with `setLabelFor` for this component.\n\nComponents that do not have static text include edit fields and combo boxes.\nSuch components cannot be activated with a keyboard shortcut. The quick-fix for this inspection\nallows you to automatically associate an adjacent label with the problematic component."
        },
        {
          "shortName": "InvalidPropertyKeyForm",
          "displayName": "Invalid property key in a UI form",
          "enabled": false,
          "description": "Reports unresolved references to .properties files."
        },
        {
          "shortName": "MissingMnemonic",
          "displayName": "Missing mnemonics",
          "enabled": false,
          "description": "Reports focusable components with the `text` property or labels with the assigned `labelFor` property that do not have a mnemonic character. The quick-fix assigns a unique mnemonic to such a component."
        },
        {
          "shortName": "OneButtonGroup",
          "displayName": "Button group with one button",
          "enabled": false,
          "description": "Reports `ButtonGroup` instances that contain only one `JRadioButton`."
        },
        {
          "shortName": "NoScrollPane",
          "displayName": "Scrollable component not in JScrollPane",
          "enabled": false,
          "description": "Reports `Scrollable` components, except for `JTextField`, that are not placed in `JScrollPane`. The quick-fix surrounds the problematic component with a scroll pane."
        },
        {
          "shortName": "FormSpellChecking",
          "displayName": "Typo in a UI form",
          "enabled": false,
          "description": "Reports typos and misspelling in your UI forms (for example, in a `JLabel` text or `JPanel` title) and fixes them\nwith one click."
        },
        {
          "shortName": "DuplicateMnemonic",
          "displayName": "Duplicate mnemonics",
          "enabled": false,
          "description": "Reports components that have duplicated mnemonic characters.\n\nThe quick-fix assigns a unique mnemonic character to each of the components."
        },
        {
          "shortName": "I18nForm",
          "displayName": "Hardcoded string literal in a UI form",
          "enabled": false,
          "description": "Reports any instances of hardcoded strings in your UI forms.\n\nHardcoded string literals are usually errors in\nan internationalized environment.\nThis inspection does not report empty strings and strings consisting of only whitespace.\n\nThe quick-fix transforms a string literal\ninto a reference to a property in a resource bundle."
        },
        {
          "shortName": "NoButtonGroup",
          "displayName": "Radio button not in a group",
          "enabled": false,
          "description": "Reports `JRadioButton` components that are not placed in `ButtonGroup`. A quick-fix is available to group radio buttons placed in adjacent grid cells."
        },
        {
          "shortName": "BoundFieldAssignment",
          "displayName": "Assignment to UI-bound field",
          "enabled": false,
          "description": "Reports assignments to fields which are bound to components in UI Designer forms.\n\nSuch assignments will cause the component setup code generated by UI Designer\nfor such fields to be ignored."
        }
      ]
    },
    {
      "name": "Redundant modifiers",
      "inspections": [
        {
          "shortName": "RedundantModifiersUtilityClassLombok",
          "displayName": "@UtilityClass modifiers",
          "enabled": false,
          "description": "Reports unneeded modifiers for classes annotated with `@UtilityClass`."
        },
        {
          "shortName": "RedundantModifiersValueLombok",
          "displayName": "@Value modifiers",
          "enabled": true,
          "description": "Reports unneeded modifiers for classes annotated with `@Value`."
        },
        {
          "shortName": "RedundantModifiersValLombok",
          "displayName": "Unnecessary final before 'val'",
          "enabled": true,
          "description": "Reports unneeded `final` modifiers before `val`."
        }
      ]
    },
    {
      "name": "Class metrics",
      "inspections": [
        {
          "shortName": "ConstructorCount",
          "displayName": "Class with too many constructors",
          "enabled": false,
          "description": "Reports classes whose number of constructors exceeds the specified maximum.\n\nClasses with too many constructors are prone to initialization errors, and often modeling such a class as multiple subclasses is preferable.\n\nConfigure the inspection:\n\n* Use the **Constructor count limit** field to specify the maximum allowed number of constructors in a class.\n* Use the **Ignore deprecated constructors** option to avoid adding deprecated constructors to the total count."
        },
        {
          "shortName": "ClassNestingDepth",
          "displayName": "Inner class too deeply nested",
          "enabled": false,
          "description": "Reports classes whose number of nested inner classes exceeds the specified maximum.\n\nNesting inner classes inside other inner classes is confusing and indicates that a refactoring may be necessary.\n\nUse the **Nesting limit** field to specify the maximum allowed nesting depth for a class."
        },
        {
          "shortName": "ClassCoupling",
          "displayName": "Overly coupled class",
          "enabled": false,
          "description": "Reports classes that reference too many other classes.\n\nClasses with too high coupling can be very fragile, and should probably be split into smaller classes.\n\nConfigure the inspection:\n\n* Use the **Class coupling limit** field to specify the maximum allowed coupling for a class.\n* Use the **Include couplings to java system classes** option to specify whether references to system classes (those in the `java.`or `javax.` packages) should be counted.\n* Use the **Include couplings to library classes** option to specify whether references to any library classes should be counted."
        },
        {
          "shortName": "AnonymousClassComplexity",
          "displayName": "Overly complex anonymous class",
          "enabled": false,
          "description": "Reports anonymous inner classes whose total complexity exceeds the specified maximum.\n\nThe total complexity of a class is the sum of cyclomatic complexities of all the methods\nand initializers the class declares. Inherited methods and initializers are not counted\ntoward the total complexity.\n\nAnonymous classes should have very low complexity otherwise they are hard to understand and should be promoted to become named inner classes.\n\nUse the **Cyclomatic complexity limit** field to specify the maximum allowed complexity for a class."
        },
        {
          "shortName": "ClassInheritanceDepth",
          "displayName": "Class too deep in inheritance tree",
          "enabled": false,
          "description": "Reports classes that are too deep in the inheritance hierarchy.\n\nClasses that are too deeply inherited may be confusing and indicate that a refactoring is necessary.\n\nAll superclasses from a library are treated as a single superclass, libraries are considered unmodifiable.\n\nUse the **Inheritance depth limit** field to specify the maximum inheritance depth for a class."
        },
        {
          "shortName": "MethodCount",
          "displayName": "Class with too many methods",
          "enabled": false,
          "description": "Reports classes whose number of methods exceeds the specified maximum.\n\nClasses with too many methods are often trying to 'do too much'. Consider splitting such a class into multiple smaller classes.\n\nConfigure the inspection:\n\n* Use the **Method count limit** field to specify the maximum allowed number of methods in a class.\n* Use the **Ignore simple getter and setter methods** option to ignore simple getters and setters in method count.\n* Use the **Ignore methods overriding/implementing a super method** to ignore methods that override or implement a method from a superclass."
        },
        {
          "shortName": "ClassComplexity",
          "displayName": "Overly complex class",
          "enabled": false,
          "description": "Reports classes whose total complexity exceeds the specified maximum.\n\nThe total complexity of a class is the sum of cyclomatic complexities of all the methods\nand initializers the class declares. Inherited methods and initializers are not counted\ntoward the total complexity.\n\nToo high complexity indicates that the class should be refactored into several smaller classes.\n\nUse the **Cyclomatic complexity limit** field below to specify the maximum allowed complexity for a class."
        },
        {
          "shortName": "AnonymousClassMethodCount",
          "displayName": "Anonymous inner class with too many methods",
          "enabled": false,
          "description": "Reports anonymous inner classes whose method count exceeds the specified maximum.\n\nAnonymous classes with numerous methods may be\ndifficult to understand and should be promoted to become named inner classes.\n\nUse the **Method count limit** field to specify the maximum allowed number of methods in an anonymous inner class."
        },
        {
          "shortName": "FieldCount",
          "displayName": "Class with too many fields",
          "enabled": false,
          "description": "Reports classes whose number of fields exceeds the specified maximum.\n\nClasses with a large number of fields are often trying to do too much. Consider splitting such a class into multiple smaller classes.\n\nConfigure the inspection:\n\n* Use the **Field count limit** field to specify the maximum allowed number of fields in a class.\n* Use the **Include constant fields in count** option to indicate whether constant fields should be counted.\n* By default only immutable `static final` objects are counted as constants. Use the **'static final' fields count as constant** option to count any `static final` field as constant.\n* Use the **Include enum constants in count** option to specify whether `enum` constants in `enum` classes should be counted."
        }
      ]
    },
    {
      "name": "Method",
      "inspections": [
        {
          "shortName": "BooleanMethodNameMustStartWithQuestion",
          "displayName": "Boolean method name must start with question word",
          "enabled": false,
          "description": "Reports boolean methods whose names do not start with a question word.\n\nBoolean methods that override library methods are ignored by this inspection.\n\n**Example:**\n\n    boolean empty(List<String> list) {\n      return list.isEmpty();\n    }\n\nA quick-fix that renames such methods is available only in the editor.\n\nConfigure the inspection:\n\n* Use the **Boolean method name prefixes** list to specify acceptable question words to start boolean method names with.\n* Use the **Ignore methods with 'java.lang.Boolean' return type** option to ignore methods with the `java.lang.Boolean` return type.\n* Use the **Ignore boolean methods in an @interface** option to ignore boolean methods in annotation types (`@interface`).\n* Use the **Ignore methods overriding/implementing a super method** to ignore methods the have supers."
        },
        {
          "shortName": "MisspelledMethodName",
          "displayName": "Method names differing only by case",
          "enabled": false,
          "description": "Reports cases in which multiple methods of a class have the names that differ only by case. Such names may be very confusing.\n\n**Example:**\n\n\n      public int hashcode() { // reported, should be hashCode probably?\n        return 0;\n      }\n\nA quick-fix that renames such methods is available only in the editor.\n\nUse the **Ignore methods overriding/implementing a super method** option to ignore methods overriding or implementing a method from\nthe superclass."
        },
        {
          "shortName": "LambdaUnfriendlyMethodOverload",
          "displayName": "Lambda-unfriendly method overload",
          "enabled": false,
          "description": "Reports overloaded methods that take functional interfaces with conflicting abstract method signatures.\n\nSuch overloads introduce ambiguity and require callers to cast lambdas to a specific type or specify lambda parameter types explicitly.\nIt is preferable to give the overloaded methods different names to eliminate ambiguity.\n\nExample:\n\n\n      interface MyExecutor {\n        void execute(Supplier<?> supplier);\n        void execute(Callable<?> callable);\n      }\n\n\nHere, `Supplier` and `Callable` are functional interfaces\nwhose single abstract methods do not take any parameters and return a non-void value.\nAs a result, the type of the lambda cannot be inferred at the call site unless an explicit cast is used."
        },
        {
          "shortName": "OverloadedMethodsWithSameNumberOfParameters",
          "displayName": "Overloaded methods with same number of parameters",
          "enabled": false,
          "description": "Reports methods that are declared in the same class, have the same name, and the same number of parameters. Such overloads cam be very confusing because it can be unclear which overload gets called.\n\n**Example:**\n\n\n      class Main {\n        public static void execute(Runnable r) {}\n        public static <T> void execute(RunnableFuture<T> c) {}\n      }\n\n\nUse the option to ignore overloaded methods whose parameter types are definitely incompatible."
        },
        {
          "shortName": "MethodNameSameAsClassName",
          "displayName": "Method name same as class name",
          "enabled": false,
          "description": "Reports methods that are named identically to their class. While such naming is allowed by the Java language, by convention it is reserved for defining constructors. Using it for methods is probably a mistake or bad practice.\n\n**Example:**\n\n\n      class MyClass {\n        int val;\n\n        // Method MyClass named identically to its containing class.\n        // Likely, 'void' was added by mistake.\n        void MyClass(int val) {\n          this.val = val;\n        }\n      }\n\nWhen appropriate, a quick-fix converts the method to a constructor:\n\n\n      class MyClass {\n        int val;\n\n        MyClass(int val) {\n          this.val = val;\n        }\n      }\n\nAnother quick-fix renames the method."
        },
        {
          "shortName": "MethodNameSameAsParentName",
          "displayName": "Method name same as parent class name",
          "enabled": false,
          "description": "Reports methods that have the same name as the superclass of the method's class, as such a method name may be confusing.\n\nThis inspection doesn't check interfaces or superclasses deep in the hierarchy.\n\n**Example:**\n\n\n      class Parent {}\n      class Child extends Parent {\n         public Parent Parent() {\n           return null;\n         }\n      }\n\nA quick-fix that renames such methods is available only in the editor."
        },
        {
          "shortName": "NewMethodNamingConvention",
          "displayName": "Method naming convention",
          "enabled": false,
          "description": "Reports methods whose names are too short, too long, or do not follow the specified regular expression pattern.\n\nInstance methods that override library\nmethods and constructors are ignored by this inspection.\n\n**Example:** if the inspection is enabled for static methods, and the minimum specified method name length is 4 (the default),\nthe following static method produces a warning, because the length of its name is 3, which is less\nthan 4: `public static int max(int a, int b)`.\n\nA quick-fix that renames such methods is available only in the editor.\n\nConfigure the inspection:\n\nUse the list in the **Options** section to specify which methods should be checked. Deselect the checkboxes for the method types for which\nyou want to skip the check. Specify **0** in the length fields to skip the corresponding checks.\n\nRegular expressions should be specified in the standard `java.util.regex` format."
        },
        {
          "shortName": "NonBooleanMethodNameMayNotStartWithQuestion",
          "displayName": "Non-boolean method name must not start with question word",
          "enabled": false,
          "description": "Reports non-boolean methods whose names start with a question word. Such method names may be confusing.\n\nNon-boolean methods that override library methods are ignored by this inspection.\n\n**Example:**\n\n\n      public void hasName(String name) {\n        assert names.contains(name);\n      }\n\nA quick-fix that renames such methods is available only in the editor.\n\nConfigure the inspection:\n\n* Use the **Boolean method name prefixes** list to specify the question words that should be used only for boolean methods.\n* Use the **Ignore methods with 'java.lang.Boolean' return type** option to ignore methods with `java.lang.Boolean` return type.\n* Use the **Ignore methods overriding/implementing a super method** option to ignore methods which have supers."
        },
        {
          "shortName": "OverloadedVarargsMethod",
          "displayName": "Overloaded varargs method",
          "enabled": false,
          "description": "Reports varargs methods with the same name as other methods in the class or in a superclass. Overloaded methods that take a variable number of arguments can be very confusing because it is often unclear which overload gets called.\n\n**Example:**\n\n\n        public void execute(Runnable... r) {} // warning\n        public void execute(Runnable r1, Runnable r2) {}\n"
        }
      ]
    },
    {
      "name": "Dependency issues",
      "inspections": [
        {
          "shortName": "ClassWithTooManyTransitiveDependents",
          "displayName": "Class with too many transitive dependents",
          "enabled": false,
          "description": "Reports a class on which too many other classes are directly or indirectly dependent.\n\nAny modification to such a class may require changing many other classes, which may be expensive.\n\nOnly top-level classes are reported.\n\nUse the **Maximum number of transitive dependents** field to specify the maximum allowed number of direct or indirect dependents\nfor a class.\n\nAvailable only from **Code \\| Inspect Code** or\n**Code \\| Analyze Code \\| Run Inspection by Name** and isn't reported in the editor."
        },
        {
          "shortName": "ClassWithTooManyTransitiveDependencies",
          "displayName": "Class with too many transitive dependencies",
          "enabled": false,
          "description": "Reports classes that are directly or indirectly dependent on too many other classes.\n\nModifications to any dependency of such a class may require changing the class thus making it prone to instability.\n\nOnly top-level classes are reported.\n\nUse the **Maximum number of transitive dependencies** field to specify the maximum allowed number of direct or indirect dependencies\nfor a class.\n\nAvailable only from **Code \\| Inspect Code** or\n**Code \\| Analyze Code \\| Run Inspection by Name** and isn't reported in the editor."
        },
        {
          "shortName": "ClassWithTooManyDependents",
          "displayName": "Class with too many dependents",
          "enabled": false,
          "description": "Reports a class on which too many other classes are directly dependent.\n\nAny modification to such a class may require changing many other classes, which may be expensive.\n\nOnly top-level classes are reported.\n\nUse the field below to specify the maximum allowed number of dependents for a class.\n\nAvailable only from **Code \\| Inspect Code** or\n**Code \\| Analyze Code \\| Run Inspection by Name** and isn't reported in the editor."
        },
        {
          "shortName": "CyclicClassDependency",
          "displayName": "Cyclic class dependency",
          "enabled": false,
          "description": "Reports classes that are mutually or cyclically dependent on other classes.\n\nSuch cyclic dependencies make code fragile and hard to maintain.\n\nAvailable only from **Code \\| Inspect Code** or\n**Code \\| Analyze Code \\| Run Inspection by Name** and isn't reported in the editor."
        },
        {
          "shortName": "CyclicPackageDependency",
          "displayName": "Cyclic package dependency",
          "enabled": false,
          "description": "Reports packages that are mutually or cyclically dependent on other packages.\n\nSuch cyclic dependencies make code fragile and hard to maintain.\n\nAvailable only from **Code \\| Inspect Code** or\n**Code \\| Analyze Code \\| Run Inspection by Name** and isn't reported in the editor."
        },
        {
          "shortName": "ClassWithTooManyDependencies",
          "displayName": "Class with too many dependencies",
          "enabled": false,
          "description": "Reports classes that are directly dependent on too many other classes in the project.\n\nModifications to any dependency of such classes may require changing the class, thus making it prone to instability.\n\nOnly top-level classes are reported.\n\nUse the **Maximum number of dependencies** field to specify the maximum allowed number of dependencies for a class.\n\nAvailable only from **Code \\| Inspect Code** or\n**Code \\| Analyze Code \\| Run Inspection by Name** and isn't reported in the editor."
        }
      ]
    },
    {
      "name": "Compiler issues",
      "inspections": [
        {
          "shortName": "JavacQuirks",
          "displayName": "Javac quirks",
          "enabled": true,
          "description": "Reports known Javac issues, performance problems, and incompatibilities. For example, type inference may be slow when it has to process many nested calls.\n\nThe following code triggers a warning, as vararg method call has 50+ poly arguments:\n\n\n      Arrays.asList(\n          Arrays.asList(\"a\", \"b\"),\n          ...\n          Arrays.asList(\"a100\", \"b100\"));\n\nThe quick-fix adds explicit type arguments, which makes compilation and IDE processing much faster:\n\n\n      //noinspection RedundantTypeArguments\n      Arrays.<List<String>>asList(\n          Arrays.asList(\"a\", \"b\"),\n          ...\n          Arrays.asList(\"a100\", \"b100\"));\n"
        },
        {
          "shortName": "UNCHECKED_WARNING",
          "displayName": "Unchecked warning",
          "enabled": false,
          "description": "Reports code on which an unchecked warning will be issued by the javac compiler. Every unchecked warning may potentially trigger `ClassCastException` at runtime.\n\nExample:\n\n\n      List items = Arrays.asList(\"string\", \"string\");\n      List<Integer> numbers = Collections.unmodifiableList(items); // unchecked assignment\n\nThe quick-fix tries to generify the containing file,\nwhich may expose any problems in the editor and during compilation that previously only appeared at runtime:\n\n\n      List<String> items = Arrays.asList(\"string\", \"string\");\n      List<Integer> numbers = Collections.unmodifiableList(items); // incompatible types\n"
        },
        {
          "shortName": "PreviewFeature",
          "displayName": "Preview Feature warning",
          "enabled": false,
          "description": "Reports usages of Preview Feature APIs, i.e. of a module, package, class, interface, method, constructor, field, or enum constant in the `java.*` or `javax.*` namespace annotated with `@PreviewFeature`.\n\n\nA preview feature is a new feature of the Java language, Java Virtual Machine, or Java SE API that is fully specified, fully implemented,\nand is yet impermanent. The notion of a preview feature is defined in [JEP 12](https://openjdk.java.net/jeps/12).\n\n\nIf some piece of code depends on a preview API, it may stop compiling in future JDK versions if the feature is changed or removed.\n\nThe inspection only reports if the language level of the project or module is **Preview**.\n\nNew in 2021.1"
        },
        {
          "shortName": "SynchronizeOnValueBasedClass",
          "displayName": "Value-based warnings",
          "enabled": false,
          "description": "Reports attempts to synchronize on an instance of a value-based class that produce compile-time warnings and raise run-time exceptions starting from Java 16.\n\n\nFor example, `java.lang.Double` is annotated with `jdk.internal.ValueBased`, so the following code will\nproduce a compile-time warning:\n\n\n    Double d = 20.0;\n    synchronized (d) { ... } // javac warning\n\nNew in 2021.1"
        }
      ]
    },
    {
      "name": "Annotations",
      "inspections": [
        {
          "shortName": "DelegatesTo",
          "displayName": "@DelegatesTo",
          "enabled": false,
          "description": "Reports unused `@DelegatesTo.Target` annotations and unresolved `@DelegatedTo.target` annotation attribute values.\n\n**Example:**\n\n\n      // unused target 't1' and unresolved target 't2'\n      def m(\n          @DelegatesTo.Target('t1') target,\n          @DelegatesTo(target = 't2') Closure c\n      ) {}\n"
        },
        {
          "shortName": "GrAnnotationReferencingUnknownIdentifiers",
          "displayName": "@TupleConstructor and @MapConstructor",
          "enabled": false,
          "description": "Reports unresolved identifiers in `@TupleConstructor` and `@MapConstructor` `includes` and `excludes` annotation attribute values.\n\n**Example:**\n\n\n      // unresolved 'c'\n      @TupleConstructor(includes = ['a', 'b', 'c'])\n      class X {\n          def a\n          def b\n      }\n"
        },
        {
          "shortName": "GrPOJO",
          "displayName": "@POJO without @CompileStatic",
          "enabled": false,
          "description": "Reports annotation `@groovy.transform.stc.POJO` applied without `@groovy.transform.CompileStatic`.\n\n\nAnnotation `@POJO` changes compilation process of Groovy classes to bytecode. It has no effect without explicitly enabled static compilation (which is done via `@CompileStatic` annotation).\n\n**Example:**\n\n\n      @POJO // reports @POJO\n      class A {}\n"
        },
        {
          "shortName": "SingletonConstructor",
          "displayName": "@Singleton constructors",
          "enabled": false,
          "description": "Reports constructors of classes annotated by `@Singleton` unless it is declared non-strict.\n\n**Example:**\n\n\n      @Singleton\n      class Foo{\n          Foo(){\n          }\n      }\n\nThere are two possible quick-fixes: either to remove the constructor or to declare `@Singleton` non-strict.\n\nAfter the quick-fix is applied:\n\n\n      @Singleton\n      class Foo{\n      }\n\nor:\n\n\n      @Singleton(strict = false)\n      class Foo{\n          Foo(){\n          }\n      }\n"
        },
        {
          "shortName": "GrNamedVariantLabels",
          "displayName": "@NamedVariant/@NamedParam/@NamedDelegate unresolved label",
          "enabled": false,
          "description": "Reports unresolved argument labels in calls of methods annotated by `@NamedVariant`/`@NamedParam`/`@NamedDelegate`.\n\n**Example:**\n\n\n      @groovy.transform.NamedVariant\n      def foo(a, b) {}\n\n      // unresolved label 'c'\n      foo(a: 1, b: 2, c: 3)\n"
        }
      ]
    },
    {
      "name": "Proofreading",
      "inspections": [
        {
          "shortName": "SpellCheckingInspection",
          "displayName": "Typo",
          "enabled": false,
          "description": "Reports typos and misspellings in your code, comments, and literals and fixes them with one click."
        }
      ]
    },
    {
      "name": "Manifest",
      "inspections": [
        {
          "shortName": "MissingFinalNewline",
          "displayName": "Missing final new line",
          "enabled": false,
          "description": "Reports if manifest files do not end with a final newline as required by the JAR file specification."
        },
        {
          "shortName": "MisspelledHeader",
          "displayName": "Unknown or misspelled header name",
          "enabled": false,
          "description": "Reports any unknown and probably misspelled header names and provides possible variants."
        }
      ]
    },
    {
      "name": "Ant",
      "inspections": [
        {
          "shortName": "AntMissingPropertiesFileInspection",
          "displayName": "Missing properties file",
          "enabled": false,
          "description": "|------------------------------------|\n| Reports missing .properties files. |"
        },
        {
          "shortName": "AntResolveInspection",
          "displayName": "Ant references resolve problems",
          "enabled": false,
          "description": "|--------------------------------------------------------------------------------------------------|\n| Reports unresolved references on properties and custom type definitions that cannot be resolved. |"
        },
        {
          "shortName": "AntDuplicateTargetsInspection",
          "displayName": "Duplicate targets",
          "enabled": false,
          "description": "|--------------------------------------------------------|\n| Reports duplicate `targets` in the current build file. |"
        }
      ]
    },
    {
      "name": "Method metrics",
      "inspections": [
        {
          "shortName": "NestingDepth",
          "displayName": "Overly nested method",
          "enabled": false,
          "description": "Reports methods whose body contain too deeply nested statements.\n\nMethods with too deep statement\nnesting may be confusing and are a good sign that refactoring may be necessary.\n\nUse the **Nesting depth limit** field to specify the maximum allowed nesting depth for a method."
        },
        {
          "shortName": "NonCommentSourceStatements",
          "displayName": "Overly long method",
          "enabled": false,
          "description": "Reports methods whose number of statements exceeds the specified maximum.\n\nMethods with too many statements may be confusing and are a good sign that refactoring is necessary.\n\nThe following statements are not counted:\n\n* empty statements (semicolons)\n* block statements\n* `for` loop initialization statements, that is, `int i = ...` within a `for(int i = ...;...)` statement\n* `for` loop update statements, that is, `i += 2` within a `for(int i = ...;...; i += 2)` statement\n\nUse the **Maximum statements per method** field to specify the maximum allowed number of statements in a method."
        },
        {
          "shortName": "OverlyLongLambda",
          "displayName": "Overly long lambda expression",
          "enabled": false,
          "description": "Reports lambda expressions whose number of statements exceeds the specified maximum.\n\nLambda expressions that are too long may be confusing, and it is often better to extract the statements into a separate method.\n\n\nThe following statements are not counted:\n\n* empty statements (semicolons)\n* block statements\n* `for` loop initialization statements, that is, `int i = ...` within a `for(int i = ...;...)` statement\n* `for` loop update statements, that is, `i += 2` within a `for(int i = ...;...; i += 2)` statement\n\nUse the **Non-comment source statements limit** field to specify the maximum allowed number of statements in a lambda expression."
        },
        {
          "shortName": "ParametersPerMethod",
          "displayName": "Method with too many parameters",
          "enabled": false,
          "description": "Reports methods whose number of parameters exceeds the specified maximum. Methods with too many parameters can be a good sign that a refactoring is necessary.\n\nMethods that have super methods are not reported.\n\nUse the **Parameter limit** field to specify the maximum allowed number of parameters for a method."
        },
        {
          "shortName": "MethodCoupling",
          "displayName": "Overly coupled method",
          "enabled": false,
          "description": "Reports methods that reference too many other classes. Methods with too high coupling can be very fragile and should be probably split into smaller methods.\n\nEach referenced class is counted only once no matter how many times it is referenced.\n\nConfigure the inspection:\n\n* Use the **Method coupling limit** field to specify the maximum allowed coupling for a method.\n* Use the **Include couplings to java system classes** option to count references to classes from `java`or `javax` packages.\n* Use the **Include couplings to library classes** option to count references to third-party library classes."
        },
        {
          "shortName": "ThrownExceptionsPerMethod",
          "displayName": "Method with too many exceptions declared",
          "enabled": false,
          "description": "Reports methods that have too many types of exceptions in its `throws` list.\n\nMethods with too many exceptions declared are a good sign that your error handling code is getting overly complex.\n\nUse the **Exceptions thrown limit** field to specify the maximum number of exception types a method is allowed to have in its `throws` list."
        },
        {
          "shortName": "CyclomaticComplexity",
          "displayName": "Overly complex method",
          "enabled": false,
          "description": "Reports methods that have too many branch points.\n\nA branch point is one of the following:\n\n* loop statement\n* `if` statement\n* ternary expression\n* `catch` section\n* expression with one or more `&&` or `||` operators inside\n* `switch` block with non-default branches\n\nMethods with too high cyclomatic complexity may be confusing and hard to test.\n\nUse the **Method complexity limit** field to specify the maximum allowed cyclomatic complexity for a method."
        },
        {
          "shortName": "ThreeNegationsPerMethod",
          "displayName": "Method with more than three negations",
          "enabled": false,
          "description": "Reports methods with three or more negations. Such methods may be confusing.\n\n**Example:**\n\n\n      void doSmth(int a, int b, boolean flag1, boolean flag2) {\n        if (!flag && !flag2) {\n          if (a != b) {\n            doOther();\n          }\n        }\n      }\n\nWithout negations, the method becomes easier to understand:\n\n\n      void doSmth(int a, int b, boolean flag1, boolean flag2) {\n        if (flag1 || flag2 || a == b) return;\n        doOther();\n      }\n\nConfigure the inspection:\n\n* Use the **Ignore negations in 'equals()' methods** option to disable the inspection within `equals()` methods.\n* Use the **Ignore negations in 'assert' statements** to disable the inspection within `assert` statements."
        },
        {
          "shortName": "ParametersPerConstructor",
          "displayName": "Constructor with too many parameters",
          "enabled": false,
          "description": "Reports constructors whose number of parameters exceeds the specified maximum. Such objects are hard to instantiate, especially if some parameters are optional. Constructors with too many parameters may indicate that refactoring is necessary. Consider applying the builder pattern, for example.\n\n**Example:**\n\n\n      public BankAccount(long accountNumber,\n                         String owner,\n                         double balance,\n                         double interestRate) {\n        // fields initialization\n      }\n\nConfigure the inspection:\n\n* Use the **Parameter limit** field to specify the maximum allowed number of parameters in a constructor.\n* Use the **Ignore constructors with visibility** list to specify whether the inspection should ignore constructors with specific visibility."
        },
        {
          "shortName": "MethodWithMultipleLoops",
          "displayName": "Method with multiple loops",
          "enabled": false,
          "description": "Reports methods that contain more than one loop statement.\n\n**Example:**\n\nThe method below will be reported because it contains two loops:\n\n\n      void methodWithTwoLoops(int n1, int n2) {\n        for (int i = 0; i < n1; i++) {\n          System.out.println(i);\n        }\n\n        int j = 0;\n        while (j < n2) {\n          System.out.println(j);\n          j++;\n        }\n      }\n\nThe following method will also be reported because it contains a nested loop:\n\n\n      void methodWithNestedLoop(int n1, int n2) {\n        for (int i = 0; i < n1; i++) {\n          for (int j = 0; j < n2; j++) {\n            System.out.println(i + j);\n          }\n        }\n      }\n"
        },
        {
          "shortName": "MultipleReturnPointsPerMethod",
          "displayName": "Method with multiple return points",
          "enabled": false,
          "description": "Reports methods whose number of `return` points exceeds the specified maximum. Methods with too many `return` points may be confusing and hard to refactor.\n\nA `return` point is either a `return` statement or a falling through the bottom of a\n`void` method or constructor.\n\n**Example:**\n\nThe method below is reported if only two `return` statements are allowed:\n\n\n      void doSmth(User[] users) {\n        for (User user : users) {\n          if (cond1(user)) {\n            user.setId(getId());\n            return;\n          } else if (cond2(user)) {\n            if (cond3(user)) {\n              user.setId(getId());\n              return;\n            }\n          }\n        }\n      }\n\nConsider rewriting the method so it becomes easier to understand:\n\n\n      void doSmth(User[] users) {\n        for (User user : users) {\n          if (cond1(user) || cond2(user) && cond3(user)) {\n            user.setId(getId());\n            return;\n          }\n        }\n      }\n\nConfigure the inspection:\n\n* Use the **Return point limit** field to specify the maximum allowed number of `return` points for a method.\n* Use the **Ignore guard clauses** option to ignore guard clauses. A guard clause is an `if` statement that contains only a `return` statement\n* Use the **Ignore for 'equals()' methods** option to ignore `return` points inside `equals()` methods."
        },
        {
          "shortName": "GroovyMethodParameterCount",
          "displayName": "Method with too many parameters",
          "enabled": false,
          "description": "Reports methods with too many parameters. Method with too many parameters is a good sign that refactoring is necessary. Methods whose signatures are inherited from library classes are ignored by this inspection.\n\n\nUse the **Maximum number of parameters:** field to specify the maximum acceptable number of parameters a method might have."
        },
        {
          "shortName": "GroovyMultipleReturnPointsPerMethod",
          "displayName": "Method with multiple return points",
          "enabled": false,
          "description": "Reports methods with too many return points. Methods with too many return points may be confusing, and hard to refactor.\n\n**Example:**\n\n\n      int foo(int a) {\n        if (a > 0) {\n          return a\n        }\n        if (a < 0) return -a\n        return 0\n      }\n\n\nUse the field provided below to specify the maximum acceptable number of return points a method\nmight have."
        },
        {
          "shortName": "GroovyOverlyLongMethod",
          "displayName": "Overly long method",
          "enabled": false,
          "description": "Reports methods that are too long.\n\n\nMethods that are too long\nmay be confusing, and are a good sign that refactoring is necessary.\n\n\nUse the **Maximum statements per method** field to specify the maximum acceptable number of non-comment source\nstatements a method might have."
        },
        {
          "shortName": "GroovyOverlyComplexMethod",
          "displayName": "Overly complex method",
          "enabled": false,
          "description": "Reports methods that have too high a cyclomatic complexity.\n\n\nCyclomatic\ncomplexity is basically a measurement of the number of branching points in a method. Methods with too high\na cyclomatic complexity may be confusing and difficult to test.\n\n\nUse the **Method complexity limit** field to specify the maximum acceptable cyclomatic complexity a method might have."
        },
        {
          "shortName": "GroovyOverlyNestedMethod",
          "displayName": "Overly nested method",
          "enabled": false,
          "description": "Reports methods whose bodies are too deeply nested.\n\n\nMethods with too much statement\nnesting may be confusing, and are a good sign that refactoring may be necessary.\n\n\nUse the **Maximum nesting depth** field to specify the maximum acceptable nesting depth a method might have."
        },
        {
          "shortName": "GroovyMethodWithMoreThanThreeNegations",
          "displayName": "Method with more than three negations",
          "enabled": false,
          "description": "Reports methods with three or more negation operations (`!` or `!=`). Such methods may be unnecessarily confusing."
        }
      ]
    },
    {
      "name": "Test frameworks",
      "inspections": [
        {
          "shortName": "MaskedAssertion",
          "displayName": "Assertion is suppressed by 'catch'",
          "enabled": false,
          "description": "Reports `assert` statements and test framework assertions that are suppressed by a surrounding catch block. Such assertions will never fail, as the thrown `AssertionError` will be caught and silently ignored.\n\n**Example 1:**\n\n\n      void javaAssertion() {\n        try {\n          ...\n          assert 1 == 2;\n        } catch (AssertionError e) {\n          // the assertion is silently ignored\n        }\n      }\n\n**Example 2:**\n\n\n      @Test\n      void testWithAssertJ() {\n        try {\n          ...\n          assertThat(1).as(\"test\").isEqualTo(2);\n        } catch (AssertionError e) {\n          // the assertion is silently ignored\n        }\n      }\n\n**Example 3:**\n\n\n      @Test\n      void testWithJunit() {\n        try {\n          ...\n          assertEquals(1, 2);\n        } catch (AssertionError e) {\n          // the assertion is silently ignored\n        }\n      }\n\nNew in 2020.3"
        },
        {
          "shortName": "MisorderedAssertEqualsArguments",
          "displayName": "Misordered 'assertEquals()' arguments",
          "enabled": false,
          "description": "Reports calls to `assertEquals()` that have the expected argument and the actual argument in the wrong order.\n\n\nFor JUnit 3, 4, and 5 the correct order is `(expected, actual)`.\nFor TestNG the correct order is `(actual, expected)`.\n\n\nSuch calls will behave fine for assertions that pass, but may give confusing error reports on failure.\nUse the quick-fix to flip the order of the arguments.\n\n**Example (JUnit):**\n\n\n      assertEquals(actual, expected)\n\nAfter the quick-fix is applied:\n\n\n      assertEquals(expected, actual)\n"
        },
        {
          "shortName": "AssertWithoutMessage",
          "displayName": "Message missing on assertion",
          "enabled": false,
          "description": "Reports calls to `assertXXX()` or `fail()` without an error message string argument. An error message on assertion failure may help clarify the test case's intent.\n\n**Example:**\n\n\n      assertTrue(checkValid());\n\nAfter the quick-fix is applied:\n\n    assertTrue(checkValid(), \"|\");\n\n\nThe message argument is added before or after the existing arguments according to the assertions framework that you use."
        },
        {
          "shortName": "SimplifiableAssertion",
          "displayName": "Simplifiable assertion",
          "enabled": false,
          "description": "Reports any `assert` calls that can be replaced with simpler and equivalent calls.\n\n|             Example              |  |       Replacement       |\n|----------------------------------|---|-------------------------|\n| `assertEquals(`**true**`, x());` |   | `assertTrue(x());`      |\n| `assertTrue(y() != null);`       |   | `assertNotNull(y());`   |\n| `assertTrue(z == z());`          |   | `assertSame(z, z());`   |\n| `assertTrue(a.equals(a()));`     |   | `assertEquals(a, a());` |\n| `assertTrue(`**false**`);`       |   | `fail();`               |"
        },
        {
          "shortName": "AssertBetweenInconvertibleTypes",
          "displayName": "'assertEquals()' between objects of inconvertible types",
          "enabled": false,
          "description": "Reports calls to assertion methods where the \"expected\" and \"actual\" arguments are of incompatible types.\n\nSuch calls often indicate that there is a bug in the test.\nThis inspection checks the relevant JUnit, TestNG, and AssertJ methods.\n\n**Examples:**\n\n\n      assertEquals(\"1\", 1);\n      assertNotSame(new int[0], 0);\n\n      // weak warning, may just test the equals() contract\n      assertThat(foo).as(\"user type\").isNotEqualTo(bar);\n"
        },
        {
          "shortName": "ConstantAssertArgument",
          "displayName": "Constant assert argument",
          "enabled": false,
          "description": "Reports constant arguments in `assertTrue()`, `assertFalse()`, `assertNull()`, and `assertNotNull()` calls.\n\n\nCalls to these methods with\nconstant arguments will either always succeed or always fail.\nSuch statements can easily be left over after refactoring and are probably not intended.\n\n**Example:**\n\n\n      assertNotNull(\"foo\");\n"
        }
      ]
    },
    {
      "name": "Bitwise operation issues",
      "inspections": [
        {
          "shortName": "ShiftOutOfRange",
          "displayName": "Shift operation by inappropriate constant",
          "enabled": true,
          "description": "Reports shift operations where the shift value is a constant outside the reasonable range.\n\nInteger shift operations outside the range `0..31` and long shift operations outside the\nrange `0..63` are reported. Shifting by negative or overly large values is almost certainly\na coding error.\n\n**Example:**\n\n\n      int shiftSize = 32;\n      // Warning: shift by 32 bits is equivalent to shift by 0 bits, so there's no shift at all.\n      int mask = (1 << shiftSize) - 1;\n"
        },
        {
          "shortName": "PointlessBitwiseExpression",
          "displayName": "Pointless bitwise expression",
          "enabled": true,
          "description": "Reports pointless bitwise expressions.\n\n\nSuch expressions include applying the `&` operator to the maximum value for the given type, applying the\n`or` operator to zero, and shifting by zero. Such expressions may be the result of automated\nrefactorings not followed through to completion and are unlikely to be originally intended.\n\n**Examples:**\n\n\n      // Warning: operation is pointless and can be replaced with just `flags`\n      // 0xFFFF_FFFF is the maximum value for an integer, and both literals are treated\n      // as 32 bit integer literals.\n      int bits = flags & 0xFFFF_FFFF;\n\n      // Warning: operation is pointless and can be replaced with just `bits`\n      // OR-ing with 0 always outputs the other operand.\n      int or = bits | 0x0;\n\n      // Warning: operation is pointless, as always results in 0\n      int xor = or ^ or;\n"
        },
        {
          "shortName": "IncompatibleMask",
          "displayName": "Incompatible bitwise mask operation",
          "enabled": true,
          "description": "Reports bitwise mask expressions which are guaranteed to evaluate to `true` or `false`.\n\n\nThe inspection checks the expressions of the form `(var & constant1) == constant2` or\n`(var | constant1) == constant2`, where `constant1`\nand `constant2` are incompatible bitmask constants.\n\n**Example:**\n\n      // Incompatible mask: as the mask ends in 00,\n      // the result could be 0x1200 but not 0x1234\n      if ((mask & 0xFF00) == 0x1234) {...}\n"
        }
      ]
    },
    {
      "name": "Reflective access",
      "inspections": [
        {
          "shortName": "JavaReflectionInvocation",
          "displayName": "Reflective invocation arguments mismatch",
          "enabled": true,
          "description": "Reports cases in which the arguments provided to `Method.invoke()` and `Constructor.newInstance()` do not match the signature specified in `Class.getMethod()` and `Class.getConstructor()`.\n\nExample:\n\n\n      Method m = myObj.getClass().getMethod(\"myMethod\", int.class);\n      // the argument should be an **int** value\n      m.invoke(myObj, \"abc\");\n\nNew in 2017.2"
        },
        {
          "shortName": "JavaLangInvokeHandleSignature",
          "displayName": "MethodHandle/VarHandle type mismatch",
          "enabled": true,
          "description": "Reports `MethodHandle` and `VarHandle` factory method calls that don't match any method or field.\n\nAlso reports arguments to `MethodHandle.invoke()` and similar methods, that don't match the `MethodHandle` signature\nand arguments to `VarHandle.set()` that don't match the `VarHandle` type.\n\n\nExamples:\n\n```\n  MethodHandle mh = MethodHandles.lookup().findVirtual(\n      MyClass.class, \"foo\", MethodType.methodType(void.class, int.class));\n  // the argument should be an int value\n  mh.invoke(myObj, \"abc\");\n```\n\n<br />\n\n```\n  // the argument should be String.class\n  VarHandle vh = MethodHandles.lookup().findVarHandle(\n      MyClass.class, \"text\", int.class);\n```\n\n<br />\n\n```\n  VarHandle vh = MethodHandles.lookup().findVarHandle(\n      MyClass.class, \"text\", String.class);\n  // the argument should be a String value\n  vh.set(myObj, 42);\n```\n\n\nNew in 2017.2"
        },
        {
          "shortName": "JavaReflectionMemberAccess",
          "displayName": "Reflective access to nonexistent/not visible class member",
          "enabled": true,
          "description": "Reports reflective access to fields and methods that don't exist or aren't visible.\n\nExample:\n\n\n      Field stringHashField() throws NoSuchFieldException {\n        return String.class.getField(\"hash\");\n      }\n\nAfter the quick-fix is applied:\n\n\n      Field stringHashField() throws NoSuchFieldException {\n        return String.class.getDeclaredField(\"hash\");\n      }\n\n\nWith a `final` class, it's clear if there is a field or method with the specified name in the class.\n\n\nWith non-`final` classes, it's possible that a subclass has a field or method with that name, so there could be false positives.\nUse the inspection's settings to get rid of such false positives everywhere or with specific classes.\n\nNew in 2017.2"
        },
        {
          "shortName": "Java9ReflectionClassVisibility",
          "displayName": "Reflective access across modules issues",
          "enabled": true,
          "description": "Reports `Class.forName()` and `ClassLoader.loadClass()` calls which try to access classes that aren't visible in the current scope due to Java 9 module accessibility rules.\n\nThis inspection only reports if the language level of the project or module is 9 or higher."
        }
      ]
    },
    {
      "name": "Java 14",
      "inspections": [
        {
          "shortName": "EnhancedSwitchMigration",
          "displayName": "Statement can be replaced with enhanced 'switch'",
          "enabled": false,
          "description": "Reports `switch` statements that can be automatically replaced with enhanced `switch` statements or expressions.\n\n**Example:**\n\n\n      double getPrice(String fruit) {\n        // Switch statement can be replaced with enhanced 'switch'\n        switch (fruit) {\n          case \"Apple\":\n            return 1.0;\n          case \"Orange\":\n            return 1.5;\n          case \"Mango\":\n            return 2.0;\n          default:\n            throw new IllegalArgumentException();\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      double getPrice(String fruit) {\n        return switch (fruit) {\n          case \"Apple\" -> 1.0;\n          case \"Orange\" -> 1.5;\n          case \"Mango\" -> 2.0;\n          default -> throw new IllegalArgumentException();\n        };\n      }\n      \nThis inspection only reports if the language level of the project or module is 14 or higher\n\nNew in 2019.1"
        },
        {
          "shortName": "EnhancedSwitchBackwardMigration",
          "displayName": "Enhanced 'switch'",
          "enabled": false,
          "description": "Reports enhanced `switch` statements and expressions. Suggests replacing them with regular `switch` statements.\n\n**Example:**\n\n\n      boolean even = switch (condition) {\n        case 1, 3, 5, 7, 9 -> false;\n        default -> true;\n      };\n\nAfter the quick-fix is applied:\n\n\n      boolean even;\n      switch (condition) {\n        case 1:\n        case 3:\n        case 5:\n        case 7:\n        case 9:\n          even = false;\n          break;\n        default:\n          even = true;\n          break;\n    }\n\nNew in 2019.1"
        }
      ]
    },
    {
      "name": "Validity issues",
      "inspections": [
        {
          "shortName": "GroovyDuplicateSwitchBranch",
          "displayName": "Duplicate switch case",
          "enabled": false,
          "description": "Reports duplicated expressions in `case` labels for `switch` statements.\n\n**Example:**\n\n\n    switch (n) {\n      case 1: //duplicate\n        break\n      case 1: //duplicate\n        System.out.println(\"2\")\n        break\n      default:\n        System.out.println(\"default\");\n    }\n\n"
        },
        {
          "shortName": "GroovyUnreachableStatement",
          "displayName": "Unreachable statement",
          "enabled": false,
          "description": "Reports statements that are unreachable. This can occur if the statement is after an infinite loop,\n`return`, `break`, or `continue` statement.\n\n**Example:**\n\n\n      void foo (int n) {\n          if (n < 1) {\n              return\n              print('This statement is unreachable')\n          }\n          while (true){\n              print ('Hello, world!')\n          }\n          print('This statement is unreachable too')\n      }\n"
        }
      ]
    },
    {
      "name": "Cast",
      "inspections": [
        {
          "shortName": "DoubleLiteralMayBeFloatLiteral",
          "displayName": "Cast to 'float' can be 'float' literal",
          "enabled": false,
          "description": "Reports `double` literal expressions that are immediately cast to `float`.\n\nSuch literal expressions can be replaced with equivalent `float` literals.\n\n**Example:**\n\n    float f = (float)1.1;\n\nAfter the quick-fix is applied:\n\n    float f = 1.1f;\n"
        },
        {
          "shortName": "UnnecessaryExplicitNumericCast",
          "displayName": "Unnecessary explicit numeric cast",
          "enabled": false,
          "description": "Reports primitive numeric casts that would be inserted implicitly by the compiler. Also, reports any primitive numeric casts that the compiler will remove.\n\n**Example:**\n\n    int x = (short)5; // The cast will be removed by the javac tool\n\nAfter the quick-fix is applied:\n`int x = 5;`"
        },
        {
          "shortName": "IntegerMultiplicationImplicitCastToLong",
          "displayName": "Integer multiplication or shift implicitly cast to 'long'",
          "enabled": true,
          "description": "Reports integer multiplications and left shifts that are implicitly cast to long.\n\n**Example:**\n\n\n      void f(int i) {\n        long val = 65536 * i;\n      }\n\nAfter the quick-fix is applied, the code changes to:\n\n\n      void x(int i) {\n        long val = 65536L * i;\n      }\n\n**Example:**\n\n\n      void f(int i) {\n        long value = i << 24;\n      }\n\nAfter the quick-fix is applied, the code changes to:\n\n\n      void f(int i) {\n        long value = (long) i << 24;\n      }\n\n\nSuch multiplications are often a mistake, as overflow truncation may occur unexpectedly.\nConverting an `int` literal to a `long` literal (`65536`**L**) fixes the problem."
        },
        {
          "shortName": "IntLiteralMayBeLongLiteral",
          "displayName": "Cast to 'long' can be 'long' literal",
          "enabled": false,
          "description": "Reports `int` literal expressions that are immediately cast to `long`.\n\nSuch literal expressions can be replaced with equivalent `long` literals.\n\n**Example:**\n\n    Long l = (long)42;\n\nAfter the quick-fix is applied:\n\n    Long l = 42L;\n"
        },
        {
          "shortName": "CastThatLosesPrecision",
          "displayName": "Numeric cast that loses precision",
          "enabled": false,
          "description": "Reports cast operations between primitive numeric types that may result in precision loss.\n\nSuch casts are not necessarily a problem but may result in difficult to\ntrace bugs if the loss of precision is unexpected.\n\n**Example:**\n\n\n      int a = 420;\n      byte b = (byte) a;\n\nUse the **Ignore casts from int to char** option to ignore casts from `int` to `char`.\nThis type of cast is often used when implementing I/O operations because the `read()` method of the\n`java.io.Reader` class returns an `int`.\n\nUse the **Ignore casts from int 128-255 to byte** option to ignore casts of constant values (128-255) from `int` to\n`byte`.\nSuch values will overflow to negative numbers that still fit inside a byte."
        }
      ]
    },
    {
      "name": "Description file",
      "inspections": [
        {
          "shortName": "IntentionDescriptionNotFoundInspection",
          "displayName": "Intention description checker",
          "enabled": false,
          "description": "Reports intentions that are missing an HTML description file, `before.template` file or `after.template` file. These are shown in [Settings \\| Editor \\| Intentions](settings://preferences.intentionPowerPack).\n\n\nThe **Create description file** quick-fix creates a template HTML description file."
        },
        {
          "shortName": "InspectionDescriptionNotFoundInspection",
          "displayName": "Inspection description checker",
          "enabled": false,
          "description": "Reports inspections that are missing an HTML description file, i.e. a file containing a text like this.\n\n\nThe **Create description file** quick-fix creates a template HTML description file."
        },
        {
          "shortName": "PostfixTemplateDescriptionNotFound",
          "displayName": "Postfix template description checker",
          "enabled": false,
          "description": "Reports postfix templates missing an HTML description file, `before.template` file or `after.template` file. These are shown in [Settings \\| Editor \\| General \\| Postfix Completion](settings://reference.settingsdialog.IDE.editor.postfix.templates).\n\n\nThe **Create description file** quick-fix creates a template HTML description file."
        }
      ]
    },
    {
      "name": "JSON and JSON5",
      "inspections": [
        {
          "shortName": "Json5StandardCompliance",
          "displayName": "Compliance with JSON5 standard",
          "enabled": false,
          "description": "Reports inconsistency with [the language specification](http://json5.org) in a JSON5 file."
        },
        {
          "shortName": "JsonPathUnknownFunction",
          "displayName": "Unknown JSONPath function",
          "enabled": false,
          "description": "Reports an unknown name in a JSONPath function call instead of known standard function names: `concat`, `keys`, `length`, `min`, `max`, `avg`, `stddev`, `sum`."
        },
        {
          "shortName": "JsonSchemaCompliance",
          "displayName": "Compliance with JSON schema",
          "enabled": false,
          "description": "Reports inconsistence between a JSON file and the [JSON schema](https://json-schema.org) that is assigned to it.  "
        },
        {
          "shortName": "JsonStandardCompliance",
          "displayName": "Compliance with JSON standard",
          "enabled": false,
          "description": "Reports the following discrepancies of a JSON file with [the language specification](https://tools.ietf.org/html/rfc7159):\n\n* A line or block comment (configurable).\n* Multiple top-level values (expect for JSON Lines files, configurable for others).\n* A trailing comma in an object or array (configurable).\n* A single quoted string.\n* A property key is a not a double quoted strings.\n* A NaN or Infinity/-Infinity numeric value as a floating point literal (configurable)."
        },
        {
          "shortName": "JsonSchemaDeprecation",
          "displayName": "Deprecated JSON property",
          "enabled": false,
          "description": "Reports a deprecated property in a JSON file.  \nNote that deprecation mechanism is not defined in the JSON Schema specification yet, and this inspection uses a non-standard extension 'deprecationMessage'."
        },
        {
          "shortName": "JsonSchemaRefReference",
          "displayName": "Unresolved '$ref' and '$schema' references",
          "enabled": false,
          "description": "Reports an unresolved `$ref` or `$schema` path in a JSON schema.  "
        },
        {
          "shortName": "JsonPathEvaluateUnknownKey",
          "displayName": "Unknown property key used for JSONPath evaluate expression",
          "enabled": false,
          "description": "Reports a key in a JSONPath expression that is missing in the source JSON document to evaluate."
        },
        {
          "shortName": "JsonDuplicatePropertyKeys",
          "displayName": "Duplicate keys in object literals",
          "enabled": false,
          "description": "Reports a duplicate key in an object literal."
        },
        {
          "shortName": "JsonPathUnknownOperator",
          "displayName": "Unknown JSONPath operator",
          "enabled": false,
          "description": "Reports an unknown operator on a JSONPath expression instead of one of the standard ones: `in`, `nin`, `subsetof`, `anyof`, `noneof`, `size`, `empty`, `contains`."
        }
      ]
    },
    {
      "name": "XPath",
      "inspections": [
        {
          "shortName": "RedundantTypeConversion",
          "displayName": "Redundant type conversion",
          "enabled": false,
          "description": "Reports unnecessary type conversions. Type conversions are unnecessary when the argument type of a `string()`, `number()`, or `boolean()` function is already the same as the function's return type or if the expected expression type is `any`. Suggests removing the unnecessary conversion.\n\nPowered by XPathView + XSLT-Support"
        },
        {
          "shortName": "IndexZeroUsage",
          "displayName": "XPath predicate with index 0",
          "enabled": false,
          "description": "Reports usages of `0` in a predicate index or in a comparison with the function `position()`. Such usage is almost always a bug because in XPath, the index starts at `1`, *not* at`0`.\n\n**Example:**\n\n\n      //someelement[position() = 0] or //something[0]\n\nPowered by XPathView + XSLT-Support"
        },
        {
          "shortName": "CheckNodeTest",
          "displayName": "Unknown element or attribute name",
          "enabled": false,
          "description": "Reports names of elements or attributes that are used in an XPath-expression but are missing in the associated XML files and are not defined in the referenced schemas. Such names are often the result of typos and would otherwise probably only be discovered at runtime.\n\n**Example:**\n\n\n      <xsl:template match=\"h:txtarea\" />\n\n\nIf the `h` is bound to the XHTML namespace, the inspection will report this part of the `match` expression as an\nunknown element name because the correct name of the element is \"textarea\".\n\nPowered by XPathView + XSLT-Support"
        },
        {
          "shortName": "HardwiredNamespacePrefix",
          "displayName": "Hardcoded namespace prefix",
          "enabled": false,
          "description": "Reports comparisons of the `name()` function with a string that contains a colon (`:`). Such usages usually indicate a hardcoded namespace prefix in the comparison. As a result, the code will break when run against XML that uses another prefix for the same namespace.\n\n**Example:**\n\n\n      <xsl:if test=\"name() = 'xlink:href'\">...<xsl:if>\n\nPowered by XPathView + XSLT-Support"
        },
        {
          "shortName": "ImplicitTypeConversion",
          "displayName": "Implicit type conversion",
          "enabled": false,
          "description": "Reports implicit conversions between the predefined XPath-types `STRING`, `NUMBER`, `BOOLEAN`, and `NODESET`. Helps to write XSLT scripts that are more expressive about types and prevents subtle bugs:\n\n**Example:**\n\n\n      <xsl:if test=\"foo\" />\n\nis not the same as\n\n\n      <xsl:if test=\"string(foo)\" />\n\n\nThe first test checks whether the element \"foo\" exists (`count(foo) > 0)`; the latter one however is only\ntrue if the element actually contains any text (`string-length(foo) > 0`). Suggests making\nthe type conversion more explicit.\n\n\nUse the following options to configure the inspection:\n\n* Enable or disable implicit conversions between certain types\n* Always report explicit conversions that do not result in the actually expected type, for example, `<xsl:if test=\"number(foo)\" />`\n* Ignore conversion from `NODESET` to `BOOLEAN` by using the `string()` function as a shortcut for writing `string-length() > 0`.\n\nPowered by XPathView + XSLT-Support"
        }
      ]
    },
    {
      "name": "Java 10",
      "inspections": [
        {
          "shortName": "VariableTypeCanBeExplicit",
          "displayName": "Variable type can be explicit",
          "enabled": false,
          "description": "Reports local variables of the `var` type that can be replaced withvan explicit type.\n\nThe inspection can help find and eliminate usages of implicit types in case of downgrading.\n\n**Example:**\n\n\n      var str = \"Hello\";\n\nAfter the quick-fix is applied:\n\n\n      String str = \"Hello\";\n\nThis inspection only reports if the language level of the project or module is 10 or higher."
        },
        {
          "shortName": "RedundantExplicitVariableType",
          "displayName": "Local variable type can be omitted",
          "enabled": false,
          "description": "Reports redundant local variable types.\n\nThese types can be inferred from the context and thus replaced with `var`.\n\n**Example:**\n\n\n      void test(InputStream s) {\n        try (InputStream in = s) {}\n      }\n\nAfter the fix is applied:\n\n\n      void test(InputStream s) {\n        try (var in = s) {}\n      }\n"
        }
      ]
    },
    {
      "name": "Java 7",
      "inspections": [
        {
          "shortName": "EqualsReplaceableByObjectsCall",
          "displayName": "'equals()' expression replaceable by 'Objects.equals()' expression",
          "enabled": false,
          "description": "Reports expressions that can be replaced with a call to `java.util.Objects#equals`.\n\n**Example:**\n\n\n      void f(Object a, Object b) {\n        boolean result = a != null && a.equals(b);\n      }\n\nAfter the quick-fix is applied:\n\n\n      void f(Object a, Object b) {\n        boolean result = Objects.equals(a, b);\n      }\n\n\nReplacing expressions like `a != null && a.equals(b)` with `Objects.equals(a, b)`\nslightly changes the semantics. Use the **Highlight expressions like 'a != null \\&\\& a.equals(b)'** option to enable or disable this behavior.\n\nThis inspection only reports if the language level of the project or module is 7 or higher."
        },
        {
          "shortName": "SafeVarargsDetector",
          "displayName": "Possible heap pollution from parameterized vararg type",
          "enabled": false,
          "description": "Reports all methods with variable arity, which can be annotated as `@SafeVarargs`. The `@SafeVarargs` annotation suppresses unchecked warnings about parameterized array creation at call sites.\n\n**Example:**\n\n\n      public class Foo<T> {\n        private List<T> list = new ArrayList<>();\n\n        public final void safeVarargs(T... elements) {\n          Collections.addAll(list, elements);\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      public class Foo<T> {\n        private List<T> list = new ArrayList<>();\n\n        @SafeVarargs\n        public final void safeVarargs(T... elements) {\n          Collections.addAll(list, elements);\n        }\n      }\n\n\nThis annotation is not supported under Java 1.6 or earlier JVMs."
        },
        {
          "shortName": "TryWithIdenticalCatches",
          "displayName": "Identical 'catch' branches in 'try' statement",
          "enabled": false,
          "description": "Reports identical `catch` sections in a single `try` statement.\n\nCollapsing such sections into one *multi-catch* block reduces code duplication and prevents\nthe situations when one `catch` section is updated, and another one is not.\n\n**Example:**\n\n\n        try {\n            doSmth();\n        }\n        catch (IOException e) {\n            LOG.error(e);\n        }\n        catch (URISyntaxException e) {\n            LOG.error(e);\n        }\n\nA quick-fix is available to make the code more compact:\n\n\n        try {\n            doSmth();\n        }\n        catch (IOException | URISyntaxException e) {\n            LOG.error(e);\n        }\n\nThis inspection only reports if the language level of the project or module is 7 or higher."
        },
        {
          "shortName": "Convert2Diamond",
          "displayName": "Explicit type can be replaced with '<>'",
          "enabled": false,
          "description": "Reports all `new` expressions with type arguments that can be replaced a with diamond type `<>`.\n\nExample:\n\n\n      List<String> list = new ArrayList<String>(); // reports array list type argument\n\nAfter the quick-fix is applied:\n\n\n      List<String> list = new ArrayList<>();\n\nThis inspection only reports if the language level of the project or module is 7 or higher."
        },
        {
          "shortName": "TryFinallyCanBeTryWithResources",
          "displayName": "'try finally' can be replaced with 'try' with resources",
          "enabled": false,
          "description": "Reports `try`-`finally` statements that can use Java 7 Automatic Resource Management, which is less error-prone.\n\nA quick-fix is available to convert a `try`-`finally`\nstatement into a `try`-with-resources statement.\n\n**Example:**\n\n\n      PrintStream printStream = new PrintStream(fileName);\n      try {\n        printStream.print(true);\n      } finally {\n        printStream.close();\n      }\n\nA quick-fix is provided to pass the cause to a constructor:\n\n\n      try (PrintStream printStream = new PrintStream(fileName)) {\n        printStream.print(true);\n      }\n\nThis inspection only reports if the language level of the project or module is 7 or higher."
        }
      ]
    },
    {
      "name": "Version control",
      "inspections": [
        {
          "shortName": "IgnoreFileDuplicateEntry",
          "displayName": "Ignore file duplicates",
          "enabled": false,
          "description": "Reports duplicate entries (patters) in the ignore file (e.g. .gitignore, .hgignore). Duplicate entries in these files are redundant and can be removed.\n\nExample:\n\n```\n    # Output directories\n    /out/\n    /target/\n    /out/\n```"
        }
      ]
    },
    {
      "name": "Gradle",
      "inspections": [
        {
          "shortName": "GradleKotlinxCoroutinesDeprecation",
          "displayName": "Incompatible kotlinx.coroutines dependency is used with Kotlin 1.3+ in Gradle",
          "enabled": true,
          "description": "Reports `kotlinx.coroutines` library dependencies in Gradle that should be updated to be compatible with Kotlin 1.3+.\n\n**Example:**\n\n\n      dependencies {\n          implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:0.0.1'\n      }\n\nThe quick fix changes the `kotlinx.coroutines` library version to a compatible with Kotlin 1.3:\n\n\n      dependencies {\n          implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:0.27.0-eap13'\n      }\n"
        }
      ]
    },
    {
      "name": "Nullability problems",
      "inspections": [
        {
          "shortName": "NullableProblems",
          "displayName": "@NotNull/@Nullable problems",
          "enabled": false,
          "description": "Reports problems related to nullability annotations.\n\n**Examples:**\n\n* Overriding methods are not annotated:\n\n\n      abstract class A {\n        @NotNull abstract String m();\n      }\n      class B extends A {\n          String m() { return \"empty string\"; }\n      }\n          \n* Annotated primitive types: `@NotNull int myFoo;`\n* Both `@Nullable` and `@NotNull` are present on the same member: `@Nullable @NotNull String myFooString;`\n* Collection of nullable elements is assigned into a collection of non-null elements:\n\n\n      void testList(List<@Nullable String> nullableList) {\n         List<@NotNull String> list2 = nullableList;\n      }\n          \nUse the **Configure Annotations** button to specify nullability annotations and the checkboxes to fine-tune where the inspection should provide warnings.\n\nThis inspection only reports if the language level of the project or module is 5 or higher,\nand nullability annotations are available on the classpath."
        },
        {
          "shortName": "ReturnNull",
          "displayName": "Return of 'null'",
          "enabled": false,
          "description": "Reports `return` statements with `null` return values. While occasionally useful, this construct may make the code more prone to failing with a `NullPointerException`.\n\n\nIf a method is designed to return `null`, it is suggested to mark it with the\n`@Nullable` annotation - such methods will be ignored by this inspection.\n\n**Example:**\n\n\n      class Person {\n        public String getName () {\n          return null;\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      class Person {\n        @Nullable\n        public String getName () {\n          return null;\n        }\n      }\n\n\nIf the return type is `java.util.Optional`, an additional quick-fix to convert\n`null` to `Optional.empty()` is suggested.\n\n\nUse the following options to configure the inspection:\n\n* Whether to ignore `private` methods. This will also ignore return of `null` from anonymous classes and lambdas.\n* Whether `null` values on array returns, collection object returns, plain object returns, or a combination of the three should be reported. Return of `null` in methods with return type `java.util.Optional` are always reported.\n* Click **Configure annotations** to specify which annotations should be considered 'nullable'."
        },
        {
          "shortName": "NotNullFieldNotInitialized",
          "displayName": "@NotNull field is not initialized",
          "enabled": false,
          "description": "Reports fields annotated as not-null that are not initialized in the constructor.\n\nExample:\n\n    public class MyClass {\n      private @NotNull String value;\n\n      public void setValue(@NotNull String value) {\n        this.value = value;\n      }\n\n      public @NotNull String getValue() {\n        return value;\n      }\n      }\n\n\nSuch fields may violate the not-null constraint. In the example above, the `setValue` parameter is annotated as not-null, but\n`getValue` may return null if the setter was not called.\n\nConfigure the inspection:\n\n* Use the **Ignore fields which could be initialized implicitly** option to control whether a warning should be issued if the field could be initialized implicitly (e.g. via a dependency injection).\n* Use the **Ignore fields initialized in setUp() method** option to control whether a warning should be issued if the field is written in the test case `setUp()` method."
        },
        {
          "shortName": "UnsatisfiedRange",
          "displayName": "Return value is outside of declared range",
          "enabled": false,
          "description": "Reports numeric values returned from methods that don't conform to the declared method return range. You can declare method return range using a number of annotations:\n\n* `org.jetbrains.annotations.Range` from JetBrains annotations package (specify 'from' and 'to')\n* `org.checkerframework.common.value.qual.IntRange` from Checker Framework annotations package (specify 'from' and 'to')\n* `org.checkerframework.checker.index.qual.GTENegativeOne` from Checker Framework annotations package (range is '\\>= -1')\n* `org.checkerframework.checker.index.qual.NonNegative` from Checker Framework annotations package (range is '\\>= 0')\n* `org.checkerframework.checker.index.qual.Positive` from Checker Framework annotations package (range is '\\> 0')\n* `javax.annotation.Nonnegative` from JSR 305 annotations package (range is '\\>= 0')\n* `javax.validation.constraints.Min` (specify minimum value)\n* `javax.validation.constraints.Max` (specify maximum value)\n\nExample:\n\n\n      @Range(from = 0, to = Integer.MAX_VALUE) int getValue() {\n        // Warning: -1 is outside of declared range\n        return -1;\n      }\n\nNew in 2021.2"
        }
      ]
    },
    {
      "name": "Structural search",
      "inspections": [
        {
          "shortName": "SSBasedInspection",
          "displayName": "Structural search inspection",
          "enabled": true,
          "description": "Allows configuring **Structural Search/Structural Replace** templates that you can apply to the file you are editing.\n\nAll matches will be highlighted and marked with the template name that you have configured.\nIf you configure the **Structural Replace** pattern as well, the corresponding replace option will be available as a quick-fix."
        }
      ]
    },
    {
      "name": "toString() issues",
      "inspections": [
        {
          "shortName": "FieldNotUsedInToString",
          "displayName": "Field not used in 'toString()' method",
          "enabled": false,
          "description": "Reports any fields that are not used in the `toString()` method of a class.\n\nThis inspection can help discover the\nfields that were added after the `toString()` method was created and for which the `toString()` method was not\nupdated. The quick-fix regenerates the `toString()` method.\n\n\nIn the **Generate \\| toString()** dialog, it is possible to exclude fields from this check.\nThis inspection will also check for problems with getter methods if the *Enable getters in code generation* option is enabled there.\n\nExample:\n\n\n      public class Relevant {\n        private String name; // not used in toString()\n        private int index;\n        private int length;\n\n        @Override\n        public String toString() {\n            return \"Relevant{\" + \"index=\" + index +\n              \", length=\" + length + '}';\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      public class Relevant {\n        private String name;\n        private int index;\n        private int length;\n\n        @Override\n        public String toString() {\n            return \"Relevant{\" + \"name='\" + name + '\\'' +\n              \", index=\" + index + \", length=\" + length + '}';\n        }\n      }\n"
        },
        {
          "shortName": "ClassHasNoToStringMethod",
          "displayName": "Class does not override 'toString()' method",
          "enabled": false,
          "description": "Reports classes without a `toString()` method."
        }
      ]
    },
    {
      "name": "RELAX NG",
      "inspections": [
        {
          "shortName": "UnresolvedReference",
          "displayName": "Unresolved reference",
          "enabled": false,
          "description": "Reports an unresolved reference to a named pattern (`define`) in RELAX-NG files that use XML syntax. Suggests creating the referenced `define` element."
        },
        {
          "shortName": "UnusedDefine",
          "displayName": "Unused define",
          "enabled": false,
          "description": "Reports an unused named pattern (`define`) in a RELAX-NG file (XML or Compact Syntax). `define` elements that are used through an include in another file are ignored."
        }
      ]
    },
    {
      "name": "Java 11",
      "inspections": [
        {
          "shortName": "ReadWriteStringCanBeUsed",
          "displayName": "'Files.readString()' or 'Files.writeString()' can be used",
          "enabled": false,
          "description": "Reports code fragments that read or write a `String` as bytes using `java.nio.file.Files`.\n\nThese fragments can be replaced with calls to the `Files.readString()` and `Files.writeString()` methods introduced in Java 11.\n\n**Example:**\n\n\n      String s = \"example\";\n      Files.write(Paths.get(\"out.txt\"), s.getBytes(StandardCharsets.UTF_8), StandardOpenOption.WRITE);\n      s = new String(Files.readAllBytes(Paths.get(\"in.txt\")), StandardCharsets.ISO_8859_1);\n\nAfter the quick fix is applied:\n\n\n      String s = \"example\";\n      Files.writeString(Paths.get(\"out.txt\"), s, StandardOpenOption.WRITE);\n      s = Files.readString(Paths.get(\"in.txt\"), StandardCharsets.ISO_8859_1);\n\nNew in 2018.3"
        },
        {
          "shortName": "StringRepeatCanBeUsed",
          "displayName": "String.repeat() can be used",
          "enabled": false,
          "description": "Reports loops that can be replaced with a single `String.repeat()` method (available since Java 11).\n\n**Example:**\n\n\n      void append(StringBuilder sb, int count, Object obj) {\n        for (int i = 0; i < count; i++) {\n          sb.append(obj);\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      void append(StringBuilder sb, int count, Object obj) {\n        sb.append(String.valueOf(obj).repeat(Math.max(0, count)));\n      }\n\n\nBy default, the inspection may wrap `count` with `Math.max(0, count)` if it cannot prove statically that `count` is\nnot negative. This is done to prevent possible semantics change, as `String.repeat()` rejects negative numbers.\nUse the **Add Math.max(0,count) to avoid possible semantics change** option to disable this behavior if required.\n\nSimilarly, a string you want to repeat can be wrapped in\n`String.valueOf` to prevent possible `NullPointerException` if it's unknown whether it can be `null`.\n\nThis inspection only reports if the language level of the project or module is 11 or higher.\n\nNew in 2019.1"
        }
      ]
    }
  ]
}